<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hhuysqt</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-27T19:01:32.613Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hhuysqt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zynq[3] bootstrap Ubuntu</title>
    <link href="http://yoursite.com/zynq3/"/>
    <id>http://yoursite.com/zynq3/</id>
    <published>2019-04-27T09:05:56.000Z</published>
    <updated>2019-04-27T19:01:32.613Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu、Debian之类的不同的发行版，其实就是不同的<code>rootfs</code>。Debian系的发行版有个工具叫<code>debootstrap</code>，可以从<code>源</code>那里下载最小的根文件系统。Arch相应的工具则是<code>packstrap</code>。</p><p>下完根文件系统之后<code>chroot</code>进去进行相应的配置，为了chroot到一个ARM的rootfs，我们需要用<code>qemu-arm-static</code>。进去之后<code>apt-get</code>你想要安装的东西。配完了之后烧进sd卡，通过内核参数<code>root=xxxx</code>告诉内核要挂载哪个rootfs，即可启动了。</p><p>要制作一个叉叉派的镜像都是这样的套路：bootstrap一个最小系统，安装内核模块，安装必要的应用程序，然后安装不同的桌面环境，最后打包。于是就制作出各种水果派的n多镜像，像Ubuntu core、Ubuntu mate、xubuntu、lubuntu、Debian，Arch等等，应有尽有。。</p><p>然而这些大型发行版的“最小系统”都相当的大，几百兆的样子，而我们的EBAZ4205只有128M的nand flash，所以只好从sd卡启动才能维持得了生活。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们先在一台Ubuntu主机上安装<code>qemu-user-static</code>、<code>debootstrap</code>，然后继续。后文一些命令如果没有安装，随时apt-get一下。</p><h4 id="准备镜像文件"><a href="#准备镜像文件" class="headerlink" title="准备镜像文件"></a>准备镜像文件</h4><p>我们<code>dd</code>一个3.7G的空白镜像，这样可以烧录进一个标明4G的SD卡。姑且叫它<code>ubuntu1804.img</code>吧：</p><pre><code class="bash">dd if=/dev/zero of=ubuntu1804.img bs=1M count=3500</code></pre><p>然后我们将它挂载为<code>loop</code>设备：</p><pre><code class="bash">sudo losetup -f --show ubuntu1804.img</code></pre><p>如果你之前没有挂过别的回环设备的话，一般它会挂在<code>/dev/loop0</code>。</p><p>然后我们给它分区。可以用图形界面的工具如<code>gparted</code>，也可以用命令行工具如<code>parted</code>、<code>fdisk</code>等。比方说我们用fdisk。</p><pre><code class="bash">sudo fdisk /dev/loop0</code></pre><p>用<code>n</code>来添加新分区。顺着它的指示走下去即可。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">文件系统</th><th style="text-align:left">大小</th></tr></thead><tbody><tr><td style="text-align:left">启动分区</td><td style="text-align:left">vfat</td><td style="text-align:left">256MB就够了</td></tr><tr><td style="text-align:left">文件系统</td><td style="text-align:left">ext4</td><td style="text-align:left">3.2G</td></tr></tbody></table><p>同步这些分区。这样会在<code>/dev/mapper/</code>下面生成对应的节点：</p><pre><code class="bash">sudo kpartx -av /dev/loop0</code></pre><p>格式化它们：</p><pre><code class="bash">sudo mkfs.vfat /dev/mapper/loop0p1sudo mkfs.ext4 /dev/mapper/loop0p2</code></pre><p>挂载它们：</p><pre><code class="bash">mkdir boot rootfssudo mount /dev/mapper/loop0p1 bootsudo mount /dev/mapper/loop0p2 rootfs</code></pre><h4 id="uboot和设备树改动"><a href="#uboot和设备树改动" class="headerlink" title="uboot和设备树改动"></a>uboot和设备树改动</h4><p>我们要修改uboot环境变量，让它从SD卡里面读取内核和设备树。不过zc702工程的默认启动设备就是sd卡，我们只需要留意<code>sdboot</code>这个环境变量以及各种地址就好了：</p><pre><code class="diff">-    &quot;kernel_load_address=0x2080000\0&quot; \+    &quot;kernel_load_address=0x8000\0&quot; \...-    &quot;devicetree_image=devicetree.dtb\0&quot;    \-    &quot;devicetree_load_address=0x2000000\0&quot;    \+    &quot;devicetree_image=zynq-zc702.dtb\0&quot;    \+    &quot;devicetree_load_address=0x0\0&quot;    \...     &quot;sdboot=if mmcinfo; then &quot; \-        &quot;run uenvboot; &quot; \         &quot;echo Copying Linux from SD to RAM... &amp;&amp; &quot; \         &quot;load mmc 0 ${kernel_load_address} ${kernel_image} &amp;&amp; &quot; \         &quot;load mmc 0 ${devicetree_load_address} ${devicetree_image} &amp;&amp; &quot; \-        &quot;load mmc 0 ${ramdisk_load_address} ${ramdisk_image} &amp;&amp; &quot; \-        &quot;bootm ${kernel_load_address} ${ramdisk_load_address} ${devicetree_load_address}; &quot; \+        &quot;bootm ${kernel_load_address} - ${devicetree_load_address}; &quot; \     &quot;fi\0&quot; \</code></pre><p>我们还要修改设备树，添加启动参数，让内核挂载Ubuntu文件系统。其中<code>rootwait</code>这个参数表示需要等待根文件系统的挂载，不然内核启动很快，一看还没有挂上文件系统就会kernel panic了：</p><pre><code class="diff">     chosen {-        bootargs = &quot;&quot;;+        bootargs = &quot;root=/dev/mmcblk0p2 rw rootwait&quot;;         stdout-path = &quot;serial0:115200n8&quot;;     };</code></pre><p>将<code>BOOT.bin</code>、<code>uImage</code>、<code>zynq-zc702.dtb</code>放进启动分区。</p><h3 id="安装最小系统"><a href="#安装最小系统" class="headerlink" title="安装最小系统"></a>安装最小系统</h3><p>接着就可以愉快地debootstrap了。不过可惜的是，国内Ubuntu源都没有同步<code>armhf</code>的port，只有x86的，所以只能用官方源了。</p><pre><code class="bash">sudo debootstrap --arch=armhf --foreign bionic ./rootfs</code></pre><p>但是国内的Debian就同步了arm的分支，比方说清华源：</p><pre><code class="bash">sudo debootstrap --arch=armhf --foreign stretch ./rootfs https://mirrors.tuna.tsinghua.edu.cn/debian/</code></pre><p>等一段时间下完基本系统，然后拷贝<code>qemu</code>进去：</p><pre><code class="bash">sudo cp -av /usr/bin/qemu-arm-static rootfs/usr/bin/</code></pre><p>还需要拷贝<code>resolv.conf</code>，以便联网：</p><pre><code class="bash">sudo cp /run/systemd/resolve/stub-resolv.conf rootfs/etc/resolv.conf </code></pre><p>然后<code>chroot</code>进去：</p><pre><code class="bash">sudo chroot ./rootfs</code></pre><p>在里面进行<code>second-stage</code>：</p><pre><code class="bash"># chroot环境下面：export LANG=C/debootstrap/debootstrap --second-stage</code></pre><p>安装完成之后，补全<code>/etc/apt/source.list</code>：</p><pre><code>deb http://ports.ubuntu.com/ubuntu-ports bionic main restricted universe multiversedeb http://ports.ubuntu.com/ubuntu-ports bionic-security main restricted universe multiversedeb http://ports.ubuntu.com/ubuntu-ports bionic-updates main restricted universe multiversedeb http://ports.ubuntu.com/ubuntu-ports bionic-proposed main restricted universe multiversedeb http://ports.ubuntu.com/ubuntu-ports bionic-backports main restricted universe multiversedeb-src http://ports.ubuntu.com/ubuntu-ports bionic main restricted universe multiversedeb-src http://ports.ubuntu.com/ubuntu-ports bionic-security main restricted universe multiversedeb-src http://ports.ubuntu.com/ubuntu-ports bionic-updates main restricted universe multiversedeb-src http://ports.ubuntu.com/ubuntu-ports bionic-proposed main restricted universe multiversedeb-src http://ports.ubuntu.com/ubuntu-ports bionic-backports main restricted universe multiverse</code></pre><p>然后装一些基本的软件：</p><pre><code class="bash">apt-get updateapt-get install sudo ifupdown net-tools ethtool udev wireless-tools iputils-ping resolvconf wget apt-utils wpasupplicant vim git gcc build-essential openssh-server</code></pre><p>新建用户，就叫它ubuntu吧，密码也是ubuntu：</p><pre><code class="bash">useradd -G sudo -m -s /bin/bash ubuntuecho ubuntu:ubuntu | chpasswd</code></pre><p>更改root密码：</p><pre><code class="bash">passwd root</code></pre><p>设置主机名为<code>armhf</code>：</p><pre><code class="bash">echo armhf &gt; /etc/hostname</code></pre><p>设置网络，改<code>/etc/network/interfaces</code>文件：</p><pre><code>auto loiface lo inet loopbackallow-hotplug eth0iface eth0 inet dhcp</code></pre><p>终端配色：将<code>/home/ubuntu/.bashrc</code>里面的<code>force_color_prompt=yes</code>注释删掉即可。</p><p>设置默认挂载目录：改<code>/etc/fstab</code>，将启动分区挂载到<code>/boot</code>目录上：</p><pre><code>/dev/mmcblk0p1 /boot vfat defaults 0 0</code></pre><p>如果没什么别的想要配置的话，就可以<code>exit</code>退出了。</p><h3 id="烧录SD卡"><a href="#烧录SD卡" class="headerlink" title="烧录SD卡"></a>烧录SD卡</h3><p>我们将镜像文件卸载：</p><pre><code class="bash">sudo umount ./bootsudo umount ./rootfssudo kpartx -d /dev/loop0sudo losetup -d /dev/loop0</code></pre><p>我们看到这个镜像文件有3.7G那么大，但是世界上它占用的磁盘空间没那么大，它是个<code>sparse file</code>，将它打包压缩之后就没看上去那么大了。可以用<code>ls -s</code>来看到它实际上多大：</p><pre><code>$ ls -sh ubuntu1804.img 1.2G ubuntu1804.img</code></pre><p>现在我们直接将这个文件dd到一张SD卡里面：</p><pre><code class="bash">dd if=ubuntu1804.img of=/dev/sd某</code></pre><p>如果你的SD卡不只有4G，那么可以通过像<code>gparted</code>、<code>parted</code>、<code>fdisk</code>等等的分区工具将第二个分区拉大，然后<code>resize2fs</code>重新设置分区大小。gparted一般会自动帮你resize2fs。</p><h3 id="上机测试"><a href="#上机测试" class="headerlink" title="上机测试"></a>上机测试</h3><p>可以从串口看到完整的启动过程：uboot、kernel、systemd，然后是login：</p><pre><code>U-Boot 2018.01 (Apr 24 2019 - 00:24:09 +0800) Xilinx Zynq ZC702Model: Zynq ZC702 Development BoardBoard: Xilinx ZynqSilicon: v3.1I2C:   readyDRAM:  ECC disabled 256 MiBNAND:  128 MiB...## Booting kernel from Legacy Image at 00008000 ...  Image Name:   Linux-4.19.0-xilinx  Image Type:   ARM Linux Kernel Image (uncompressed)  Data Size:    4322424 Bytes = 4.1 MiB  Load Address: 00008000  Entry Point:  00008000  Verifying Checksum ... OK## Flattened Device Tree blob at 00000000  Booting using the fdt blob at 0x000000  Loading Kernel Image ... OK  Loading Device Tree to 0eafd000, end 0eb037a6 ... OKStarting kernel ...Booting Linux on physical CPU 0x0Linux version 4.19.0-xilinx (hyq@ict) (gcc version 6.2.1 20161114 (Linaro GCC Snapshot 6.2-2016.11))#19 SMP PREEMPT Wed Apr 24 21:55:25 CST 2019CPU: ARMv7 Processor [413fc090] revision 0 (ARMv7), cr=18c5387dCPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cacheOF: fdt: Machine model: Xilinx ZC702 board...VFS: Mounted root (ext4 filesystem) on device 179:2.devtmpfs: mountedFreeing unused kernel memory: 1024KRun /sbin/init as init processrandom: fast init donesystemd[1]: System time before build time, advancing clock.systemd[1]: Failed to insert module &#39;autofs4&#39;: No such file or directorysystemd[1]: systemd 237 running in system mode. (+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT+UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD -IDN2 +IDN -PCRE2default-hierarchy=hybrid)systemd[1]: Detected architecture arm.Welcome to Ubuntu 18.04 LTS!systemd[1]: Set hostname to &lt;armhf&gt;.systemd[1]: File /lib/systemd/system/systemd-journald.service:36 configures an IP firewall (IPAddressDeny=any), but the local system does not support BPF/cgroup based firewalling.systemd[1]: Proceeding WITHOUT firewalling in effect! (This warning is only shown for the first loaded unit using IP firewalling.)random: systemd: uninitialized urandom read (16 bytes read)systemd[1]: Reached target Swap.[  OK  ] Reached target Swap....[  OK  ] Started resolvconf-pull-resolved.service.Ubuntu 18.04 LTS armhf ttyPS0armhf login: ubuntuPassword:Last login: Fri Apr 26 17:35:14 UTC 2019 on ttyPS0Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.19.0-xilinx armv7l)* Documentation:  https://help.ubuntu.com* Management:     https://landscape.canonical.com* Support:        https://ubuntu.com/advantageubuntu@armhf:~$ </code></pre><p>跑个screenfetch来看看：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq3/screenfetch.jpeg" alt="sf" title="">                </div>                <div class="image-caption">sf</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq3/screenfetch2.jpeg" alt="gcc" title="">                </div>                <div class="image-caption">gcc</div>            </figure><p>gcc真的能用。。但是真是慢。。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.orangepi.org/Docs/Makingabootable.html" target="_blank" rel="noopener">http://www.orangepi.org/Docs/Makingabootable.html</a></li><li><a href="https://a-delacruz.github.io/debian/debian-arm64.html" target="_blank" rel="noopener">https://a-delacruz.github.io/debian/debian-arm64.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu、Debian之类的不同的发行版，其实就是不同的&lt;code&gt;rootfs&lt;/code&gt;。Debian系的发行版有个工具叫&lt;code&gt;debootstrap&lt;/code&gt;，可以从&lt;code&gt;源&lt;/code&gt;那里下载最小的根文件系统。Arch相应的工具则是&lt;code&gt;packstrap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下完根文件系统之后&lt;code&gt;chroot&lt;/code&gt;进去进行相应的配置，为了chroot到一个ARM的rootfs，我们需要用&lt;code&gt;qemu-arm-static&lt;/code&gt;。进去之后&lt;code&gt;apt-get&lt;/code&gt;你想要安装的东西。配完了之后烧进sd卡，通过内核参数&lt;code&gt;root=xxxx&lt;/code&gt;告诉内核要挂载哪个rootfs，即可启动了。&lt;/p&gt;
&lt;p&gt;要制作一个叉叉派的镜像都是这样的套路：bootstrap一个最小系统，安装内核模块，安装必要的应用程序，然后安装不同的桌面环境，最后打包。于是就制作出各种水果派的n多镜像，像Ubuntu core、Ubuntu mate、xubuntu、lubuntu、Debian，Arch等等，应有尽有。。&lt;/p&gt;
&lt;p&gt;然而这些大型发行版的“最小系统”都相当的大，几百兆的样子，而我们的EBAZ4205只有128M的nand flash，所以只好从sd卡启动才能维持得了生活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zynq" scheme="http://yoursite.com/tags/zynq/"/>
    
  </entry>
  
  <entry>
    <title>zynq[2] Linux from scratch</title>
    <link href="http://yoursite.com/zynq2/"/>
    <id>http://yoursite.com/zynq2/</id>
    <published>2019-04-27T04:35:38.000Z</published>
    <updated>2019-04-27T15:15:27.421Z</updated>
    
    <content type="html"><![CDATA[<p>Xilinx有个工具叫<code>PetaLinux</code>，它可以一键生成uboot、Linux、根文件系统。但是按照惯例我们还是自己敲命令一个个来吧。</p><p>Xilinx有个<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841738/Getting+Started" target="_blank" rel="noopener">wiki</a>讲述如何一步步做<code>Linux from scratch</code>。有些步骤是多余的，比如编译设备树的工具链。鉴于我们的EBAZ4205是块野生的板子，需要稍微做一些配置。</p><p>安装vivado、SDK时候顺便安装了<code>arm-linux-gnueabihf-</code>以及其他Xilinx自家的工具链，不妨将其export到PATH：</p><pre><code class="bash"># gccexport PATH=/某某某/SDK/2017.4/gnu/aarch32/lin/gcc-arm-linux-gnueabi/bin/:$PATH# bootgen etc.export PATH=/某某某/SDK/2017.4/bin:$PATH</code></pre><p>所有工作开始之前，还要export <code>ARCH</code>和<code>CROSS_COMPILE</code>两个环境变量：</p><pre><code class="bash">export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><a id="more"></a><h3 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h3><p>uboot只需要极少量的配置，就基本上works out of the box了。现在我们先用<code>tftp</code>来启动内核。各部分的地址如下：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">文件名</th><th style="text-align:left">启动地址</th></tr></thead><tbody><tr><td style="text-align:left">设备树</td><td style="text-align:left">zynq-zc702.dtb</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">内核</td><td style="text-align:left">uImage</td><td style="text-align:left">0x8000</td></tr><tr><td style="text-align:left">文件系统</td><td style="text-align:left">uramdisk.image.gz</td><td style="text-align:left">0x01000000</td></tr></tbody></table><p>从<a href="https://github.com/Xilinx/u-boot-xlnx" target="_blank" rel="noopener">https://github.com/Xilinx/u-boot-xlnx</a>上下载Xilinx家的uboot，当然也可以选择去下载<a href="https://github.com/Xilinx/u-boot-xlnx/releases" target="_blank" rel="noopener">release</a>版本的。</p><h4 id="改改配置"><a href="#改改配置" class="headerlink" title="改改配置"></a>改改配置</h4><p><a href="https://github.com/Xilinx/u-boot-xlnx/blob/master/arch/arm/dts/zynq-zc702.dts#L22" target="_blank" rel="noopener">arch/arm/dts/zynq-zc702.dts</a>的<code>memory</code>节点，内存大小改为256MB</p><pre><code class="diff">@@ -21,7 +21,7 @@     memory@0 {         device_type = &quot;memory&quot;;-        reg = &lt;0x0 0x40000000&gt;;+        reg = &lt;0x0 0x10000000&gt;;     };     chosen {</code></pre><p>直接用<code>zynq_zc702_defconfig</code>：</p><pre><code>make zynq_zc702_defconfig</code></pre><ul><li>关闭<code>CONFIG_ENV_IS_IN_SPI_FLASH</code>，不然启动时候会卡死在SPI flash初始化部分。这时候就用默认的环境变量。</li><li>开启<code>CONFIG_NAND</code>、<code>CONFIG_NAND_ZYNQ</code>，以开启nand命令。</li></ul><p>定制环境变量，改<code>include/configs/zynq-common.h</code>，主要是来配置启动参数。</p><ul><li>tftp之前得显式地设置<code>serverip</code></li><li>要tftp内核、设备树、根文件系统</li></ul><pre><code>set serverip xxx.xxx.xxx.xxxdhcptftpboot 0 zynq-zc702.dtbtftpboot 8000 uImagetftpboot 1000000 uramdisk.image.gzbootm 8000 1000000 0</code></pre><p>然后make，生成了<code>u-boot</code>可执行文件。</p><h4 id="生成BOOT-bin"><a href="#生成BOOT-bin" class="headerlink" title="生成BOOT.bin"></a>生成BOOT.bin</h4><p>我们写一个<code>boot.bif</code>，引用之前建的helloworld工程中的<code>FSBL</code>和<code>bitstream</code>：</p><pre><code>the_ROM_image:{    [bootloader]/某某某/fsbl.elf    /某某某/ebaz4205_wrapper.bit    /某某某/u-boot.elf}</code></pre><p>利用vivado安装的工具<code>bootgen</code>，通过上述配置文件来生成<code>BOOT.bin</code>。<strong><code>u-boot</code>需要重命名为<code>u-boot.elf</code>，不然bootgen不认为它是ELF文件，就当它是bin文件来处理了。。。</strong></p><pre><code>mv u-boot u-boot.elfbootgen -image boot.bif -o i BOOT.bin -w</code></pre><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><p>内核很大程度上也是work out of the box了，改改设备树就好。</p><p>从<a href="https://github.com/Xilinx/linux-xlnx" target="_blank" rel="noopener">https://github.com/Xilinx/linux-xlnx</a>上下载Xilinx家的内核。目前版本是4.19.0，还是挺新的。</p><h4 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h4><p>首先还是得将内存大小改对：</p><pre><code class="diff">        memory@0 {                device_type = &quot;memory&quot;;-               reg = &lt;0x0 0x40000000&gt;;+               reg = &lt;0x0 0x10000000&gt;;        };</code></pre><p>因为我们的野生板子外设很少，必须将不用的外设<code>disabled</code>掉，不然引脚配置会打架。</p><pre><code class="diff"> &amp;can0 {-       status = &quot;okay&quot;;+       status = &quot;disabled&quot;;... &amp;i2c0 {-       status = &quot;okay&quot;;+       status = &quot;disabled&quot;; &amp;qspi {        u-boot,dm-pre-reloc;-       status = &quot;okay&quot;;+       status = &quot;disabled&quot;; &amp;usb0 {-       status = &quot;okay&quot;;+       status = &quot;disabled&quot;;</code></pre><p>串口的引脚要改对：</p><pre><code class="diff">@@ -368,12 +382,12 @@         };         conf-rx {-            pins = &quot;MIO49&quot;;+            pins = &quot;MIO25&quot;;             bias-high-impedance;         };         conf-tx {-            pins = &quot;MIO48&quot;;+            pins = &quot;MIO24&quot;;             bias-disable;         };     };</code></pre><p>网口通过<code>EMIO</code>引出，因此<code>gem0</code>的引脚声明应该删掉，否则会跟串口引脚打架，导致启动到一半串口没输出了。。并且<code>ethernet_phy</code>节点的<code>reg</code>参数应改为0，不然会枚举不到那个网卡：</p><pre><code class="diff">&amp;gem0 {    status = &quot;okay&quot;;    phy-mode = &quot;rgmii-id&quot;;    phy-handle = &lt;&amp;ethernet_phy&gt;;-    pinctrl-names = &quot;default&quot;;-    pinctrl-0 = &lt;&amp;pinctrl_gem0_default&gt;;-    phy-reset-gpio = &lt;&amp;gpio0 11 0&gt;;-    phy-reset-active-low;-    ethernet_phy: ethernet-phy@7 {-        reg = &lt;7&gt;;+    ethernet_phy: ethernet-phy@0 {+        reg = &lt;0&gt;;         device_type = &quot;ethernet-phy&quot;;     };};</code></pre><p>SDIO接口也在fsbl初始化完成了，所以它的引脚声明也要删掉：</p><pre><code class="diff"> &amp;sdhci0 {     u-boot,dm-pre-reloc;     status = &quot;okay&quot;;-    pinctrl-names = &quot;default&quot;;-    pinctrl-0 = &lt;&amp;pinctrl_sdhci0_default&gt;; };</code></pre><p>为了用nand flash，需要添加<code>nand</code>节点。在阿莫论坛<a href="https://www.amobbs.com/thread-5705018-1-1.html" target="_blank" rel="noopener">有个帖子</a>，62楼列举了原板子启动的log，可以看到它有9个分区：</p><pre><code>Creating 9 MTD partitions on &quot;pl35x-nand&quot;:0x000000000000-0x000000300000 : &quot;nand-fsbl-uboot&quot;0x000000300000-0x000000800000 : &quot;nand-linux&quot;0x000000800000-0x000000820000 : &quot;nand-device-tree&quot;0x000000820000-0x000001220000 : &quot;nand-rootfs&quot;0x000001220000-0x000002220000 : &quot;nand-jffs2&quot;0x000002220000-0x000002a20000 : &quot;nand-bitstream&quot;0x000002a20000-0x000006a20000 : &quot;nand-allrootfs&quot;0x000006a20000-0x000007e00000 : &quot;nand-release&quot;0x000007e00000-0x000008000000 : &quot;nand-reserve&quot;</code></pre><p>所以我们这样设置<code>nand0</code>节点：</p><pre><code class="dts">&amp;nand0 {    status = &quot;okay&quot;;    pinctrl-names = &quot;default&quot;;    pinctrl-0 = &lt;&amp;pinctrl_nand0_default&gt;;    partition@0 {        label = &quot;nand-fsbl-uboot&quot;;        reg = &lt;0x0 0x300000&gt;;    };    partition@1 {        label = &quot;nand-linux&quot;;        reg = &lt;0x300000 0x500000&gt;;    };    partition@2 {        label = &quot;nand-device-tree&quot;;        reg = &lt;0x800000 0x20000&gt;;    };    partition@3 {        label = &quot;nand-rootfs&quot;;        reg = &lt;0x820000 0xa00000&gt;;    };    partition@4 {        label = &quot;nand-jffs2&quot;;        reg = &lt;0x1220000 0x1000000&gt;;    };    partition@5 {        label = &quot;nand-bitstream&quot;;        reg = &lt;0x2220000 0x800000&gt;;    };    partition@6 {        label = &quot;nand-allrootfs&quot;;        reg = &lt;0x2a20000 0x4000000&gt;;    };    partition@7 {        label = &quot;nand-release&quot;;        reg = &lt;0x6a20000 0x13e0000&gt;;    };    partition@8 {        label = &quot;nand-reserve&quot;;        reg = &lt;0x7e00000 0x200000&gt;;    };};</code></pre><p>它的引脚配置<code>pinctrl_nand0_default</code>如下：</p><pre><code class="dts">    pinctrl_nand0_default: nand0-default {        mux {            groups = &quot;smc0_nand8_grp&quot;;            function = &quot;smc0_nand&quot;;        };        conf {            groups = &quot;smc0_nand8_grp&quot;;            bias-pull-up;        };    };</code></pre><p>groups的名字是在<a href="https://github.com/Xilinx/linux-xlnx/blob/master/drivers/pinctrl/pinctrl-zynq.c#L715" target="_blank" rel="noopener">pinctrl-zynq.c第715行</a>找到的。</p><p>由于在<a href="https://github.com/Xilinx/linux-xlnx/blob/master/arch/arm/boot/dts/zynq-7000.dtsi#L220" target="_blank" rel="noopener">zynq-7000.dtsi</a>里，<code>nand0</code>是<code>smcc</code>的子节点，所以还要使能<code>smcc</code>节点：</p><pre><code class="dts">&amp;smcc {    status = &quot;okay&quot;;};</code></pre><p>为了避免<code>pinctrl_gpio0_default</code>跟<code>pinctrl_nand0_default</code>引脚打架，前者的引脚都应该删掉：</p><pre><code class="diff">     pinctrl_gpio0_default: gpio0-default {         mux {             function = &quot;gpio0&quot;;-            groups = &quot;gpio0_7_grp&quot;, &quot;gpio0_8_grp&quot;, &quot;gpio0_9_grp&quot;,-                 &quot;gpio0_10_grp&quot;, &quot;gpio0_11_grp&quot;, &quot;gpio0_12_grp&quot;,-                 &quot;gpio0_13_grp&quot;, &quot;gpio0_14_grp&quot;;+            groups = &quot;&quot;;         };         conf {-            groups = &quot;gpio0_7_grp&quot;, &quot;gpio0_8_grp&quot;, &quot;gpio0_9_grp&quot;,-                 &quot;gpio0_10_grp&quot;, &quot;gpio0_11_grp&quot;, &quot;gpio0_12_grp&quot;,-                 &quot;gpio0_13_grp&quot;, &quot;gpio0_14_grp&quot;;+            groups = &quot;&quot;;             slew-rate = &lt;0&gt;;             io-standard = &lt;1&gt;;         };         conf-pull-up {-            pins = &quot;MIO9&quot;, &quot;MIO10&quot;, &quot;MIO11&quot;, &quot;MIO12&quot;, &quot;MIO13&quot;, &quot;MIO14&quot;;+            pins = &quot;&quot;;             bias-pull-up;         };         conf-pull-none {-            pins = &quot;MIO7&quot;, &quot;MIO8&quot;;+            pins = &quot;&quot;;             bias-disable;         };     };</code></pre><p>其他节点该删的都要删掉，比如<code>gpio-keys</code>、<code>leds</code>、<code>usb_phy0</code>等。还有一些pinctrl的节点，看着碍事也不妨删掉，比如<code>pinctrl_gem0_default</code>等。。</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>其实用<code>xilinx_zynq_defconfig</code>已经足够，不过如果想要更多的功能，比如<code>ZRAM</code>压缩内存之类的比较骚的设施，也可以稍微配置一下。。</p><p>记得我们uboot会将内核放在32K开始的内存地址处。然后编译设备树。</p><pre><code>make xilinx_zynq_defconfigmake uImage UIMAGE_LOADADDR=0x8000make dtbs</code></pre><h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>从<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842473/Build+and+Modify+a+Rootfs" target="_blank" rel="noopener">Build and Modify a Rootfs</a>上下载人家编译好的<code>busybox</code>做的文件系统<code>arm_ramdisk.image.gz</code>，然后将它打包为uboot能识别的格式：</p><pre><code>mkimage -A arm -T ramdisk -C gzip -d arm_ramdisk.image.gz uramdisk.image.gz</code></pre><h3 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h3><p>装好tftp server，将<code>uImage</code>、<code>zynq-zc702.dtb</code>、<code>uramdisk.image.gz</code>放进去。将<code>BOOT.bin</code>丢进格式化为fatfs的SD卡的根目录里面，然后就可以等它启动了。</p><pre><code>## Booting kernel from Legacy Image at 00008000 ...  Image Name:   Linux-4.19.0-xilinx  Image Type:   ARM Linux Kernel Image (uncompressed)  Data Size:    4322424 Bytes = 4.1 MiB  Load Address: 00008000  Entry Point:  00008000  Verifying Checksum ... OK## Loading init Ramdisk from Legacy Image at 01000000 ...  Image Name:  Image Type:   ARM Linux RAMDisk Image (gzip compressed)  Data Size:    5309954 Bytes = 5.1 MiB  Load Address: 00000000  Entry Point:  00000000  Verifying Checksum ... OK## Flattened Device Tree blob at 00000000  Booting using the fdt blob at 0x000000  Loading Kernel Image ... OK  Loading Ramdisk to 0e5f3000, end 0eb03602 ... OK  Loading Device Tree to 0e5ec000, end 0e5f27a6 ... OKStarting kernel ...Booting Linux on physical CPU 0x0Linux version 4.19.0-xilinx (hyq@ict) (gcc version 6.2.1 20161114 (Linaro GCC Snapshot 6.2-2016.11))#19 SMP PREEMPT Wed Apr 24 21:55:25 CST 2019CPU: ARMv7 Processor [413fc090] revision 0 (ARMv7), cr=18c5387d....VFS: Mounted root (ext4 filesystem) on device 1:0.Starting rcS...++ Mounting filesystemmount: mounting /dev/mmcblk0p1 on /mnt failed: No such file or directorymount: mounting /dev/mmcblk0 on /mnt failed: No such file or directory++ Setting up mdev++ Starting telnet daemon++ Starting http daemon++ Starting ftp daemon++ Starting ssh daemonrandom: sshd: uninitialized urandom read (32 bytes read)rcS Completezynq&gt;zynq&gt; zynq&gt; zynq&gt; uname -aLinux (none) 4.19.0-xilinx #19 SMP PREEMPT Wed Apr 24 21:55:25 CST 2019 armv7l GNU/Linuxzynq&gt; </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xilinx有个工具叫&lt;code&gt;PetaLinux&lt;/code&gt;，它可以一键生成uboot、Linux、根文件系统。但是按照惯例我们还是自己敲命令一个个来吧。&lt;/p&gt;
&lt;p&gt;Xilinx有个&lt;a href=&quot;https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841738/Getting+Started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wiki&lt;/a&gt;讲述如何一步步做&lt;code&gt;Linux from scratch&lt;/code&gt;。有些步骤是多余的，比如编译设备树的工具链。鉴于我们的EBAZ4205是块野生的板子，需要稍微做一些配置。&lt;/p&gt;
&lt;p&gt;安装vivado、SDK时候顺便安装了&lt;code&gt;arm-linux-gnueabihf-&lt;/code&gt;以及其他Xilinx自家的工具链，不妨将其export到PATH：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# gcc
export PATH=/某某某/SDK/2017.4/gnu/aarch32/lin/gcc-arm-linux-gnueabi/bin/:$PATH
# bootgen etc.
export PATH=/某某某/SDK/2017.4/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有工作开始之前，还要export &lt;code&gt;ARCH&lt;/code&gt;和&lt;code&gt;CROSS_COMPILE&lt;/code&gt;两个环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabihf-
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="zynq" scheme="http://yoursite.com/tags/zynq/"/>
    
  </entry>
  
  <entry>
    <title>zynq[1] 矿板helloworld</title>
    <link href="http://yoursite.com/zynq1/"/>
    <id>http://yoursite.com/zynq1/</id>
    <published>2019-04-26T11:56:38.000Z</published>
    <updated>2019-04-27T15:17:24.544Z</updated>
    
    <content type="html"><![CDATA[<p>最近矿难，某宝某鱼上都出现了大量矿机控制板。。。ASIC负责挖矿，控制板负责联网、监视、控制之类。控制板不乏有各种水果派，像香橙派、树莓派、狗骨头之类的所谓“极客玩具”在其之列，想必国内水果派厂家活的是相当滋润。。。光靠极客教育哪有什么赚头，极客大都很穷的，像我这样看到几十块钱的“zynq开发板”，便忍不住要跟风收一波垃圾了。正常zynq板子都得500往上走的。。。</p><p>某鱼上<code>EBAZ4205</code>控制板泛滥，它出自<code>翼比特E9+</code>矿机。它的老版控制卡<code>EBAZ4203</code>配置与其基本一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/ebazE9p.jpg" alt="ebaz4205" title="">                </div>                <div class="image-caption">ebaz4205</div>            </figure><p><strong>下面一大坨都是计算卡，上面一小块才是控制板</strong></p><a id="more"></a><h3 id="板子概况"><a href="#板子概况" class="headerlink" title="板子概况"></a>板子概况</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/ebaz4205-3.jpg" alt="ebaz4205" title="">                </div>                <div class="image-caption">ebaz4205</div>            </figure><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">主控</td><td style="text-align:left">XC7Z010CLG400-1</td></tr><tr><td style="text-align:left">内存</td><td style="text-align:left">256MB DDR3，EM6GD16EWKG或者MT41K128M16</td></tr><tr><td style="text-align:left">nand</td><td style="text-align:left">128MB SLC</td></tr><tr><td style="text-align:left">以太网</td><td style="text-align:left">百兆网卡，IP101GA</td></tr><tr><td style="text-align:left">供电</td><td style="text-align:left">5V也行</td></tr><tr><td style="text-align:left">其他</td><td style="text-align:left">TF卡，UART1，2个风扇口，14针jtag，3个20pin IO口</td></tr></tbody></table><h3 id="开发工程"><a href="#开发工程" class="headerlink" title="开发工程"></a>开发工程</h3><h4 id="SOC启动配置"><a href="#SOC启动配置" class="headerlink" title="SOC启动配置"></a>SOC启动配置</h4><p>ZYNQ系列的SOC集成了双核ARM Cortex-A9和FPGA。整个SOC分为<code>PS</code>（processing system）和<code>PL</code>（programmable logic）两部分。PS包括处理器、片上AMBA总线、存储控制器、部分外设以及固定的IO口；PL就是FPGA。ZYNQ 7010处理器主频可以到约600MHz，FPGA有约28K个LE。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/zynqbd.jpeg" alt="zynq" title="">                </div>                <div class="image-caption">zynq</div>            </figure></p><p>ZYNQ的PS部分可以抛开PL部分而独立运行，因为PS的外设都默认绑定了一些IO口（<code>MIO</code>），内存控制器之类的IO口还是不可更改的，这时候就可以像开发其他ARM SOC那样去玩ZYNQ。MIO是有限的，一些外设端口冲突的话可以通过<code>EMIO</code>绕道PL将其引出，这时候就需要管PL部分了。</p><p>ZYNQ的启动分为三步：</p><ul><li><code>BOOT ROM</code>，根据引脚配置选择从哪里启动，如QSPI、nand/nor flash、SD卡等。将<code>FSBL</code>（first stage bootloader）加载到片上内存里。7010的片上内存有256k。</li><li><code>FSBL</code>，初始化更多的MIO口，初始化DDR，还可以初始化PL部分，然后将应用程序搬到DDR中。初始化部分由vivado直接生成，即那个上万行的<code>ps7_init.c</code>。FSBL可以直接用Xilinx SDK的例子工程，相当于这些工作都可以点点鼠标就完成了。</li><li><code>应用程序</code>。可以直接是用户的应用程序，也可以是又一个loader，比如uboot之类的，剩下的事情就由程序员自己做决定了。</li></ul><p>应当指出，FSBL相当于是uboot SPL的地位。在Xilinx uboot工程中，那个上万行的初始化c程序就编译进SPL中去了，所以如果用SDK的FSBL就不需要uboot的SPL了。</p><p>这块板子的<code>R2577</code>和<code>R2584</code>电阻用于配置启动设备。把<code>R2584</code>焊到<code>R2577</code>上，将原来nand启动改为SD卡启动。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/ebaz4205-2.jpg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><h4 id="Vivado操作流程"><a href="#Vivado操作流程" class="headerlink" title="Vivado操作流程"></a>Vivado操作流程</h4><p>利用Xilinx那套笨重的开发环境，helloworld工程完全可以用鼠标操作出来，一行代码都不用写。。</p><h5 id="首先新建个工程"><a href="#首先新建个工程" class="headerlink" title="首先新建个工程"></a>首先新建个工程</h5><p>一直next到选择芯片。选<code>xc7z010clg400-1</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado1.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><p>接下来就顺着左边栏<code>Flow Navigator</code>进行操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado2.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><h5 id="Create-Board-Design"><a href="#Create-Board-Design" class="headerlink" title="Create Board Design"></a>Create Board Design</h5><p>点加号添加<code>ZYNQ7 Processing System</code>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado3.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><p>双击出来的zynq7 processing system蓝框框，配置PS系统：</p><ul><li><p>添加nand控制器，默认就行了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado4.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure></li><li><p>添加MIO设置。勾上ENET0、SD0、UART1。注意引脚配置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado5.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure></li><li><p>设置外设时钟。把网口改成百兆的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado7.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure></li><li><p>设置DDR。幸好我们的<code>MT41K128M16</code>有默认参数配置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado6.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure></li></ul><p>因为板子的网口通过EMIO引出，所以我们需要一个个手动分配引脚。但是这个IP是GMII千兆网口，TX RX有8位，而百兆网卡用的MII接口TX RX只有4位，<strong>必须显式地加两个concat模块来将8位转为4位</strong>，否则多余的引脚引出了但是不分配IO口，最后生成bitstream时候会报错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado8.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><p>将GMII的TX、RX引到各自的concat模块处，将GMII其他引脚以及MDIO引出：右键点击<code>Make External</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado10.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><p>将<code>FCLK_CLK0</code>跟<code>M_AXI_GP0_ACLK</code>连起来，最后点击上方栏的<code>Run Block Automation</code>完成剩下的工作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado9.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><p>完成后的效果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado11.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><h5 id="左边栏Generate-Block-Design"><a href="#左边栏Generate-Block-Design" class="headerlink" title="左边栏Generate Block Design"></a>左边栏Generate Block Design</h5><p>先<code>Generate Block Design</code>，然后右键<code>Source</code>框下面的bd文件，<code>Create HDL Wrapper</code>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado12.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><h5 id="左边栏Run-Synthesis"><a href="#左边栏Run-Synthesis" class="headerlink" title="左边栏Run Synthesis"></a>左边栏Run Synthesis</h5><p>先综合一次，然后打开<code>Open Synthesized Design</code>-&gt;<code>Constraint Wizard</code>，分配引脚。这时需要新建一个constraint文件。</p><p>将网口的引脚都设置为<code>LVCMOS33</code>电平，然后逐个分配引脚。。。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/vivado13.jpeg" alt="vivado" title="">                </div>                <div class="image-caption">vivado</div>            </figure><p>设置完成后<code>Ctrl-S</code>保存，约束文件生成如下：</p><pre><code>set_property IOSTANDARD LVCMOS33 [get_ports ENET0_GMII_RX_CLK_0]...set_property PACKAGE_PIN U14 [get_ports ENET0_GMII_RX_CLK_0]set_property PACKAGE_PIN U15 [get_ports ENET0_GMII_TX_CLK_0]set_property PACKAGE_PIN W19 [get_ports {ENET0_GMII_TX_EN_0[0]}]set_property PACKAGE_PIN W18 [get_ports {enet0_gmii_txd[0]}]set_property PACKAGE_PIN Y18 [get_ports {enet0_gmii_txd[1]}]set_property PACKAGE_PIN V18 [get_ports {enet0_gmii_txd[2]}]set_property PACKAGE_PIN Y19 [get_ports {enet0_gmii_txd[3]}]set_property PACKAGE_PIN W16 [get_ports ENET0_GMII_RX_DV_0]set_property PACKAGE_PIN W15 [get_ports MDIO_ETHERNET_0_0_mdc]set_property PACKAGE_PIN Y14 [get_ports MDIO_ETHERNET_0_0_mdio_io]set_property PACKAGE_PIN Y16 [get_ports {enet0_gmii_rxd[0]}]set_property PACKAGE_PIN V16 [get_ports {enet0_gmii_rxd[1]}]set_property PACKAGE_PIN V17 [get_ports {enet0_gmii_rxd[2]}]set_property PACKAGE_PIN Y17 [get_ports {enet0_gmii_rxd[3]}]</code></pre><p><strong>然后再综合一次。。。</strong></p><h5 id="左边栏Run-Implementation-和-Generate-Bitstream"><a href="#左边栏Run-Implementation-和-Generate-Bitstream" class="headerlink" title="左边栏Run Implementation 和 Generate Bitstream"></a>左边栏Run Implementation 和 Generate Bitstream</h5><p>要跑一段时间。。。</p><h5 id="输出设计"><a href="#输出设计" class="headerlink" title="输出设计"></a>输出设计</h5><p><code>File</code>-&gt;<code>Export</code>-&gt;<code>Export Hardware</code></p><p>记得勾上<code>Include Bitstream</code>。</p><h5 id="进入SDK"><a href="#进入SDK" class="headerlink" title="进入SDK"></a>进入SDK</h5><p><code>File</code>-&gt;<code>Launch SDK</code></p><h4 id="SDK操作流程"><a href="#SDK操作流程" class="headerlink" title="SDK操作流程"></a>SDK操作流程</h4><h5 id="首先需要新建FSBL。"><a href="#首先需要新建FSBL。" class="headerlink" title="首先需要新建FSBL。"></a>首先需要新建FSBL。</h5><p><code>File</code>-&gt;<code>New</code>-&gt;<code>Application Project</code>，Next到<code>Templates</code>，选<code>Zynq FSBL</code>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/sdk1.jpeg" alt="sdk" title="">                </div>                <div class="image-caption">sdk</div>            </figure><p>然后它会自动开始编译。。。</p><h5 id="然后才新建helloworld。。"><a href="#然后才新建helloworld。。" class="headerlink" title="然后才新建helloworld。。"></a>然后才新建helloworld。。</h5><p><code>File</code>-&gt;<code>New</code>-&gt;<code>Application Project</code>，Next到<code>Templates</code>，选<code>Hello World</code>。它也会自动开始编译，不出意外的话就完事了。</p><h5 id="最后生成启动文件BOOT-bin"><a href="#最后生成启动文件BOOT-bin" class="headerlink" title="最后生成启动文件BOOT.bin"></a>最后生成启动文件BOOT.bin</h5><p>左边栏右键helloworld工程，<code>Create Boot Image</code>。可以看到这个启动文件包括了三部分：</p><ul><li>fsbl</li><li>bitstream</li><li>应用程序</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/sdk2.jpeg" alt="sdk" title="">                </div>                <div class="image-caption">sdk</div>            </figure><h5 id="点亮板子"><a href="#点亮板子" class="headerlink" title="点亮板子"></a>点亮板子</h5><p>将一张SD卡格式化为fat文件系统，将<code>bootimage/BOOT.bin</code>丢进去，插上电就能启动了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/sdk3.jpeg" alt="sdk" title="">                </div>                <div class="image-caption">sdk</div>            </figure><h5 id="测试网口"><a href="#测试网口" class="headerlink" title="测试网口"></a>测试网口</h5><p>SDK里面新建<code>lwIP Echo Server</code>工程，等它编译完，生成BOOT.bin，拷到SD卡里。插好网线，在终端中<code>telnet</code>它的7号端口，输入一行，回车，然后它就将你输入的东西返回来了。。。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/telnet.jpeg" alt="sdk" title="">                </div>                <div class="image-caption">sdk</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/ebaz4205-1.jpg" alt="debugging" title="">                </div>                <div class="image-caption">debugging</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/zynq1/bqb.jpg" alt="debugging" title="">                </div>                <div class="image-caption">debugging</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近矿难，某宝某鱼上都出现了大量矿机控制板。。。ASIC负责挖矿，控制板负责联网、监视、控制之类。控制板不乏有各种水果派，像香橙派、树莓派、狗骨头之类的所谓“极客玩具”在其之列，想必国内水果派厂家活的是相当滋润。。。光靠极客教育哪有什么赚头，极客大都很穷的，像我这样看到几十块钱的“zynq开发板”，便忍不住要跟风收一波垃圾了。正常zynq板子都得500往上走的。。。&lt;/p&gt;
&lt;p&gt;某鱼上&lt;code&gt;EBAZ4205&lt;/code&gt;控制板泛滥，它出自&lt;code&gt;翼比特E9+&lt;/code&gt;矿机。它的老版控制卡&lt;code&gt;EBAZ4203&lt;/code&gt;配置与其基本一样。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/zynq1/ebazE9p.jpg&quot; alt=&quot;ebaz4205&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;ebaz4205&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;下面一大坨都是计算卡，上面一小块才是控制板&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="zynq" scheme="http://yoursite.com/tags/zynq/"/>
    
  </entry>
  
  <entry>
    <title>pulpino[2] nuttx ELF</title>
    <link href="http://yoursite.com/pulpino2/"/>
    <id>http://yoursite.com/pulpino2/</id>
    <published>2018-07-29T07:48:33.000Z</published>
    <updated>2019-04-27T15:27:14.224Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序需要内核提供各种服务才能运行，服务通过库以及相应的ABI（Application Binary Interface，应用程序二进制接口）来提供，比方说C库等。nuttx的应用程序可以内置在内核中（built-in），也可以与内核分开（separate），即运行外部可执行文件。目前它支持两种可执行文件：</p><ul><li><code>ELF</code>，就是Linux下标准的ELF可执行文件；</li><li><code>NXFLAT</code>，它是简化版的<code>XFLAT</code>；XFLAT原为UCLinux开发，特点在于体积小、可以就地运行（XIP）；简化在于，NXFLAT不支持动态链接，不能导出符号表。</li></ul><p>本文讨论如何为nuttx添加riscv的ELF支持，以及如何制作nuttx ELF应用程序。以下叙述适用于<code>nuttx-7.25</code>，nuttx还很年轻，即使是小版本之间的代码变动也可能会比较大。。</p><a id="more"></a><h3 id="ELF简述"><a href="#ELF简述" class="headerlink" title="ELF简述"></a>ELF简述</h3><p>ELF的基本结构可参考<a href="http://www.sco.com/developers/gabi/1998-04-29/contents.html" target="_blank" rel="noopener">SystemV ABI</a>文档。简单说，从上到下依次是<code>ELF头</code>、<code>程序头</code>、<code>段</code>、<code>段表</code>。</p><ul><li><code>ELF头</code>记录基本信息，如该ELF的目标机器、ABI类型、入口地址、段表程序头等的偏移地址。ELF标准中里面的字段以<code>e_</code>作为前缀。</li><li><code>程序头</code>记录需要加载的内容，供ELF加载器操作：该加载的加载，该动态链接的动态链接等。Linux中可执行的文件都必须有程序头，可重定位的ELF则没有程序头。其字段以<code>p_</code>作为前缀。</li><li><code>段</code>里堆放着该文件的具体内容，需要结合最后面的<code>段表</code>才能分段解读。虽然大家都会很粗线条地将一个程序分为<code>text段</code>、<code>data段</code>等段，但是实际上段可以很随心所欲地设置，比方说<ul><li>在链接脚本里安排一个段，管它叫什么名字，然后在代码里面<code>__attribute__((section(&quot;xxx&quot;)))</code>；</li><li>gcc的<code>-ffunction-sections</code>和<code>-fdata-sections</code>，可以为每一个函数或者变量安排一个段；</li><li>objcopy的<code>--add-section</code>可以手动添加一个段；</li><li>有些病毒通过在ELF中注入自己的段来感染宿主</li></ul></li><li><code>段表</code>记录这些段的诸如起始地址、长度等信息。可重定位的ELF必须有段表，而可执行的ELF则不必有段表，虽然一般都会保留。其字段以<code>sh_</code>为前缀。每个段都有不同的功能，比方说text段就是机器码，data段是数据区，rela段指示重定位信息，symtab段是符号表，debug段指示源代码信息等。</li></ul><h4 id="readelf常用命令"><a href="#readelf常用命令" class="headerlink" title="readelf常用命令"></a>readelf常用命令</h4><p><code>xxxxxxxx-readelf</code>是binutils的工具，用来查看ELF信息。有这些常用的命令：</p><ul><li><code>-h</code>查看ELF头</li><li><code>-l</code>查看程序头</li><li><code>-S</code>查看段表</li><li><code>-s</code>查看符号表</li><li><code>-d</code>查看动态链接的符号表</li><li><code>-r</code>查看重定位表</li><li><code>-a</code>统统看</li></ul><p>下面摘录一个ELF头：</p><pre><code>$ readelf -h /lib/x86_64-linux-gnu/ld-2.27.soELF 头：  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  类别:                              ELF64  数据:                              2 补码，小端序 (little endian)  版本:                              1 (current)  OS/ABI:                            UNIX - System V  ABI 版本:                          0  类型:                              DYN (共享目标文件)  系统架构:                          Advanced Micro Devices X86-64  版本:                              0x1  入口点地址：               0x1090  程序头起点：          64 (bytes into file)  Start of section headers:          169232 (bytes into file)  标志：             0x0  本头的大小：       64 (字节)  程序头大小：       56 (字节)  Number of program headers:         7  节头大小：         64 (字节)  节头数量：         27  字符串表索引节头： 26</code></pre><h4 id="几种EFL"><a href="#几种EFL" class="headerlink" title="几种EFL"></a>几种EFL</h4><p>由EFL头部的<code>e_type</code>字段标明。值得关注的有这三种：</p><ul><li><code>EL_REL</code>，可重定位的ELF。<code>gcc -c</code>生成的中间文件<code>.o</code>就是这种类型，没有经过<code>ld</code>最终链接，是谓“可重定位”。另外Linux内核模块<code>.ko</code>文件也是这种类型，在<code>insmod</code>或者<code>modprobe</code>时候由加载器进行最终的链接。这种ELF<strong>没有程序头，有段表</strong>。</li><li><code>EL_EXEC</code>，可执行的ELF。gcc最终调用ld生成可执行的ELF。这种ELF<strong>必须要程序头</strong>来指示加载哪些部分。值得一提的是对于嵌入式工程来说编译得到一个ELF文件是“可执行”的，因为可以利用gdb通过各种gdb server、jtag bridge之类的工具连上板子，从而<code>load</code>程序。</li><li><code>EL_DYN</code>，动态链接文件。一般指<code>gcc -shared</code>生成的<code>.so</code>文件。动态链接的关键就在于<strong>导出符号表</strong>。虽然<code>.ko</code>和<code>.so</code>都要经过连接才会被执行，但是前者由Linux内核进行连接，后者由用户空间的动态连接器（一般名叫<code>/lib/ld-linux.so</code>什么的）进行连接。</li></ul><h3 id="nuttx的binary-loader"><a href="#nuttx的binary-loader" class="headerlink" title="nuttx的binary-loader"></a>nuttx的binary-loader</h3><p>nuttx就用最直接的方式实现了外部程序的加载器，没什么花拳绣腿。</p><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ul><li>为了支持多种可执行文件类型，就做成一个链表吧。<strong>每一种binfmt类型都需要在板极appinit里面注册</strong>。加载一个文件时候就沿着链表调它回调函数，直到有一个成功运行；</li><li>应用程序直接连接到内核，直接用内核的c库，没有额外的动态链接库。只需经过最简单操作就可执行的ELF当属可重定位的ELF了，于是nuttx就这么干——它的程序相当于Linux中<code>.ko</code>文件的地位。因此nuttx就可以被称为所谓“模块化”了。</li></ul><h4 id="ELF代码跟踪"><a href="#ELF代码跟踪" class="headerlink" title="ELF代码跟踪"></a>ELF代码跟踪</h4><p>nuttx的一个基本规范是，将一个功能拆分成一个个小文件；这样既可以让代码好读也可以便于裁剪。ELF代码位于<code>binfmt/libelf</code>目录中，里面都是程序文件都只有几百行。</p><ul><li>应用程序的入口：<code>sched/task/task_execv.c:execv()</code>，随后进入<code>binfmt/binfmt_exec.c:exec()</code>；</li><li>然后在文件系统中找到该文件：调用<code>binfmt/binfmt_loadmodule.c:load_module()</code>，在该文件的<code>load_absmodule()</code>中遍历已经注册的binfmt，调用其load方法；</li><li>对于ELF，则load方法为<code>binfmt/elf.c:elf_loadbinary()</code>：<ul><li>首先将该加载的部分加载到内存里：<code>binfmt/libelf/libelf_load.c:elf_load()</code>；</li><li>然后进行重定位：<code>binfmt/libelf/libelf_bind.c:elf_bind()</code></li></ul></li><li>加载完成，就可以跳到程序入口了。</li></ul><h3 id="riscv重定位"><a href="#riscv重定位" class="headerlink" title="riscv重定位"></a>riscv重定位</h3><p>重定位部分是依赖架构的：它需要根据重定位的地址，修改对应位置的机器码从而让它可以正确运行。nuttx的重定位竟然放在<code>libc</code>中。。。具体在<code>libs/libc/machine</code>中实现。</p><h4 id="重定位符号"><a href="#重定位符号" class="headerlink" title="重定位符号"></a>重定位符号</h4><p>代码里的<code>常量</code>在编译时候就能够确定，并不需要重定位。该工程<code>内部的</code>函数变量都是可确定的，也不需要重定位。ELF里需要重定位的是外部的变量、函数，本质上说就是<code>地址</code>，要重定位的地方就是一条未填入地址的用于寻址的机器码。重定位过程就是将那条指令抠出来然后填入正确的地址。这是架构相关的部分。</p><p>重定位ELF中每一个需要被重定位的段都配有一个相应的<code>重定位段</code>，如<code>.text</code>段配<code>.rela.text</code>。重定位段中的字段以<code>r_</code>为前缀。它就是一个表，有<a href="http://www.sco.com/developers/gabi/1998-04-29/ch4.reloc.html" target="_blank" rel="noopener">两种重定位段</a>，在段表中标明：</p><ul><li><code>SHT_REL</code>，每个表项有两个字段，<code>r_offset</code>指出该指令的位置，<code>r_info</code>有一个字段是<code>符号表（.symtab）</code>的索引；</li><li><code>SHT_RELA</code>，比<code>SHT_REL</code>类型多一个所谓“加数”<code>r_addend</code>，是符号的偏置，从符号表中得到符号后需要加上它。</li></ul><p>ARM的ELF只有<code>SHT_REL</code>类型的重定位段，而riscv的ELF只有<code>SHT_RELA</code>类型的重定位段。x86就两者都有。</p><p><a href="http://www.sco.com/developers/gabi/1998-04-29/ch4.symtab.html" target="_blank" rel="noopener">符号表</a><code>.symtab</code>专门存储该ELF中的符号信息，其中关键字段有：</p><ul><li><code>st_shndx</code>，正常的话是一个正整数，是段表的索引，因为不少符号值在某一个段中，比方说代码里面的字符串常量就存在<code>.rodata</code>段里。还有一些其他取值：<ul><li><code>SHN_UNDEF</code>，定义为0，表示这个符号不在本ELF中；</li><li><code>SHN_ABS</code>，定义为<code>0xfff1</code>，表示一个绝对量（absolute value）；</li><li><code>SHN_COMMON</code>，定义为<code>0xfff2</code>，表示一个还未分配空间的块。nuttx并不支持；gcc加参数<code>-fno-common</code>就可以不生成这种符号；</li></ul></li><li><code>st_value</code>，表示该符号在st_shndx那个段的偏移量。</li><li><code>st_name</code>，该符号的名字，是<code>.strtab</code>字符串表的的索引。如果符号未定义，需要通过符号名从外部符号表里面搜索。</li></ul><p><a href="http://www.sco.com/developers/gabi/1998-04-29/ch4.strtab.html" target="_blank" rel="noopener">字符串表</a><code>.strtab</code>堆放着一批字符串，以0结尾。这些字符串并不是给程序用的，而是给装载器、调试器之类的工具用的，因此装载器并不会在内存中给它分配空间。程序用到的字符串一般存在<code>.rodata</code>段。</p><p>可以用<code>readelf -p .strtab xxxx.elf</code>来查看字符串表。</p><p>通常情况下要resolve一个在本ELF中符号：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino2/relasymbols.jpeg" alt="relocation" title="">                </div>                <div class="image-caption">relocation</div>            </figure></p><p>如果本ELF符号表中没有，那么通过<code>.symtab</code>从<code>.strtab</code>中找到符号名称，从系统的符号表中找。高效率的系统会将符号表设计为一个哈希表，静态的哈希表还可以通过gperf来生成“perfect”的哈希表，例如编译器、解释器等要通过字符串识别一个个token，而关键字都是确定的，这种情况最适合用gperf。而nuttx实现太简单了，它就是只支持静态的符号表，而且仅仅通过遍历来寻找符号。。</p><h4 id="riscv重定位类型"><a href="#riscv重定位类型" class="headerlink" title="riscv重定位类型"></a>riscv重定位类型</h4><p>根据riscv的<a href="https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#relocations" target="_blank" rel="noopener">ABI文档</a>，有那么几十种重定位类型；而<a href="https://github.com/riscv/riscv-linux/blob/406087706427cdd610ce2dc3fbffa655064944d3/arch/riscv/kernel/module.c" target="_blank" rel="noopener">riscv的Linux内核模块装载器</a>只实现了其中的少部分。因为nuttx的ELF相当于Linux内核<code>.ko</code>的地位，而且不支持动态链接，所以需要实现的就更少了；而最关键最常用的也只有寥寥几种。</p><p>rv32-I基本指令集有四种编码类型的指令：<code>R</code>、<code>I</code>、<code>S</code>、<code>U</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino2/riscv-instype.jpeg" alt="riscvins" title="">                </div>                <div class="image-caption">riscvins</div>            </figure></p><p>其中I、S、U都能编码立即数，前两者能编码12位，后者能编码20位。</p><p>rv32的基本指令集都是32位定长的。如果要加载一个32立即数，riscv不是像ARM那样弄一个“文字池（literal pool）”然后从里面load，而是直接把立即数编码在<strong>两条指令</strong>中分两次加载。这样的好处是指令都在流水线上，不需要等待访存操作。所以很多重定位类型都是成双成对的。下面分别讨论：</p><ul><li>C语言里面引用全局变量、字符串常量这种地址固定（absolute address）的变量，就是<code>R_RISCV_HI20</code>配<code>R_RISCV_LO12_I</code>或<code>R_RISCV_LO12_S</code>；</li><li>C语言里面调一个函数，函数地址是PC相关的（PC-relative call），由<code>auipc</code>和<code>jalr</code>来实现。这时auipc之后一定是jalr，这种情况就是<code>R_RISCV_CALL</code>；</li><li>循环、条件跳转等，用到<code>beq</code>、<code>bne</code>等指令，需要有一个PC相关的偏移量，就是<code>R_RISCV_BRANCH</code>；</li><li>用<strong>压缩指令集</strong>（gcc参数是<code>-mrvc</code>。pulpino就支持）时候，各种条件非条件跳转，有<code>R_RISCV_RVC_BRANCH</code>、<code>R_RISCV_RVC_JUMP</code>等；</li><li>还有一些不太常用的类型：<ul><li>汇编里引用一个相对PC指针（PC-relative reference）的值，一般是<code>la</code>伪指令展开的结果（有这样的用例：我想在某处调用一个子程序，但是子程序返回到另一个地方。那么我就<code>la</code>返回地址。。），则是<code>R_RISCV_PCREL_HI20</code>配<code>R_RISCV_PCREL_LO12_I</code>或<code>R_RISCV_PCREL_LO12_S</code>；</li><li>汇编里调用本文件的子程序，用<code>jal</code>指令调到子程序的标号那里。就是<code>R_RISCV_JAL</code>；</li><li>还有直接操作符号的，如<code>R_RISCV_RELAX</code>保持符号值不变、<code>R_RISCV_32</code>直接改32位数、<code>R_RISCV_ADD32</code>/<code>R_RISCV_SUB32</code>对那个32位数作加减。这些一般用于对debug段的重定位。</li></ul></li></ul><h4 id="需要添加的代码"><a href="#需要添加的代码" class="headerlink" title="需要添加的代码"></a>需要添加的代码</h4><ul><li>nuttx里的ELF加载器基本上是给ARM做的，而ARM只有<code>SHT_REL</code>类型的重定位，于是<code>SHT_RELA</code>类型的重定位就根本没有实现。。所以首先要依葫芦画瓢实现RELA的函数；</li><li>添加<code>libs/libc/machine/riscv</code>目录：<ul><li>根据上文<a href="#3-2、riscv重定位类型">3-2</a>实现<code>arhc_elf.c</code>；</li><li>添加Makefile和Kconfig；</li></ul></li></ul><h3 id="制作nuttx可运行的ELF"><a href="#制作nuttx可运行的ELF" class="headerlink" title="制作nuttx可运行的ELF"></a>制作nuttx可运行的ELF</h3><p>参考资料：<a href="http://www.nuttx.org/doku.php?id=wiki:nshhowtos:elf-addon" target="_blank" rel="noopener">elf-addon</a></p><p>Linux的<code>xxx-linux-gcc</code>工具链可以直接生成对应平台下的ELF文件；UCLinux的工具链<code>xxx-uclinuxeabi-gcc</code>可以直接生成可在UCLinux下运行的flat文件，并附带一个后缀为.gdb的ELF文件用于调试；这些ELF文件都是可执行类型的。</p><p>但是nuttx的应用程序是可重定位类型的，就是<code>.o</code>级别的，因此其实并不需要<code>xxx-nuttx-gcc</code>，直接用<code>xxx-none-gcc</code>、<code>xxx-unknown-gcc</code>就可以了。另外nuttx的buildroot制作的<code>xxx-nuttx-gcc</code>其实跟Linux、UCLinux的并不是一回事，也不能不加参数一步到位生成可执行的ELF。这时我们应该显示地<strong>先编译再链接</strong>，链接时候需要加参数<code>-r</code>以告诉ld要生成relocatable的ELF。</p><p>作为例子，假设有这样一个c应用程序：</p><pre><code class="c">// hello.c#include &lt;stdio.h&gt;int main(void){  printf(&quot;Hello from Add-On Program!\n&quot;);  return 0;}</code></pre><p>该程序中printf是C库函数，在nuttx内核提供的C库里。所以问题就是要将找到printf符号。如果用的是工具链里的C库（<code>riscv32-unknown-elf-</code>用的是<code>newlib</code>），那上面的printf有可能会被编译器解释为putc。如果用nuttx打包的头文件的话就还是printf。这个程序的重定位表有以下表项：</p><pre><code>偏移量     信息    类型              符号值      符号名称 + 加数00000000  0000071a R_RISCV_HI20      00000000   .LC0 + 000000006  0000071b R_RISCV_LO12_I    00000000   .LC0 + 00000000c  00000b12 R_RISCV_CALL      00000000   printf + 0</code></pre><p>其中前两个是字符串常量<code>&quot;Hello from Add-On Program!\n&quot;</code>，最后一个是<code>printf</code>符号。</p><h4 id="内核没有符号表：直接链到固定地址"><a href="#内核没有符号表：直接链到固定地址" class="headerlink" title="内核没有符号表：直接链到固定地址"></a>内核没有符号表：直接链到固定地址</h4><p>由于并没有外部符号表，因此<strong>printf不能是UND符号</strong>。例子中用了两次链接。第一次将所有编译的<code>.o</code>链接为一个可重定位的文件（相当于archive了一次）；然后第二次链接，填入所有未定义符号。</p><p>编译完nuttx内核，就会生成一个<code>System.map</code>文件，里面列举了所有全局变量和函数的地址，其中就包括C库的函数。我们找到<code>printf</code>的地址，假设它是<code>0x23015bc2</code>。可以在ld script里面加一句话：<code>printf=0x23015bc2;</code>，也可以为ld加参数<code>--defsym=printf=0x23015bc2</code>。这样就能消掉printf的未定义。</p><p><code>printf</code>未定义时，符号表里是这样的：</p><pre><code>11: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</code></pre><p>第二次链接之后，<code>printf</code>被resolved成一个absolute的值<code>0x23015bc2</code>。</p><pre><code> 8: 23015bc2     0 NOTYPE  GLOBAL DEFAULT  ABS printf</code></pre><h4 id="内核有符号表：根据静态符号表链入内核"><a href="#内核有符号表：根据静态符号表链入内核" class="headerlink" title="内核有符号表：根据静态符号表链入内核"></a>内核有符号表：根据静态符号表链入内核</h4><p>这时就允许<code>printf</code>是UND符号了，因为有外部符号表。但是这个符号表需要写死在内核里。如果只需要printf的话可以这样写一个数组：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;nuttx/binfmt/symtab.h&gt;const struct symtab_s g_symtab[] ={  {&quot;printf&quot;, (FAR void *)printf}};int g_nsymbols = 1;</code></pre><p>其中<code>g_symtab</code>、<code>g_nsymbols</code>都是在Kconfig里预定义好的符号。。。会在<code>binfmt/binfmt_execsymtab.c</code>里被引用。</p><p>nuttx也有工具去生成符号表，这个工具提供了源码：<code>tools/mksymtab.c</code>和<code>tools/cvsparser.c</code>可制作出<code>mksymtab</code>工具，它输入一个<code>.csv</code>文件，输出一个<code>.c</code>文件。<code>.csv</code>文件在源码里就有，它枚举了函数名、参数等信息。<code>tools/README.txt</code>里建议这样生成符号表数组：</p><pre><code>$ cd nuttx/tools$ cat ../syscall/syscall.csv ../libs/libc/libc.csv | sort &gt; tmp.csv$ ./mksymtab tmp.csv tmp.c</code></pre><p>然后将符号表加入源码中编译即可。不过源码中提供的csv文件有点问题，有些函数还没有实现，需要一个个去除。。</p><p>ELF程序可以放在一张SD卡里面，然后执行：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino2/helloaddon.jpeg" alt="helloworld" title="">                </div>                <div class="image-caption">helloworld</div>            </figure></p><h4 id="nuttx内核打包"><a href="#nuttx内核打包" class="headerlink" title="nuttx内核打包"></a>nuttx内核打包</h4><p>可以将nuttx的头文件和静态链接库打包出去制作SDK。</p><pre><code>$ make export</code></pre><p>它将所有头文件打包，包括arch级以及板极的头文件，加上两个archives：<code>libnuttx.a</code>和<code>libapps.a</code>。头文件可以用于制作<code>xxx-nuttx-gcc</code>工具链；利用这个SDK可以对固件做二次开发。可参考<a href="http://nuttx.org/doku.php?id=wiki:nshhowtos:external-applications" target="_blank" rel="noopener">Building NuttX with Applications Outside of the Source Tree</a>，以及<a href="https://acassis.wordpress.com/2017/03/28/using-nuttx-as-a-library/" target="_blank" rel="noopener">Using NuttX as a library</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用程序需要内核提供各种服务才能运行，服务通过库以及相应的ABI（Application Binary Interface，应用程序二进制接口）来提供，比方说C库等。nuttx的应用程序可以内置在内核中（built-in），也可以与内核分开（separate），即运行外部可执行文件。目前它支持两种可执行文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ELF&lt;/code&gt;，就是Linux下标准的ELF可执行文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NXFLAT&lt;/code&gt;，它是简化版的&lt;code&gt;XFLAT&lt;/code&gt;；XFLAT原为UCLinux开发，特点在于体积小、可以就地运行（XIP）；简化在于，NXFLAT不支持动态链接，不能导出符号表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文讨论如何为nuttx添加riscv的ELF支持，以及如何制作nuttx ELF应用程序。以下叙述适用于&lt;code&gt;nuttx-7.25&lt;/code&gt;，nuttx还很年轻，即使是小版本之间的代码变动也可能会比较大。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nuttx" scheme="http://yoursite.com/tags/nuttx/"/>
    
      <category term="pulpino" scheme="http://yoursite.com/tags/pulpino/"/>
    
      <category term="riscv" scheme="http://yoursite.com/tags/riscv/"/>
    
  </entry>
  
  <entry>
    <title>pulpino[1] nuttx：bring up</title>
    <link href="http://yoursite.com/pulpino1/"/>
    <id>http://yoursite.com/pulpino1/</id>
    <published>2018-07-23T13:19:06.000Z</published>
    <updated>2019-04-27T15:28:29.508Z</updated>
    
    <content type="html"><![CDATA[<p>PULPino是<a href="https://www.pulp-platform.org/" target="_blank" rel="noopener">PULP</a>的一个子项目，<code>PULP</code>全称“Parallel Ultra Low Power”，是一个<a href="http://riscv.org/" target="_blank" rel="noopener">RISC-V</a>项目，旨在搭建低功耗的多核嵌入式SOC。PULPino是一个单核的单片机的架构，CPU内核除了实现RISCV的I、M、C指令集之外还扩展了一些类似于DSP的指令集，使其<a href="https://riscv.org/wp-content/uploads/2016/01/Wed1315-PULP-riscv3_noanim.pdf" target="_blank" rel="noopener">计算性能超过了ARM Cortex M4</a>、硅片面积更小、功耗更低。。。</p><p>PULPino的<a href="https://github.com/pulp-platform/pulpino/tree/master/sw" target="_blank" rel="noopener">例程</a>用cmake来管理；其中有FreeRTOS的简单移植。FreeRTOS说到底就是一个scheduler，其他东西基本上连架构都没有，啥都要自己动手。</p><p>就功能而言适用于无MMU的操作系统最强的当属<a href="http://www.nuttx.org/" target="_blank" rel="noopener">nuttx</a>，号称“Linux on microcontroller”，文件系统、网络、应用程序一应俱全，而且非常小巧，完全没有UCLinux那般臃肿。作为例子，若在stm32上要用网络，则nuttx不用特别裁剪优化得到100kB左右的bin，而UCLinux疯狂裁剪之后得到1MB左右的bin。</p><p>目前nuttx里有riscv的基本移植，但要移植到PULPino上还需要非常多的功夫。本文阐述nuttx的踩坑历程。</p><a id="more"></a><h3 id="nuttx世界观"><a href="#nuttx世界观" class="headerlink" title="nuttx世界观"></a>nuttx世界观</h3><p>Nuttx的创立者名叫Gregory Nutt，命名有Linus风范。nuttx定位在从RTOS到Linux的这段广阔的中间地带：这里有着很多“高性能”的MCU，也有一些有MMU的GHz主频级别的应用处理器，甚至是SMP多核处理器。</p><p>nuttx的功能多得令人咋舌，驱动架构、VFS、可执行文件、各种文件系统、网络、shell、web服务器、图形框架等等应有尽有，而且支持非常多的架构（其中大部分是ARM的，其中又有大部分是NXP和STM32的片子），几乎实现了UCLinux的所有东西并且代码时刻在更新。nuttx工程由<a href="https://bitbucket.org/nuttx/nuttx" target="_blank" rel="noopener">Bitbucket</a>托管，如果想贡献代码的话直接给Nutt发邮件即可。。。</p><p>对于系统程序员而言需要特别留意<a href="http://nuttx.org/Documentation/NuttxPortingGuide.html" target="_blank" rel="noopener">Nuttx Porting Guide</a>，在源码里也有<code>Documentation/NuttxPortingGuide.html</code>。</p><h4 id="多架构的管理"><a href="#多架构的管理" class="headerlink" title="多架构的管理"></a>多架构的管理</h4><p>nuttx将SOC的移植分为三个层次：</p><ul><li>架构（arch），即不同的ISA，如ARM、x86、RISCV等；同一类ISA放在<code>arch/</code>目录下面的不同子目录，比如<code>arch/arm/src/armv7-a</code>、<code>arch/arm/src/armv7-m</code>等。</li><li>芯片（chip），即同一个ISA下的不同芯片，如使用ARM架构的不同STM32芯片；它们放在架构目录下的不同子目录中，如<code>arch/arm/src/stm32</code>、<code>arch/arm/src/stm32l4</code>等。</li><li>板极（board），即使用一个chip做出的不同板子，主控一样但是引出的外设、具有的存储器、地址映射等有所不同；它们放在<code>configs/</code>目录下面，如一些有名的板子像<code>configs/stm32f4discovery/</code>、<code>configs/stm32f429i-disco/</code>等。</li></ul><p>在架构级目录下面实现的是诸如进程调度、系统调用、信号之类的与ISA息息相关的东西。</p><p>在芯片级目录下面实现的是片子的外设驱动，以及它的启动文件（需要实现启动代码和中断向量表）。值得一提的是Linux的外设驱动分散在它的<code>drivers/</code>目录下面，而<code>arch/xxx/mach-xxx/</code>目录下面又只有非常少的东西。</p><p>在板极目录下面实现的一般是外挂设备的<em>初始化</em>，比方说SDIO上挂了一个WiFi网卡，SPI上挂了一个flash等。这些驱动一般放在<code>drivers/</code>目录下面，毕竟外接设备与架构无关。</p><p>于是一目了然，要做某些层次的移植就要关注那些层次的目录。</p><h4 id="内核运行方式"><a href="#内核运行方式" class="headerlink" title="内核运行方式"></a>内核运行方式</h4><p>nuttx可以有三种运行方式：</p><ul><li>扁平模式（flat），不区分<code>内核空间</code>和<code>用户空间</code>，就跟普通的小RTOS一样；<strong>STM32等的nuttx实现都是flat模式</strong>；</li><li>保护模式（protected），需要有<code>MPU</code>来保护<code>内核空间</code>，而所有应用程序都在同一个<code>用户空间</code>；</li><li>内核模式（kernel），适用于有<code>MMU</code>的系统，内核、不同的应用程序都在不同的地址空间。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino1/nuttx1.jpeg" alt="nuttx1" title="">                </div>                <div class="image-caption">nuttx1</div>            </figure><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><p>为体现模块化，nuttx的应用程序与内核分开来开发，编译时候要分别<a href="http://www.nuttx.org/doku.php?id=downloads" target="_blank" rel="noopener">下载</a><code>nuttx-xxx.tar.gz</code>和<code>apps-xxx.tar.gz</code>。应用程序可以有两类：</p><ul><li>内建的（built-in），跟内核绑在一起，从而可以直接调用nuttx C库。<code>apps</code>目录下开发的所有东西都是内建程序，小到helloworld，中到shell和各种实用工具，大到web服务器，都可以是内建的。。。</li><li>可执行文件，这些程序都放到文件系统里面。可以有<a href="http://www.nuttx.org/Documentation/NuttXBinfmt.html" target="_blank" rel="noopener">两种文件格式</a>：<ul><li>ELF，需要用nuttx buildroot生成的gcc工具链来编译。</li><li><a href="http://nuttx.org/Documentation/NuttXNxFlat.html" target="_blank" rel="noopener">NXFLAT</a>，这是简化版的<a href="http://xflat.sourceforge.net/" target="_blank" rel="noopener">XFLAT</a>，体积小，而且可以在文件系统中就地运行（XIP）从而减少RAM的消耗。目前它只能跑在romfs上。。</li></ul></li></ul><h4 id="简洁的驱动架构"><a href="#简洁的驱动架构" class="headerlink" title="简洁的驱动架构"></a>简洁的驱动架构</h4><p>与Linux纷繁复杂的驱动架构相比nuttx简单多了。Linux支持的设备太多太复杂了，以至于现在每一个驱动都是一个复杂的架构，比如时钟系统、电源管理等等，程序员要同时关注数个对象、数十个方法；另外它还开发出很多gdb不友好的“动态”的技巧，比方说链表、container_of云云，以至于调bug几乎只能靠打log来猜。。</p><p>小型嵌入式系统在驱动层面上往往没有那么多“动态”的东西：外设少而且几乎都是MMIO，而且并不指望同一个系统镜像能运行在不同类型的板子上，因此它不需要设备树之类的东西；该有的对象直接静态地列出就好。关于设备树的讨论可见笔者<a href="/ucpc4/">之前的博客</a>。</p><p>值得一提的是nuttx中类的继承关系只有<code>单继承</code>，而且子类的第一个成员对象是父类的实例。这样做的好处是，要通过父类找子类只需要对父类指针cast一下就可以了，根本不需要container_of之类的东西。Java也只有单继承（接口不算），说明这样做也没啥不妥的。</p><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>与Linux一样，nuttx也使用kbuild来管理工程。用Kconfig脚本，<code>make menuconfig</code>来配置，最后正式编译之前将配置项生成<code>include/nuttx/config.h</code>头文件，根据各个目录下面的<code>Make.defs</code>来确定要编译哪些文件、要加哪些编译参数。</p><p>配置是板极的，一个板子可以有很多个配置，比方说stm32f429-discovery就有：串口shell（nsh）、USB shell（usbnsh）、图形界面（nxwm）等等配置。板极目录下面有这些子目录：</p><ul><li><code>src/</code>和<code>include/</code>，放C语言程序，进行设备初始化。</li><li><code>scripts/</code>，放各种脚本如：链接脚本、Make.defs（设置编译参数）、调试脚本（如gdb脚本、openocd脚本等）</li><li>其他子目录，是各种默认配置，里面只有一个文件，名叫<code>defconfig</code>。</li></ul><p>defconfig非常小，只保留必要信息，可通过遍历整个工程的Kconfig来还原<code>.config</code>。这个过程由<code>tools/configure.sh</code>来进行。比方说要还原<code>configs/xxboard/xxconf/defconfig</code>，则用以下命令：</p><pre><code>$ ./tools/configure.sh xxboard/xxconf</code></pre><p>生成defconfig方法如下：</p><pre><code>$ make savedefconfig...$ mv defconfig configs/xxboard/xxconf</code></pre><h3 id="PULPino底层移植"><a href="#PULPino底层移植" class="headerlink" title="PULPino底层移植"></a>PULPino底层移植</h3><p>PULPino指令集包括RISCV-IMC以及扩充的计算指令集，系统层面的话只需要关注RISCV的指令即可。由于nuttx里面有RISCV-IM的基本实现，而且需要汇编实现的部分很短而不需要考虑压缩指令集，因此只需要实现chip级以及board级的东西就可以了。</p><ul><li>chip级：<code>arch/risc-v/src/pulpino</code>和<code>arch/risc-v/include/pulpino</code></li><li>board级：<code>configs/pulpino</code>；参照<code>configs/nr5m100-nexys4</code>，一款野生的跑在FPGA上的riscv板子。。</li></ul><h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>因为PULPino既没有MMU也没有MPU，因此内核只能以flat模式运行，整个操作系统就相当于一个程序。由低址到高址可连续地分为以下几段：</p><ul><li>text段：内核的代码段，只读；</li><li>data段：内核的非零的全局变量；</li><li>bss段：内核的清零的全局变量；</li><li>heap段：内核的malloc区域（新建任务的所有东西也都放在这里），又分为两部分：<ul><li>idle task的堆栈区，由<code>CONFIG_IDLETHREAD_STACKSIZE</code>配置大小。从reset handler开始就算idle task了，因此启动代码的堆栈要设置在这里。</li><li>剩下的所有内存空闲区域都留作heap。由arch/risc-v/src/common/up_allocateheap.c:<code>up_allocate_heap()</code>返回基地址和大小。</li></ul></li></ul><p>链接脚本<a href="#2-5-2、链接脚本">见下文</a>。</p><h4 id="启动代码"><a href="#启动代码" class="headerlink" title="启动代码"></a>启动代码</h4><p>根据<a href="https://pulp-platform.org//wp-content/uploads/2017/11/ri5cy_user_manual.pdf" target="_blank" rel="noopener">RI5CY手册</a>，复位后CPU从0x80处开始执行，那里是一条跳转指令。如果链接脚本没有注明入口，则pulpino的工具链默认0x8C处是reset handler。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino1/vectortable.jpeg" alt="vector" title="">                </div>                <div class="image-caption">vector</div>            </figure><p>启动时，将31个寄存器清零，将bss段清零，初始化data段，然后跳转到c语言程序中（<em>由于目前用JTAG直接下载ELF，因此data段实际上不需要初始化</em>）。如果没什么特别的初始化的话，可以直接跳转到内核的os_start()函数。。</p><pre><code class="c">reset_handler:  /* 清零寄存器 */  mv  x1, x0  mv  x2, x1  ...  mv x31, x1  /* 清零bss段 */  la x26, _sbss  la x27, _ebss  bge x26, x27, zero_loop_endzero_loop:  sw x0, 0(x26)  addi x26, x26, 4  ble x26, x27, zero_loopzero_loop_end:  /* 初始化全局变量 */  //call    __libc_init_array  /* 初始化堆栈指针：idle task的堆栈 */  la   x2, IDLE_TASK_STACKmain_entry:  /* 直接跳到os_start() */  jal x1, os_start</code></pre><h4 id="中断处理与任务切换"><a href="#中断处理与任务切换" class="headerlink" title="中断处理与任务切换"></a>中断处理与任务切换</h4><h5 id="nuttx内核API"><a href="#nuttx内核API" class="headerlink" title="nuttx内核API"></a>nuttx内核API</h5><p>nuttx的中断由内核统一管理，编写的ISR需要统一向内核注册，无论芯片是否支持向量中断：</p><pre><code class="c">#include &lt;nuttx/irq.h&gt;int foo_isr(int irq, FAR void *context, FAR void *arg);    // 将foo_isr注册到编号为IRQN的中断线上    irq_attach(IRQN, foo_isr);</code></pre><p>所有中断程序有统一入口：</p><pre><code class="c">#include &lt;nuttx/arch.h&gt;// 传入中断号以及栈顶指针void irq_dispatch(int irq, FAR void *context);</code></pre><h5 id="PULPino的简易中断控制"><a href="#PULPino的简易中断控制" class="headerlink" title="PULPino的简易中断控制"></a>PULPino的简易中断控制</h5><ul><li>PULPino有向量中断。中断向量表的前32个即分别为其中断入口。中断向量表地址由<code>BOOTREG</code>寄存器设置，其地址为<code>0x1A107008</code>，默认地址是0x00000000。</li><li>它还有一个简易中断控制器，名叫Event Unit，<em>是一个外设</em>。串口、SPI、I2C、定时器之类的中断都由它来处理：</li></ul><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">MM地址</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">IER</td><td style="text-align:left">0x1A104000</td><td style="text-align:left">32位，每位写1使能中断</td></tr><tr><td style="text-align:left">IPR</td><td style="text-align:left">0x1A104004</td><td style="text-align:left">32位，每位读1代表发生了这个中断</td></tr><tr><td style="text-align:left">ISP</td><td style="text-align:left">0x1A104008</td><td style="text-align:left">32位，每位写1手动触发这个中断</td></tr></tbody></table><ul><li>内核方面，PULPino只实现了少量必要的CSR寄存器。以下是<code>老版pulpino</code>实现的与中断相关的寄存器：</li></ul><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">CSR地址</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">MSTATUS</td><td style="text-align:left">0x300</td><td style="text-align:left">最低位控制全局使能（新版变了）</td></tr><tr><td style="text-align:left">MEPC</td><td style="text-align:left">0x341</td><td style="text-align:left">中断返回地址</td></tr></tbody></table><ul><li>PULPino扩展了循环指令，需要用到两组共6个循环计数器，它们都是CSR寄存器，CSR地址0x7B0-0x7B2和0x7B4-0x7B6；它们在中断时都需要保存。</li></ul><h5 id="nuttx任务的数据结构"><a href="#nuttx任务的数据结构" class="headerlink" title="nuttx任务的数据结构"></a>nuttx任务的数据结构</h5><pre><code class="c">#include &lt;nuttx/sched.h&gt;struct tcb_s {  /* 一些架构无关的东西 */  ...  /* 中断上下文 */  struct xcptcontext xcp;};</code></pre><p>其中<code>struct xcptcontext</code>每个架构都不同。riscv的在<code>arch/risc-v/include/rv32im/irq.h</code>：</p><pre><code class="c">struct xcptcontext {  /* 信号等东西 */  ...  /* 寄存器组 */  uint32_t regs[XCPTCONTEXT_REGS];}</code></pre><p>其中<code>XCPTCONTEXT_REGS</code>定义为39，编制如下：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">寄存器</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">中断返回地址，即<code>mepc</code>值</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left"><code>x1</code>寄存器</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>x2</code>寄存器，堆栈指针</td></tr><tr><td style="text-align:left">3-31</td><td style="text-align:left">其他通用寄存器</td></tr><tr><td style="text-align:left">32</td><td style="text-align:left"><code>mstatus</code>值</td></tr><tr><td style="text-align:left">33-38</td><td style="text-align:left">6个循环计数器</td></tr></tbody></table><p>刚初始化任务时，<code>up_initial_state()</code>函数在<code>struct tcb_s</code>内设置入口地址和堆栈指针。</p><h5 id="中断返回伴随着任务切换"><a href="#中断返回伴随着任务切换" class="headerlink" title="中断返回伴随着任务切换"></a>中断返回伴随着任务切换</h5><p>因为有可能某个进程正在睡眠等待某个事件，比方说串口接收中断来了，那么getchar()就可以返回了。另外显式的up_switchcontext()通过系统调用来切换任务。将syscall处理程序也注册为一个IRQ即可统一这个过程。</p><p>扁平模式下的任务切换只需换堆栈。因此整个中断处理流程如下：</p><ul><li>中断发生</li><li>汇编程序将39个寄存器压栈；</li><li>汇编将中断号和堆栈指针传入C语言写的中断处理程序；</li><li>中断处理程序或许会返回一个新堆栈指针；</li><li>汇编将寄存器组弹出；</li><li>中断返回</li></ul><p>严格来说syscall应该归为“异常（exception）”，而普通的外部中断归为“中断（interrupt）”。因为exceptions一般都是“同步的”，就像非法指令异常、除以零异常、精确总线异常、系统调用等，都由正常或不正常的CPU指令触发；interrupts则是“异步的”，由CPU片外的东西不时触发。更精细地说，异常发生时那条触发异常的指令没有执行完毕，而中断发生时上一条指令执行完毕而下一条指令还没开始。因此异常返回到触发异常的那条指令，而中断返回返回到那条指令的下一条指令。</p><p>可以简单将syscall注册为一个IRQ，但是它的汇编wrapper要手动将返回地址加4，跳过<code>ecall</code>（新riscv标准为<code>mcall</code>）指令，免得死循环。</p><h5 id="细致的切换过程"><a href="#细致的切换过程" class="headerlink" title="细致的切换过程"></a>细致的切换过程</h5><p>非正在运行状态的任务，寄存器组信息存放在<code>tcb_s::xcptcontext</code>中，进入运行状态则从那里复原寄存器组。但是中断是随机发生的，汇编并不知道该任务的tcb在哪，而且保存寄存器组之前不能破坏原来的寄存器因而不能找全局变量或者调用C程序；因此寄存器组只能暂存在原来任务的堆栈上。传入的上下文指针是此时的栈顶指针。</p><ul><li>如果要进行任务切换，则将寄存器组复制到旧tcb中，最后返回新tcb的寄存器组。<ul><li>任务初始化时tcb中的寄存器组由架构相关的代码初始化，主要就是堆栈和入口地址，也可以对寄存器染色。这是<code>up_initial_state()</code>的工作。</li></ul></li><li>如果不用任务切换，则寄存器组指针不变，汇编wrapper还是从栈上复原寄存器。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino1/taskswitch.jpeg" alt="taskswitch" title="">                </div>                <div class="image-caption">taskswitch</div>            </figure><p>非得把寄存器组放在tcb里而不是直接留在堆栈，笔者认为这考虑到统一管理、便于调试。放在tcb里的话C语言程序就很方便操作，而且gdb可以直接打印整个结构体。另外gdb不认中断上下文，它不放在堆栈就不会干扰gdb找call stack，也便于通用的探针程序去操作。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>PULPino没有实现RISCV内核的定时器，而是实现了两个简易的32位计数器作为外设。定时器的寄存器如下：</p><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">MM地址</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">TIMER</td><td style="text-align:left">0x1A103000</td><td style="text-align:left">当前计数器值</td></tr><tr><td style="text-align:left">CTRL</td><td style="text-align:left">0x1A103004</td><td style="text-align:left">最低位写1开启计数器</td></tr><tr><td style="text-align:left">CMP</td><td style="text-align:left">0x1A103008</td><td style="text-align:left">当计数器值达到它时触发中断</td></tr></tbody></table><p>一个定时器有两个中断：</p><ul><li><code>TIMER</code>达到<code>CMP</code>寄存器的值时；</li><li><code>TIMER</code>溢出时；（计数4亿个周期，一两百兆的时钟的话需要好几十秒）</li></ul><p>操作很简单：</p><ul><li>初始化时，根据<code>CONFIG_USEC_PER_TICK</code>设置定时器比较值，开定时器，注册中断函数。</li><li>定时器中断时，重置计数器，随后调用内核<code>sched_process_timer()</code>即可。</li></ul><h4 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h4><h5 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h5><p>这是arch级别的配置。</p><p>推荐使用<a href="https://github.com/pulp-platform/ri5cy_gnu_toolchain" target="_blank" rel="noopener">ETH定制的riscv32-unknown-elf-gcc</a>。需要注意的是要checkout到老commit，因为新版PULPino指令集有所更改。用RISCV原生工具生成I、M、C指令集也可以运行，只是不能用PULPino的扩展了。</p><p>同时在nuttx源码中更改工具链。首先在<code>arch/risc-v/src/rv32im/Kconfig</code>中添加一个config选项：</p><pre><code>config RI5CY_ETH_TOOLCHAIN    bool &quot;ETH version toolchain&quot;</code></pre><p>随后在<code>arch/risc-v/src/rv32im/Toolchain.defs</code>中添加编译参数：</p><pre><code>ifeq ($(filter y, $(CONFIG_RI5CY_ETH_TOOLCHAIN)),y)  CONFIG_RISCV_TOOLCHAIN ?= GNU_RISCYendififeq ($(CONFIG_RISCV_TOOLCHAIN),GNU_RISCY)  CROSSDEV ?= riscv32-unknown-elf-  ARCROSSDEV ?= riscv32-unknown-elf-  ARCHCPUFLAGS = -m32 -march=IMXpulpv2 -mrvc  MAXOPTIMIZATION ?= -Osendif</code></pre><p><code>ARCHCPUFLAGS</code>中的<code>-m32 -march=IMXpulpv2</code>选项将使用PULPino扩展的指令集，<code>-mrvc</code>将使用RISCV-C压缩指令集。<code>MAXOPTIMIZATION</code>是gcc的通用优化选项，<code>-Os</code>是对size的优化。加了这些参数之后生成代码体积可以与ARM Thumb2指令集相媲美。。</p><h5 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h5><p>这是board级别的配置。工作目录在<code>configs/pulpino/scripts/</code>：</p><ul><li>建立链接脚本为<code>link.ld</code></li><li>在<code>Make.defs</code>中设置链接脚本：<code>LDSCRIPT = link.ld</code></li></ul><p>我们pulpino挂了一块挺大的DDR内存。参照内存映射（<a href="#2-1、内存映射">见上文</a>）写链接脚本，简化如下：</p><pre><code>MEMORY{    instrram : ORIGIN = 0x23000000, LENGTH = 0x1000000    dataram  : ORIGIN = 0x24000000, LENGTH = 0x1000000}SECTIONS{    .text : {        _stext = .;        *(.text)        _etext = .;    } &gt; instrram    .data : {        . = ALIGN(4);        _sdata = .;        *(.data);        _edata = .;    } &gt; dataram    .bss :    {        . = ALIGN(4);        _sbss = .;        *(.bss)        _ebss = .;    } &gt; dataram}</code></pre><p>关键就是暴露一些变量，例如data段的开始和结束<code>_sdata</code>、<code>_edata</code>，bss段的开始和结束<code>_sbss</code>、<code>_ebss</code>，以供reset handler初始化它们。</p><h4 id="启动nsh"><a href="#启动nsh" class="headerlink" title="启动nsh"></a>启动nsh</h4><p>PULPino有一个兼容<code>16750</code>的串口。PC机上的8250、16550、16750之类的串口一脉相承，软件基本上兼容，只是后续的型号速度更快、FIFO更深等等。对于常用的115200波特率而言，可以直接使用nuttx的16550驱动。为此只需要配置好寄存器基地址，并实现<code>uart_getreg()</code>和<code>uart_putreg()</code>即可。</p><pre><code>-&gt; Device Drivers  -&gt; Serial Driver Support    -&gt; 16550 UART Chip support</code></pre><p>另外还要选择串口作为终端：</p><pre><code>-&gt; Device Drivers  -&gt; Serial Driver Support    -&gt; Serial console (UART)</code></pre><p>随后配置nsh library：</p><pre><code>-&gt; Application Configuration  -&gt; NSH Library</code></pre><p>最后使能nsh：</p><pre><code>-&gt; Application Configuration  -&gt; Examples    -&gt; NuttShell (NSH) example</code></pre><p>编译通过后就可以在串口上操作shell了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pulpino1/nsh.jpeg" alt="nsh" title="">                </div>                <div class="image-caption">nsh</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PULPino是&lt;a href=&quot;https://www.pulp-platform.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PULP&lt;/a&gt;的一个子项目，&lt;code&gt;PULP&lt;/code&gt;全称“Parallel Ultra Low Power”，是一个&lt;a href=&quot;http://riscv.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RISC-V&lt;/a&gt;项目，旨在搭建低功耗的多核嵌入式SOC。PULPino是一个单核的单片机的架构，CPU内核除了实现RISCV的I、M、C指令集之外还扩展了一些类似于DSP的指令集，使其&lt;a href=&quot;https://riscv.org/wp-content/uploads/2016/01/Wed1315-PULP-riscv3_noanim.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算性能超过了ARM Cortex M4&lt;/a&gt;、硅片面积更小、功耗更低。。。&lt;/p&gt;
&lt;p&gt;PULPino的&lt;a href=&quot;https://github.com/pulp-platform/pulpino/tree/master/sw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;例程&lt;/a&gt;用cmake来管理；其中有FreeRTOS的简单移植。FreeRTOS说到底就是一个scheduler，其他东西基本上连架构都没有，啥都要自己动手。&lt;/p&gt;
&lt;p&gt;就功能而言适用于无MMU的操作系统最强的当属&lt;a href=&quot;http://www.nuttx.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nuttx&lt;/a&gt;，号称“Linux on microcontroller”，文件系统、网络、应用程序一应俱全，而且非常小巧，完全没有UCLinux那般臃肿。作为例子，若在stm32上要用网络，则nuttx不用特别裁剪优化得到100kB左右的bin，而UCLinux疯狂裁剪之后得到1MB左右的bin。&lt;/p&gt;
&lt;p&gt;目前nuttx里有riscv的基本移植，但要移植到PULPino上还需要非常多的功夫。本文阐述nuttx的踩坑历程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nuttx" scheme="http://yoursite.com/tags/nuttx/"/>
    
      <category term="pulpino" scheme="http://yoursite.com/tags/pulpino/"/>
    
      <category term="riscv" scheme="http://yoursite.com/tags/riscv/"/>
    
  </entry>
  
  <entry>
    <title>山寨平板上的ubuntu</title>
    <link href="http://yoursite.com/ubuntu-tablet/"/>
    <id>http://yoursite.com/ubuntu-tablet/</id>
    <published>2018-06-15T10:03:22.000Z</published>
    <updated>2019-04-27T15:26:26.688Z</updated>
    
    <content type="html"><![CDATA[<p>几百块钱的Windows寨板一般都是这样的配置：CPU是Intel的Baytrail z3735f，或者Cherrytrail z8300/z8350，都是不到2GHz的四核凌动x86，而后者的核显性能数倍于前者（虽然性能都不高，但还是属于吊打树莓派的那种）。内存一般是2GB，而z83xx可以上4GB，只是性能会有所降低。闪存一般是32GB的emmc flash，聊胜于无。外设方面就是触屏WiFi蓝牙SD卡USB云云。它们一般跑着win10或者win+Android双系统。</p><p>对于树莓派一类玩家而言这些寨板吸引人的地方在于，价格便宜！x86的性能强！主频高内存大！WiFi！屏幕！然而虽然是x86的机器，它们并不能直接安装Ubuntu一类系统，原因在于：</p><ul><li>32位UEFI，因为32位的Windows占用空间小一些</li><li>驱动非常不齐全</li></ul><p>以没经过处理的<code>Ubuntu-1404</code>为例，64位镜像因为机子UEFI是32位的而无法启动，32位镜像没有EFI启动文件也启动不了。强行给32位镜像补上EFI文件则可以顺利安装，然而电池、SD卡、触屏、WiFi、声卡、屏幕调光、按键、陀螺仪、摄像头之类的驱动统统没有，只有USB能用。。。</p><p>要解决这两个问题势必要经过一些折腾。</p><a id="more"></a><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>少数安卓双系统的机子用的是64位UEFI，因此可以直接启动64位镜像。然而大多数机子并不能直接启动Ubuntu镜像。虽然32位UEFI只可以运行32位的<code>.efi</code>，但是<code>multiarch</code>版的镜像的efi可以接着启动64位的程序，从而启动到grub并继续启动下去。</p><h4 id="multi-arch"><a href="#multi-arch" class="headerlink" title="multi-arch"></a>multi-arch</h4><p>新版的Debian 9可以直接下载<a href="https://cdimage.debian.org/debian-cd/current/multi-arch/iso-cd/" target="_blank" rel="noopener">multi-arch</a>版本的镜像，它的关键是有<code>efi/boot/bootia32.efi</code>这个文件，从而可以用32位UEFI启动64位镜像。但是Debian装后只有基本系统，后续定制起来有点麻烦。</p><p>有个野生的名叫<a href="https://sourceforge.net/projects/xjubuntu/files/" target="_blank" rel="noopener">XJUbuntu</a>的发行版定制了很多东西，其中有个玩家在他的台电X98 plus平板上定制Ubuntu 16.04，跑通了很多东西，制作了所谓<a href="https://xjesus.net/xjubuntu/xjubuntab-tablet-customizedcustomizable-distro-based-on-xubuntu-14-04-64-bits/" target="_blank" rel="noopener">XJUbuntuTAB</a>。但是这个镜像很大，定制的xfce桌面我也并不特别习惯，并且很多关键驱动如电池、触屏在我平板上都不行。</p><p>如果要用原生Ubuntu，可以将<code>bootia32.efi</code>加到其中从而使其可以启动；</p><ul><li>如果用Debian multiarch的efi，还需要多改一些东西。<a href="https://askubuntu.com/questions/392719/32-bit-uefi-boot-support" target="_blank" rel="noopener">这篇问答</a>详细解释了如何操作。</li><li>如果用<a href="https://github.com/hirotakaster/baytail-bootia32.efi" target="_blank" rel="noopener">这个efi</a>，直接丢到镜像中就好了。</li></ul><h4 id="linuxium的工具"><a href="#linuxium的工具" class="headerlink" title="linuxium的工具"></a>linuxium的工具</h4><p>Linuxium是个机顶盒、电视棒的Linux玩家，<a href="http://linuxiumcomau.blogspot.com" target="_blank" rel="noopener">他的博客</a>有很多非常有意思的东西。为了在x86的电视棒上跑Ubuntu，他开发了<a href="http://linuxiumcomau.blogspot.com/2017/06/customizing-ubuntu-isos-documentation.html" target="_blank" rel="noopener">isorespin.sh</a>这个脚本，功能非常多，包括：</p><ul><li>添加32位UEFI启动文件</li><li>添加Apollo lake的必要文件（对于N3450系列的赛扬芯平板）</li><li>更改Linux内核，从而添加驱动补丁</li><li>新增软件包等，从而添加固件和驱动</li><li>运行脚本</li></ul><p>其实这些都是<a href="https://help.ubuntu.com/community/LiveCDCustomization" target="_blank" rel="noopener">Ubuntu-LiveCD定制</a>的工作，只是Ubuntu的wiki上对于UEFI的定制说明太少了。</p><p>利用<code>isorespin.sh</code>，可以为64位Ubuntu 18.04添加32位启动项：</p><pre><code>$ isorespin.sh -i ubuntu-18.04-desktop-amd64.iso</code></pre><p>因为它需要mount镜像，所以它需要root权限。需要留意的是虽然它可以用<code>--atom</code>来添加特别的驱动，比方说rtl8723bs的WiFi和蓝牙。但是这都要梯子才能下载，命令行中sudo之后的代理有点问题，所以这些东西还是启动之后再安装吧。大概半个小时之后它会生成一个名叫<code>linuxium-ubuntu-18.04-desktop-amd64.iso</code>的镜像（大部分时间用在squashfs的解压和重新生成上）。</p><h4 id="选择哪个桌面"><a href="#选择哪个桌面" class="headerlink" title="选择哪个桌面"></a>选择哪个桌面</h4><p>Ubuntu 17.10开始的官方发行版桌面为GNOME；但现在的GNOME 3问题在于太过耗资源了，刚启动就占了1个多GB，开两个gnome-terminal就快要炸了。轻量级的桌面有LXDE、XFCE等等，个人感觉XFCE稍微好看点。。。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ubuntu-tablet/screenfetch.png" alt="screen" title="">                </div>                <div class="image-caption">screen</div>            </figure></p><h3 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h3><p>越新版的内核，一些外设的驱动越有可能得到支持。比方说最新的Ubuntu 18.04，在我的<code>昂达V101W</code>上就能用<strong>SD卡、电池、背光调节、陀螺仪、开关机按钮</strong>了。其他的能折腾出来的驱动罗列如下。</p><h4 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h4><p>一般网卡是rtl8723bs，它的驱动已经合并到linux 4.12的staging目录下面了，所以Ubuntu 18.04有它的驱动。但是网卡还需要一个固件，可以从<a href="https://github.com/hadess/rtl8723bs" target="_blank" rel="noopener">hadess的github</a>上下载。</p><p>dmesg看到缺少这个固件：</p><pre><code>$ dmesg | grep rtl8723...[  170.823731] rtl8723bs: acquire FW from file:rtlwifi/rtl8723bs_nic.bin[  170.823790] rtl8723bs mmc0:0001:1: Direct firmware load for rtlwifi/rtl8723bs_nic.bin failed with error -2...</code></pre><p>就把固件复制到<code>/lib/firmware/rtlwifi/</code>目录下面，重新加载驱动即可。</p><pre><code>$ sudo cp rtl8723bs_nic.bin /lib/firmware/rtlwifi/$ sudo modprobe -r r8723bs$ sudo modprobe r8723bs$ dmesg | grep rtl8723...[  228.095947] rtl8723bs: acquire FW from file:rtlwifi/rtl8723bs_nic.bin...$ ifconfig wlan0wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.2.225  netmask 255.255.255.0  broadcast 192.168.2.255        inet6 fe80::74b5:1920:54c6:e8d  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 8c:18:d9:1f:3e:fd  txqueuelen 1000  (以太网)        RX packets 579  bytes 705015 (705.0 KB)        RX errors 0  dropped 582  overruns 0  frame 0        TX packets 605  bytes 70957 (70.9 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>对于博通系列的SDIO网卡也一样是补上固件就能用了。博通的驱动比较通用，几乎支持所有的<code>AP6xxx</code>模块；它除了需要固件以为还需要配置文件，这些都可以在github上找到，比方说<a href="https://github.com/Asus-T100/firmware" target="_blank" rel="noopener">华硕T100的固件</a>。</p><p>值得一提的是，<strong>Lubuntu 18.04</strong>的rtl8723bs则直接可用。</p><h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>蓝牙一般都是通过串口，以HCI协议进行交互。老版内核会认出一个MMIO的串口（通常是<code>ttyS4</code>），由一个systemd守护进程（而不是内核驱动）通过这个串口下载蓝牙固件、初始化、与之交互，详见<a href="https://github.com/lwfinger/rtl8723bs_bt" target="_blank" rel="noopener">这个仓库</a>的<a href="https://github.com/lwfinger/rtl8723bs_bt/blob/master/start_bt.sh#L9" target="_blank" rel="noopener">start_bt.sh</a>。</p><p>但是新版的内核引入了所谓<code>serdev</code>的概念，驱动事宜都由内核解决。这时串口就不仅仅是一个“字符设备”，而是一个“总线”了。这时它就不会将串口<code>/dev/ttySx</code>暴露给用户空间了。然而rtl8723bs的蓝牙驱动现在内核里面又没有，所以就需要一些内核补丁。</p><ul><li>可以用<a href="https://github.com/jwrdegoede/linux-sunxi/commit/bc904e3703940600ca66c65fcdb0a8cb01dff55d" target="_blank" rel="noopener">这个补丁</a>，它简单地加了一个判断，不要将OBDA8723设备注册为<code>serdev</code>，从而可以用之前的systemd守护进程。</li><li>或者用<a href="https://www.spinics.net/lists/linux-bluetooth/msg75848.html" target="_blank" rel="noopener">这些补丁</a>就详细实现了HCI5协议以及rtl8723bs的驱动，进而不需要用户空间的systemd了。其实这些补丁来自于<a href="https://github.com/jwrdegoede/linux-sunxi/tree/master/drivers/bluetooth" target="_blank" rel="noopener">Linux-sunxi</a>，虽然说是全志的专用内核，但是也包含了很多新奇趣怪的驱动，比方说jwrdegoede这位兄弟貌似在搞GPD win掌机的驱动。。</li></ul><p>linux 4.17内核打了sunxi的补丁，加上蓝牙的固件和配置文件（<a href="https://github.com/lwfinger/rtl8723bs_bt" target="_blank" rel="noopener">lwfinger的仓库</a>里面有），蓝牙就可以愉快地跑了。</p><pre><code>[    8.027854] Bluetooth: hci0: rtl: examining hci_ver=06 hci_rev=000b lmp_ver=06 lmp_subver=8723[    8.032153] Bluetooth: hci0: rom_version status=0 version=1[    8.032183] Bluetooth: hci0: rtl: loading rtl_bt/rtl8723bs_fw.bin[    8.033786] Bluetooth: hci0: rtl: loading rtl_bt/rtl8723bs_config-OBDA8723.bin[    8.064135] Bluetooth: hci0: cfg_sz 55, total size 24263</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ubuntu-tablet/bluetooth.png" alt="bluetooth" title="">                </div>                <div class="image-caption">bluetooth</div>            </figure><h4 id="触屏"><a href="#触屏" class="headerlink" title="触屏"></a>触屏</h4><p>很多win或安卓平板用的触屏芯片都是gslx680，一个I2C接口的电容屏芯片。它也需要固件，根据电容屏的行列布线不同而需要不同的固件。好事情是驱动和固件都能找到。</p><ul><li><a href="https://github.com/onitake/gslx680-acpi" target="_blank" rel="noopener">gslx680-acpi</a>适用于ACPI平台，可以加入内核中。</li><li><a href="https://github.com/onitake/gsl-firmware" target="_blank" rel="noopener">gsl-firmware</a>适用于不同的平板，如果没有支持的平板的话可用里面的工具自己生成。</li></ul><p>对于我的昂达V101W-V5平板来说，可以从<a href="http://cs.onda.cn/Tablet/ProductInfo.aspx?ProductId=328&amp;d=down" target="_blank" rel="noopener">昂达旧官网</a>上下载Windows驱动。找到<code>TP/SileadTouch.fw</code>这个固件，然后利用gsl-firmware的工具来生成适用的固件：</p><pre><code>$ tools/unscramble SileadTouch.fw silead_ts.fw$ sudo cp silead_ts.fw /lib/firmware</code></pre><p>生成的固件直接丢在<code>/lib/firmware/</code>目录下面就行了。这时启动之后就可以用触屏了。</p><pre><code>[    6.736112] gslx680 i2c-MSSL1680:00: gsl_ts_probe: got a device named MSSL1680:00 at address 0x40, IRQ 23, flags 0x0[    6.768964] byt_gpio INT33FC:02: [Firmware Bug]: pin 21 forcibly re-configured as GPIO[    6.770426] input: Silead GSLx680 Touchscreen as /devices/platform/80860F41:03/i2c-3/i2c-MSSL1680:00/input/input4</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ubuntu-tablet/touchscreen.jpg" alt="touchscreen" title="">                </div>                <div class="image-caption">touchscreen</div>            </figure><p>启动之后可以使用<code>xinput_calibrator</code>进行更细致的微调。</p><p><strong>另外要想加一些手势操作比方说长按右键、两根手指、三根手指、滑动等等，可以用<code>touchegg</code>来配置。</strong></p><h4 id="声卡"><a href="#声卡" class="headerlink" title="声卡"></a>声卡</h4><p>Windows平板用的声卡一般都是<code>alc5640</code>，对于新版内核来说也是这样，有驱动没固件没配置文件。</p><ul><li>固件可以直接用<a href="https://github.com/Asus-T100/firmware" target="_blank" rel="noopener">华硕T100的固件</a>，添加到<code>/lib/firmware/intel/</code>目录下面。</li><li>配置文件用<a href="https://github.com/plbossart/UCM/tree/master/bytcr-rt5640" target="_blank" rel="noopener">这份UCM</a>，需要复制到<code>/usr/share/alsa/ucm/bytcr-rt5640/</code>目录下面。</li><li>另外还需要用<code>alsa</code>的工具来配置默认输出。</li></ul><p>linuxium用<a href="http://linuxiumcomau.blogspot.com/2017/10/fixing-broken-hdmi-audio.html" target="_blank" rel="noopener">这些方法</a>弄好了Intel计算棒的HDMI音频输出，同样道理也可以弄好普通声卡输出。</p><p>首先查看有哪些音频设备：</p><pre><code>$ aplay -l**** PLAYBACK 硬體裝置清單 ****card 0: Audio [Intel HDMI/DP LPE Audio], device 0: HdmiLpeAudio [Intel HDMI/DP LPE Audio]子设备: 1/1子设备 #0: subdevice #0card 0: Audio [Intel HDMI/DP LPE Audio], device 1: HdmiLpeAudio [Intel HDMI/DP LPE Audio]子设备: 1/1子设备 #0: subdevice #0card 1: bytcrrt5640 [bytcr-rt5640], device 0: 1 []子设备: 1/1子设备 #0: subdevice #0card 1: bytcrrt5640 [bytcr-rt5640], device 1: Deep-Buffer Audio (*) []子设备: 1/1子设备 #0: subdevice #0</code></pre><p>可见<code>card 1</code>那里有两个<code>bytcr-rt5640</code>设备。试着用<code>card1,device0</code>来播放测试音频：</p><pre><code>$ aplay -D plughw:1,0 /usr/share/sounds/alsa/Front_Left.wav正在播放 WAVE &#39;/usr/share/sounds/alsa/Front_Left.wav&#39; : Signed 16 bit Little Endian, 频率48000Hz， Mono</code></pre><p>不出意外可以听到扬声器说出“front left”这句话来。</p><p>然后我们就要修改<code>/etc/pulse/default.pa</code>来设置默认音频设备了。找到加载<code>module-alsa-sink</code>这一行，取消注释，并加上<code>device=hw:1,0</code></p><pre><code>load-module module-alsa-sink device=hw:1,0</code></pre><p>然后把下面一段的“Automatically load driver modules”的那几行都注释掉。</p><p>重启，就可以有声音了。然而只是扬声器有效，耳机并不行，想必是ucm文件没有这份配置。</p><p>一些踩坑记录：</p><ul><li>如果没有固件，则声卡不能成功初始化</li><li>如果没有ucm文件，则dmesg中会不断刷屏说“byt-rt5640 byt-rt5640: ASoC: CPU DAI baytrail-pcm-audio not registered”</li><li>如果没有修改<code>/etc/pulse/default.pa</code>，那么在登录之前就有声音，进桌面就没声音。</li></ul><h4 id="电池"><a href="#电池" class="headerlink" title="电池"></a>电池</h4><p>平板用的电源管理芯片一般是<code>AXP288</code>，它能输出多路直流电源并管理锂电池，通过I2C接口来配置和读取信息。在老板内核里面没有axp288驱动，于是Icenowy大神就写了一个systemd来生成一个<a href="https://github.com/Icenowy/axpd" target="_blank" rel="noopener">测试电源</a>，并利用<code>i2cget</code>来读取AXP288的寄存器，从而得到电量、是否充电之类的信息。</p><p>新版内核就有AXP288驱动了，在不少平板上都可以愉快使用，但是在我之前收的一块拆机主板上电量读取总是为0。翻<a href="http://download.bbs.ickey.cn/201707/cfe88ee7ef01eed7a4586ce340165da0.pdf" target="_blank" rel="noopener">手册</a>发现，电量输出有两个可能的寄存器，一个是<code>0xB9</code>，一个是<code>0xE4</code>，前者通过电流积分来算容量，后者则根据电压来估计容量，一般情况下读前者就行了。Linux驱动中读电量的fuel_gauge_get_property()函数读取的是<a href="https://elixir.bootlin.com/linux/v4.17/source/drivers/power/supply/axp288_fuel_gauge.c#L500" target="_blank" rel="noopener">前面的那个寄存器</a>寄存器，而这块板子读出来就是0，只能读后面的寄存器。于是修改如下：</p><pre><code>@@ -498,7 +498,7 @@             val-&gt;intval = 0;         break;     case POWER_SUPPLY_PROP_CAPACITY:-        ret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);+        ret = fuel_gauge_reg_readb(info, AXP288_FG_OCV_CAP_REG);         if (ret &lt; 0)             goto fuel_gauge_read_err;</code></pre><p>这些情况在拆机主板上可能比较常见，因为长时间没电池可能导致AXP288的计数器出了问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ubuntu-tablet/battery.jpeg" alt="battery" title="">                </div>                <div class="image-caption">battery</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几百块钱的Windows寨板一般都是这样的配置：CPU是Intel的Baytrail z3735f，或者Cherrytrail z8300/z8350，都是不到2GHz的四核凌动x86，而后者的核显性能数倍于前者（虽然性能都不高，但还是属于吊打树莓派的那种）。内存一般是2GB，而z83xx可以上4GB，只是性能会有所降低。闪存一般是32GB的emmc flash，聊胜于无。外设方面就是触屏WiFi蓝牙SD卡USB云云。它们一般跑着win10或者win+Android双系统。&lt;/p&gt;
&lt;p&gt;对于树莓派一类玩家而言这些寨板吸引人的地方在于，价格便宜！x86的性能强！主频高内存大！WiFi！屏幕！然而虽然是x86的机器，它们并不能直接安装Ubuntu一类系统，原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位UEFI，因为32位的Windows占用空间小一些&lt;/li&gt;
&lt;li&gt;驱动非常不齐全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以没经过处理的&lt;code&gt;Ubuntu-1404&lt;/code&gt;为例，64位镜像因为机子UEFI是32位的而无法启动，32位镜像没有EFI启动文件也启动不了。强行给32位镜像补上EFI文件则可以顺利安装，然而电池、SD卡、触屏、WiFi、声卡、屏幕调光、按键、陀螺仪、摄像头之类的驱动统统没有，只有USB能用。。。&lt;/p&gt;
&lt;p&gt;要解决这两个问题势必要经过一些折腾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="baytrail" scheme="http://yoursite.com/tags/baytrail/"/>
    
  </entry>
  
  <entry>
    <title>bcmf[3] 与固件交互：bcdc和sdpcm</title>
    <link href="http://yoursite.com/bcmf3/"/>
    <id>http://yoursite.com/bcmf3/</id>
    <published>2018-04-30T12:56:56.000Z</published>
    <updated>2019-04-27T15:29:13.156Z</updated>
    
    <content type="html"><![CDATA[<p>与固件交互时，数据包往下传到SDIO网卡之前，还需要对它进行两层包装，简单说：<code>IP协议栈</code>数据包包装为<code>bdc</code>数据包，<code>控制命令</code>则包装为<code>cdc</code>数据包；bdc、cdc在Linux中统称为bcdc；bcdc再进一步包装为<code>sdpcm</code>数据包，进而通过SDIO发送给网卡。而博通只有SDIO的网卡才多包一层sdpcm，USB、PCIE接口的网卡都没有这样做。</p><p>Linux、nuttx、WICED它们在sdpcm这一层都用了一个线程，专门包装发送、接收解析这些sdpcm数据包。单线程+中断的模型未必不可以，但是若接收数据包时处于SDIO中断上下文，而接收的时候也得利用SDIO的中断去收数据，这就是自己嵌套自己的不愉快的事情了。于是在RTOS上，该线程便使用信号量去指示是否有事情发生，在Linux上则直接使用work queue去处理这种事情。</p><a id="more"></a><h3 id="bcdc层"><a href="#bcdc层" class="headerlink" title="bcdc层"></a>bcdc层</h3><p><code>cdc</code>用于发送、接收命令，比如查询固件版本号、查询设置MAC地址、开关连接WiFi、注册事件等等；这些功能一般都调用ioctl去执行，属于<code>带外数据</code>；<br><code>bdc</code>上面则直接接的是IP协议栈，上层就是socket的read、write，属于<code>带内数据</code>；</p><h4 id="cdc协议"><a href="#cdc协议" class="headerlink" title="cdc协议"></a>cdc协议</h4><p>控制命令分为<code>ioctl</code>和<code>iovar</code>两种；二者都带有cdc头部，其数据结构如下：</p><pre><code>struct bcmf_cdc_header {    uint32_t cmd;    /* 命令编号 */    uint32_t len;    /* 命令长度 */    uint32_t flags;  /* 标志位 */    uint32_t status; /* 返回状态 */};</code></pre><p>发送ioctl，将命令编号填入cmd字段，cdc头之后紧接着数据。</p><ul><li>linux里的cmd编号以<code>BRCMF_C_</code>为前缀，见<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h" target="_blank" rel="noopener">fwil.h</a></li><li>nuttx和WICED的cmd宏定义命名都是一样的，以<code>WLC_</code>为前缀。nuttx见drivers/wireless/ieee80211/ <strong>bcmf_ioctl.h</strong>第723行之后，WICED则在WICED/WWD/include/ <strong>wwd_wlioctl.h</strong>第899行之后。</li></ul><p>iovar是cmd为<code>WLC_SET_VAR</code>或<code>WLC_GET_VAR</code>的ioctl，cdc头之后跟着一个字符串，然后再跟着数据。这些字符串，nuttx和WICED都将其定义为一大堆以<code>IOVAR_STR_</code>开头的宏定义；而Linux则是直接写的字符串，散落在<a href="https://elixir.bootlin.com/linux/v4.13.3/ident/brcmf_fil_iovar_data_get" target="_blank" rel="noopener">cfg80211.c、common.c等文件里面</a>。</p><h4 id="bdc协议"><a href="#bdc协议" class="headerlink" title="bdc协议"></a>bdc协议</h4><p>bdc头只有四个字节：</p><pre><code>struct bcmf_bdc_header {  uint8_t flags;       /* bdc标志位 */  uint8_t priority;    /* 优先级 */  uint8_t flags2;      /* 网卡模式 */  uint8_t data_offset; /* bdc头部之后跳过的4字节个数 */};</code></pre><ul><li>flags字段填<code>0x20</code>是bdc协议的标志位</li><li>优先级其实不用管</li><li>flags2是网卡此时工作模式，有station、access point、P2P这三种取值；正常情况下连WiFi就是station，开热点就是access point。</li><li>data_offset这个字段说的是<strong>4字节的倍数</strong>。之所以是“4”据说是因为bdc头部长度为4，为了考虑扩展和对齐，bdc头后面会跳过data_offset个bdc头大小的数据</li></ul><p>bdc层还包装了<code>事件帧</code>，共有<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h#L32" target="_blank" rel="noopener">一百多个事件</a>，包括扫描到WiFi、路由器的授权信号、接入点的游走（roaming）等等；这些事件就是之前用cdc注册的事件，却交给bdc去处理。。。</p><h3 id="sdpcm数据结构"><a href="#sdpcm数据结构" class="headerlink" title="sdpcm数据结构"></a>sdpcm数据结构</h3><p>在bcdc包前面补上一个sdpcm头即可。对于这个头，Linux中有一段这样的注释<em>（横屏看）</em>：</p><pre><code>/*** brcmfmac sdio bus specific header* This is the lowest layer header wrapped on the packets transmitted between* host and WiFi dongle which contains information needed for SDIO core and* firmware** It consists of 3 parts: hardware header, hardware extension header and* software header* hardware header (frame tag) - 4 bytes* Byte 0~1: Frame length* Byte 2~3: Checksum, bit-wise inverse of frame length* hardware extension header - 8 bytes* Tx glom mode only, N/A for Rx or normal Tx* Byte 0~1: Packet length excluding hw frame tag* Byte 2: Reserved* Byte 3: Frame flags, bit 0: last frame indication* Byte 4~5: Reserved* Byte 6~7: Tail padding length* software header - 8 bytes* Byte 0: Rx/Tx sequence number* Byte 1: 4 MSB Channel number, 4 LSB arbitrary flag* Byte 2: Length of next data frame, reserved for Tx* Byte 3: Data offset* Byte 4: Flow control bits, reserved for Tx* Byte 5: Maximum Sequence number allowed by firmware for Tx, N/A for Tx packet* Byte 6~7: Reserved*/</code></pre><p>Linux里填充sdpcm头时就是一个个字节地数的。。。详见<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L1443" target="_blank" rel="noopener">brcmf_sdio_hdpack()</a>。正常发送bdc、cdc时候并不需要“hardware extension header”，所以就是两部分：4字节的大小和8字节的software header。</p><p>在WICED中将这翻译为如下的数据结构：</p><pre><code>typedef struct{    uint8_t sequence;    uint8_t channel_and_flags;    uint8_t next_length;    uint8_t header_length;    uint8_t wireless_flow_control;    uint8_t bus_data_credit;    uint8_t _reserved[2];} sdpcm_sw_header_t;typedef struct{    uint16_t           frametag[2];    sdpcm_sw_header_t  sw_header;} sdpcm_header_t;typedef struct{    wwd_buffer_header_t    buffer_header;    sdpcm_header_t         sdpcm_header;} sdpcm_common_header_t;</code></pre><p>可以看到WICED跟Linux一样将sdpcm头拆成两部分：4字节的大小和8字节的software header。不过WICED自己添加了一个wwd_buffer_header_t，这是WICED自己的头，发送之前会去掉。随后，它定义了cdc、bdc的专用数据头：</p><pre><code>typedef struct{    sdpcm_common_header_t  common;    sdpcm_cdc_header_t     cdc_header;} sdpcm_control_header_t;typedef struct{    sdpcm_common_header_t  common;    uint8_t                _padding[2];    sdpcm_bdc_header_t     bdc_header;} sdpcm_data_header_t;</code></pre><p>可见它认为bdc数据头是要多加两个字节的padding的。</p><p>nuttx则更简单：</p><pre><code>struct bcmf_sdpcm_header {    uint16_t size;    uint16_t checksum;    uint8_t  sequence;    uint8_t  channel;    uint8_t  next_length;    uint8_t  data_offset;    uint8_t  flow_control;    uint8_t  credit;    uint16_t padding;};</code></pre><p>注意，nuttx的padding还是属于前面software header的最后的两字节，而且它发送bdc、cdc都用这个头，不像WICED发送bdc时候又再多补了两字节的padding。不过BCM芯片返回的bdc数据包的sdpcm头的确比cdc的sdpcm头多两个字节；但是只要数据段寻址时候用的是header_length（data_offset）字段，而不是简单粗暴地用sizeof，就不会出问题。</p><p>以nuttx的数据结构为例，header里的字段如下：</p><ul><li><code>size</code>，这个包的长度，包含sdpcm头。</li><li><code>checksum</code>，size逐位取反。。。</li><li><code>sequence</code>，每发一个包时候递增1；每发一个包，芯片都会返回一个包，它们sequence编号相同。</li><li><code>channel</code>，有control、data、event三种通道，其中event代表了异步事件，就是之前用cdc注册的一百多种事件之一。</li><li><code>next_length</code>，在三份代码里面都直接置零而不去利用；或许说明BCM一开始设计这个头的时候，考虑将多个bdc、cdc包聚合（aggregate）为一个sdpcm包，有点类似A-MSDU和A-MPDU的想法，但是后来就直接简单地一个sdpcm包里只放一个bcdc包了。</li><li><code>data_offset</code>，也可以解释为这个头部的长度。</li><li><code>flow_control</code>，没用</li><li><code>credit</code>，解释为max sequence，上面的<code>sequence</code>字段不能超过它。BCM芯片每返回一个包就更新一次credit。</li><li><code>padding</code>，置零。（WICED里发送bdc包时候后面会在此基础上另外多增加两字节的padding。。。）</li></ul><h3 id="分层实现"><a href="#分层实现" class="headerlink" title="分层实现"></a>分层实现</h3><ul><li>nuttx严格分层了：drivers/wireless/ieee80211/目录下的<strong>bcmf_cdc.c、bcmf_bdc.c、bcmf_sdpcm.c</strong></li><li>Linux中bdc、cdc集中为drivers/net/wireless/broadcom/brcm80211/brcmfmac/ <a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c" target="_blank" rel="noopener">bcdc.c</a>，sdpcm则是<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c" target="_blank" rel="noopener">sdio.c</a></li><li>WICED将bcdc、sdpcm都搅在一起：WICED/WWD/internal/ <strong>wwd_sdpcm.c</strong></li></ul><p>bcdc层跟sdpcm层的接口，三份代码都无一例外使用了<strong>函数指针</strong>。如果说Linux里是为了兼顾PCIE和USB接口的网卡的话，nuttx和WICED估计就是单纯地依葫芦画瓢吧。。。</p><h4 id="零拷贝缓冲区"><a href="#零拷贝缓冲区" class="headerlink" title="零拷贝缓冲区"></a>零拷贝缓冲区</h4><p>发送的数据都要写入驱动的buffer。驱动中的子层每一层都会对它进行包装——添加一个头部。如果不涉及数据的切分，为了避免重复性的拷贝，最好的方法是这些子层分别引用同一个buffer的不同部分。显然，最底层需要最大的缓冲区。</p><p>因此，无论是nuttx还是wiced，它们发送数据的话都是“<strong>向驱动申请缓冲区，填写缓冲区，最后发送</strong>”这种模式，而不是自己随便申请一个缓冲区，写完之后丢给驱动。</p><p>本层模块向低一层模块申请一块包含本层头部与数据区的buffer，然后给高一层的模块返回减去本层头部的那部分。最底层模块才真正malloc一个缓冲区。</p><h4 id="nuttx"><a href="#nuttx" class="headerlink" title="nuttx"></a>nuttx</h4><p>发送数据或命令都是阻塞的，bdc、cdc都会等到收到回应才返回。</p><p>发送接收线程：bcmf_sdio.c里有一个<code>bcmf_sdio_thread()</code>，循环地等待一个名叫<code>thread_signal</code>的信号量，发送数据、接收数据，都会发出信号量从而触发其行动。</p><p>以发送一个iovar命令为例。cdc层给调用sdpcm层发送<code>thread_signal</code>之后，等待一个名为<code>control_timeout</code>的信号量；由中断程序触发bcmf_sdio_thread()去接收数据后，该线程发出<code>control_timeout</code>信号量，进而促使cdc层返回数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf3/cdc.jpeg" alt="cdc" title="">                </div>                <div class="image-caption">cdc</div>            </figure></p><h4 id="WICED"><a href="#WICED" class="headerlink" title="WICED"></a>WICED</h4><p>WICED的线程是wwd_thread.c:<code>wwd_thread_func()</code>，整个流程处理方式与nuttx很类似，只是做了一些冗余的操作。</p><ul><li>添加了WICED自己的头部，发送之前去掉。</li><li>申请了sdpcm缓冲区之后填数据，数据前面为对齐而留白，然而最终发送之前又将整段数据往前面搬了。。。或许它是为了防止别的进程使用的内存中该缓冲区之前的数据的越界而践踏我的数据。</li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux用的是work queue机制，由worker_thread内核线程统一执行。brcmfmac的workqueue是<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L3622" target="_blank" rel="noopener">brcmf_sdio_dataworker()</a>。除此之外整个流程其实相当相似，只是考虑到多核、编译器优化、乱序、大小字节序等情况而用了一些晦涩的接口，加了不少锁以及一些存储屏障，并且将函数分的更细致了，到处都是层层调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与固件交互时，数据包往下传到SDIO网卡之前，还需要对它进行两层包装，简单说：&lt;code&gt;IP协议栈&lt;/code&gt;数据包包装为&lt;code&gt;bdc&lt;/code&gt;数据包，&lt;code&gt;控制命令&lt;/code&gt;则包装为&lt;code&gt;cdc&lt;/code&gt;数据包；bdc、cdc在Linux中统称为bcdc；bcdc再进一步包装为&lt;code&gt;sdpcm&lt;/code&gt;数据包，进而通过SDIO发送给网卡。而博通只有SDIO的网卡才多包一层sdpcm，USB、PCIE接口的网卡都没有这样做。&lt;/p&gt;
&lt;p&gt;Linux、nuttx、WICED它们在sdpcm这一层都用了一个线程，专门包装发送、接收解析这些sdpcm数据包。单线程+中断的模型未必不可以，但是若接收数据包时处于SDIO中断上下文，而接收的时候也得利用SDIO的中断去收数据，这就是自己嵌套自己的不愉快的事情了。于是在RTOS上，该线程便使用信号量去指示是否有事情发生，在Linux上则直接使用work queue去处理这种事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="bcm-wifi" scheme="http://yoursite.com/tags/bcm-wifi/"/>
    
  </entry>
  
  <entry>
    <title>bcmf[2] 驱动：初始化</title>
    <link href="http://yoursite.com/bcmf2/"/>
    <id>http://yoursite.com/bcmf2/</id>
    <published>2018-04-27T03:57:26.000Z</published>
    <updated>2019-04-27T15:32:31.933Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结BCM43438的初始化流程，初始化成功的标志是连上WiFi。</p><p>参考WICED SDK、NuttX，以及Linux的源码，它们的流程略有不同。Linux的驱动面面俱到；WICED的驱动虽只针对物联网设备，却写得相当冗杂；nuttx的驱动则相当简洁恰好能用。</p><ul><li>WICED可从<a href="https://community.cypress.com/community/wiced-wifi" target="_blank" rel="noopener">Cypress官网</a>上下载，注册个账号就好了。这份软件架构简直是<strong>一切以WICED为中心</strong>，有bootloader、dct（Device Configuration Table）、OTA（Over The Air）等自创的元素，如果用它支持的平台如stm32的话，那可以非常迅速地出成果，然而如果要移植到别的CPU架构的话它并不太友好。。</li><li>NuttX可从<a href="https://bitbucket.org/nuttx/nuttx/src/master/" target="_blank" rel="noopener">bitbucket/nuttx</a>上git clone一份，或者从<a href="http://sourceforge.net/projects/nuttx/files/" target="_blank" rel="noopener">SourceForge</a>下载代码包。SourceForge上面的7.24及以前的驱动有问题，我在bitbucket上提交了<a href="https://bitbucket.org/nuttx/nuttx/commits/144e335b85fed8852e259f80181d6914b93dc659" target="_blank" rel="noopener">这份commit</a>。bitbucket在墙内访问相当不稳定。。</li><li>Linux可以直接访问<a href="https://elixir.bootlin.com/linux/v4.13.3/source" target="_blank" rel="noopener">Bootlin的Linux Cross Reference</a>。在Linux内核中，博通<strong>SDIO接口的</strong>网卡驱动是<code>brcmfmac</code>，归类到<code>brcm80211</code>，这是博通官方提供的驱动，需要non-free的固件。<code>b43</code>的驱动是社区通过一些逆向工程实现的，只支持老版的PCIe网卡。。</li></ul><p>初始化过程纯粹就是面向过程的代码，因此以下通过罗列它们的流程来进行分析。</p><p>固件这玩意儿想必是厂商喜闻乐见的东西——在你编写的程序中安插黑盒子，而你又无可奈何。</p><a id="more"></a><h3 id="SDIO卡简述"><a href="#SDIO卡简述" class="headerlink" title="SDIO卡简述"></a>SDIO卡简述</h3><p>BCM43438是一个SDIO卡。<code>SDIO卡</code>跟<code>SD卡</code>虽然都用了SDIO接口，但是二者不可混为一谈。</p><ul><li>SD卡是SD memory card，驱动通用；</li><li>SDIO卡就是为IO而准备的，为此使用了<a href="https://www.sdcard.org/developers/overview/sdio/sdio_spec/Simplified_SDIO_Card_Spec.pdf" target="_blank" rel="noopener">扩展的SDIO规范</a>。</li><li>如果卡中既有存储，又有IO，则被称为combo卡。</li></ul><p>SDIO卡具有IO空间，通过<code>CMD52</code>和<code>CMD53</code>这两条的指令读写其中的数据：</p><ul><li>CMD52，单字节IO读写，数据只通过CMD引脚传输；</li><li>CMD53，多字节IO读写，数据通过DATA[3:0]传输，非常适合传输<strong>大批量数据</strong>；</li></ul><p>IO空间里有多个<code>Function</code>，一个Function就是一块独立的IO空间：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf2/sdio.jpeg" alt="sdio function" title="">                </div>                <div class="image-caption">sdio function</div>            </figure></p><ul><li>第0个Function叫<code>CIA（common IO area）</code>，其中包含了多个寄存器组，基本上只在初始化时候才会用到：<ul><li><strong>CCCR（Card Common Control Registers）</strong>，功能诸如开关其他Function、开关中断等等；</li><li><strong>FBR（Function Basic Registers）</strong>，其中有设置该Function的block size的寄存器，还有指向下面CIS区域的指针；</li><li><strong>CIS（Card Information Structure）</strong>，除了SDIO specification里面有介绍外，没找到其他资料，而且WICED和nuttx里代码里面也没有用到。。</li></ul></li><li>另外最多支持7个Function，里面的寄存器由厂商自己定义。BCM43438有两个Function：<ul><li>Function1叫<code>Backplane</code>，来源于<a href="https://bcm-v4.sipsolutions.net/Backplane/" target="_blank" rel="noopener">Sonics Silicon Backplane（SSB）</a>，是可以访问整个SOC的地址空间的总线。不过只有老版的网卡使用SSB总线，新版网卡（包括我们的BCM43438）<a href="https://www.kernel.org/doc/readme/drivers-bcma-README" target="_blank" rel="noopener">则使用AXI总线</a>，二者的接口并不同，只是名称沿用了下来。</li><li>Function2叫<code>WLAN</code>，与固件交互时候使用，传输控制命令以及数据。</li></ul></li></ul><p>IO空间的编号、寄存器地址编码到CMD52、CMD53命令中，从而进行读写操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf2/cmd5253.jpeg" alt="cmd52,53" title="">                </div>                <div class="image-caption">cmd52,53</div>            </figure></p><h3 id="BCM43438-bringup"><a href="#BCM43438-bringup" class="headerlink" title="BCM43438-bringup"></a>BCM43438-bringup</h3><p>博通家SDIO接口的网卡初始化流程比较通用，下面罗列出要做的事情，WICED、nuttx、Linux里的执行顺序略有不同，说明初始化流程并不是唯一的。</p><ul><li>Linux中涉及到的bcmfmac里的文件有:<strong>chip.c</strong>、<strong>sdio.c</strong>、<strong>firmware.c</strong></li><li>WICED里主要就是WICED/WWD/internal/bus_protocols/SDIO/ <strong>wwd_bus_protocol.c</strong></li><li>Nuttx则主要是drivers/wireless/ieee80211/ <strong>bcmf_sdio.c</strong></li></ul><h4 id="枚举SDIO卡"><a href="#枚举SDIO卡" class="headerlink" title="枚举SDIO卡"></a>枚举SDIO卡</h4><ul><li>WICED：WICED/platform/MCU/xxxxxxxx/WWD/WWD_SDIO.c: <strong>host_platform_sdio_enumerate()</strong>，是平台相关的部分；</li><li>Nuttx：drivers/wireless/ieee80211/mmc_sdio.c: <strong>sdio_probe()</strong>， 最终调用平台相关的代码；</li><li>Linux：在mmc层，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/mmc/core/core.c#L2477" target="_blank" rel="noopener">drivers/mmc/core/core.c:mmc_rescan_try_freq()</a>。mmc层的入口可以说是插卡时候的中断进程<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/mmc/core/slot-gpio.c#L33" target="_blank" rel="noopener">mmc_gpio_cd_irqt()</a>（它之前<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/mmc/core/slot-gpio.c#L142" target="_blank" rel="noopener">被request成threaded的irq</a>）。</li></ul><p>它们的流程都一样：</p><ul><li>发送<code>CMD5</code>，没回应就按照SD存储卡初始化流程走，若有回应则是SDIO卡；</li><li>发送<code>CMD3</code>，让卡返回一个自己生成的<strong>RCA(Relative Card Address)</strong>；</li><li>将刚才的RCA作为参数，发送<code>CMD7</code>，从而选中那张卡；</li></ul><h4 id="使能Function"><a href="#使能Function" class="headerlink" title="使能Function"></a>使能Function</h4><ul><li>WICED：WICED/WWD/internal/bus_protocols/SDIO/wwd_bus_protocol.c: <strong>wwd_bus_init()</strong></li><li>Nuttx：drivers/wireless/ieee80211/bcmf_sdio.c: <strong>bcmf_probe()和bcmf_businitialize()</strong></li><li>Linux：drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c: <a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c#L1038" target="_blank" rel="noopener">brcmf_sdiod_probe()</a>，被sdio_driver的probe函数调用。</li></ul><p>首先初始化Function0、1的寄存器。一部分通用寄存器在SDIO specification里讲述，其他的寄存器没有资料。</p><ul><li>使能Backplane即F1（写F0的CCCR_IOEN寄存器）。</li><li>设置4位总线宽度（写F0的CCCR_BICTL寄存器）。另外主机也要设置为4bit，并可以提高时钟速度。</li><li>设置各个Function的block size（写F0的CCCR_FNx_BLKSIZE0、1、2，每个Function各两个寄存器）。它都设为64了，虽然数据手册上说Function0的最大只有32。。。</li><li>使能Function1、2的中断（写F0的CCCR_INTEN寄存器）。</li><li>在Function1中，使能“ALP（Active Low-Power）”时钟（写F1的CHIPCLKCSR寄存器，BCM定义的）。</li></ul><p>使能了F1之后可以随时读F1的<code>0x18000000</code>地址处读到设备ID号，在Linux的brcmfmac的驱动中，该地址处的结构体为<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h#L24" target="_blank" rel="noopener">struct chipregs</a>，第一个元素是chipid。而WICED和nuttx的驱动里面没发现这种结构体——它们都用的是一大堆宏定义的寄存器地址。不同的模块chipid可见Linux内核的drivers/net/wireless/broadcom/brcm80211/include/ <a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h" target="_blank" rel="noopener">brcm_hw_ids.h</a>，其中BCM43438的ID是<strong>十进制的43430</strong>。</p><p><em>0x18000000这个地址在brcmfmac里被命名为<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/include/soc.h#L20" target="_blank" rel="noopener">SI_ENUM_BASE</a>，在老版SSB驱动里被命名为<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/ssb/ssb_regs.h#L12" target="_blank" rel="noopener">SSB_ENUM_BASE</a>。brcmfmac里SSB总线、AXI总线分别实现了，体现了bcm网卡内部总线的发展历史。。。</em></p><table><thead><tr><th style="text-align:left">总线</th><th style="text-align:left">chipid最高8位</th><th style="text-align:left">接口前缀</th><th style="text-align:left">头文件</th></tr></thead><tbody><tr><td style="text-align:left">SSB</td><td style="text-align:left">0</td><td style="text-align:left">brcmf_chip_sb_</td><td style="text-align:left"><a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/ssb/ssb_regs.h" target="_blank" rel="noopener">linux/ssb/ssb_regs.h</a></td></tr><tr><td style="text-align:left">AXI</td><td style="text-align:left">1</td><td style="text-align:left">brcmf_chip_ai_</td><td style="text-align:left"><a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/bcma/bcma_regs.h" target="_blank" rel="noopener">linux/bcma/bcma_regs.h</a></td></tr></tbody></table><h4 id="传输固件"><a href="#传输固件" class="headerlink" title="传输固件"></a>传输固件</h4><p>固件有三种：</p><ul><li>两三百kb的大固件</li><li>一两kb的nvram</li><li>几kb的clm blob，<strong>这不是必需品</strong></li></ul><p>在这个阶段首先传前两个固件。大固件从F1的RAM首地址开始放，nvram放在RAM末尾倒数4个字节之前，RAM最后4个字节是编码之后的nvram大小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf2/fwlayout.jpeg" alt="fwlayout" title="">                </div>                <div class="image-caption">fwlayout</div>            </figure></p><h5 id="nvram的配置"><a href="#nvram的配置" class="headerlink" title="nvram的配置"></a>nvram的配置</h5><p>nvram是一个字符串数组，目的在于调试时候设置一些参数，它们最终要烧写到BCM43438的OTP（One Time Programable）存储器里面的。BCM固件收到nvram之后会与OTP空间对比，同名的参数配置以OTP为准。因此实际操作中为了保持一些灵活性，大家都不会把nvram里面所有的东西都写入OTP里面。详细的参数设置可以参考Cypress的这份文档：<a href="http://www.cypress.com/file/298131/download" target="_blank" rel="noopener">AN214807</a>：OTP Programming and NVRAM Development in SDIO Mode。</p><ul><li>WICED：在<strong>platforms/XXXXXXXXXX/wifi_nvram_image.h</strong>中定义的数组。</li><li>NuttX：在configs目录下板级配置中定义的数组，如<strong>configs/photon/src/stm32_wlan_firmware.c</strong>。</li><li><p>Linux：通用固件<a href="https://github.com/kszaq/brcmfmac_sdio-firmware-aml/tree/master/firmware/brcm/nvram_ap6212a.txt" target="_blank" rel="noopener">nvram_ap6212a.txt</a></p><pre><code>  #AP6212A_NVRAM_V1.0.1_20160606  # 2.4 GHz, 20 MHz BW mode  # The following parameter values are just placeholders, need to be updated.  manfid=0x2d0  prodid=0x0726  vendid=0x14e4  devid=0x43e2  boardtype=0x0726  ...</code></pre></li></ul><p>其中需要留意的参数有：</p><ul><li><code>macaddr</code>，设置MAC地址。其实现在买到的AP6xxx模块的OTP里面都已经有这个参数了，除非直接订购的是BCM43438芯片。</li><li><code>xtalfreq</code>，设置晶振的频率，单位为kHz。有些板子用的是37.4M晶振，有些用的是26M晶振。<strong>一定要设对，否则后面PLL时钟起不来</strong>。</li></ul><p>需要特别注意的是，<strong>最终</strong>下载到芯片里的东西必然是WICED、nuttx里面的那种风格的数组，每一个<code>xxxx=xxxx</code>的字符串<strong>键值对之后都有一个0字符</strong>，而不是Linux的配置文件那种风格。Linux的nvram.txt是经过处理才下载的，详见drivers/net/wireless/broadcom/brcm80211/brcmfmac/ <a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c" target="_blank" rel="noopener">firmware.c</a>。它使用状态机进行词法分析，滤除注释，然后<strong>brcmf_fw_add_defaults()</strong>，添加0字符。</p><h5 id="下载固件之前"><a href="#下载固件之前" class="headerlink" title="下载固件之前"></a>下载固件之前</h5><p>首先需要disable芯片的Cores，包括Cortex M3的核，还有内存控制器的核。</p><p>另外BCM43438需要<strong>取消SRAM bank 3的remap</strong>。Linux写在drivers/net/wireless/broadcom/brcm80211/brcmfmac/ chip.c:<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c#L1196" target="_blank" rel="noopener">brcmf_chip_cm3_set_passive()</a>处；WICED则是WICED/WWD/internal/chips/xxxxx/ wwd_chip_specific_functions.c: <strong>wwd_chip_specific_socsram_init()</strong>。nuttx目前只是单纯在下载固件之前判断了一下。</p><h5 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h5><p>根据不同的ID可以选择不同的固件。</p><ul><li>Linux：在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L601" target="_blank" rel="noopener">brcmfmac/sdio.c</a>里定义一堆固件名称，从而可以在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c#L550" target="_blank" rel="noopener">brcmf_fw_get_firmwares()</a>处从文件系统里request_firmware。sdio.c中传入callback函数<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L3992" target="_blank" rel="noopener">brcmf_sdio_firmware_callback()</a>，随后brcmf_sdio_firmware_callback()，传输大固件以及nvram。</li><li>WICED：层层调用到WICED/WWD/internal/bus_protocols/ wwd_bus_common.c: <strong>download_resource()</strong>，然后使用 <em>host_platform_resource_read_direct()</em> 或者<em>host_platform_resource_read_<strong><strong>in</strong></strong>direct()</em>函数，从片内flash或者片外flash里面读取固件，然后<strong>wwd_bus_transfer_bytes()</strong>下载到BCM芯片内。因为WICED运行时的平台单一，所以它并不考虑通过不同ID号选择不同的固件。</li><li>nuttx：在drivers/wireless/ieee80211/bcmf_sdio.c: <strong>bcmf_chipinitialize()</strong>里通过ID号switch case一个芯片，随后drivers/wireless/ieee80211/bcmf_core.c: <strong>bcmf_core_upload_firmware()</strong>，然后<strong>bcmf_upload_binary()</strong>。目前nuttx的固件直接写为一个巨大的uint8_t数组。。。比如photon的固件，在configs/photon/src/ <strong>stm32_wlan_firmware.c</strong>里。</li></ul><h5 id="等待固件初始化时钟"><a href="#等待固件初始化时钟" class="headerlink" title="等待固件初始化时钟"></a>等待固件初始化时钟</h5><ul><li>Linux：brcmfmac/sdio.c:<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L752" target="_blank" rel="noopener">brcmf_sdio_htclk()</a>，有个循环；</li><li>WICED：WICED/WWD/internal/bus_protocols/SDIO/wwd_bus_protocol.c: <strong>wwd_bus_sdio_download_firmware()</strong>，下载了firmware和nvram之后有个循环；</li><li>NuttX：drivers/wireless/ieee80211/bcmf_sdio.c: <strong>bcmf_sdio_bus_sleep(false)</strong>，这有个循环。下完固件，设置中断的时候才调用它。</li></ul><p>做法就是循环读F1的CHIPCLKCSR寄存器的第7位，命名为High Throughput Clock Available。这一步经常会不过关，原因可能是：</p><ul><li>大固件不对，比方说将BCM43438-A0的固件下到了A1的芯片上面了。</li><li>nvram不对，可能直接将Linux的哪个txt下进去了，可能是xtalfreq不对，可能是别的东西。。。</li><li>板子问题，晶振不起振，等等。</li><li>等待的时间不够长，可能板子焊的不太好，要多等一会儿才能available。</li></ul><p>如果这一步过关了，说明这个固件或许可以用，后面或许就轻松了不少。。</p><h5 id="然后收尾"><a href="#然后收尾" class="headerlink" title="然后收尾"></a>然后收尾</h5><ul><li>使能F2、F2的中断</li><li>初始化save-restore功能。并不是所有固件都支持sr功能。<ul><li>WICED：WICED/WWD/internal/chips/xxxxx/ wwd_chip_specific_functions.c: <strong>wwd_chip_specific_init()</strong></li><li>Linux：brcmf_sdio_firmware_callback()之后<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L4063" target="_blank" rel="noopener">brcmf_sdio_sr_init()</a></li><li>Nuttx：我照着WICED的代码在bcmf_sdio.c里面添加了bcmf_sdio_sr_init()。之前虽然没有，但是据说也能用。。</li></ul></li></ul><h4 id="与固件交互进行初始化"><a href="#与固件交互进行初始化" class="headerlink" title="与固件交互进行初始化"></a>与固件交互进行初始化</h4><p>与固件交互，用的是Function2即WLAN，Linux、nuttx里将该功能注释为“frame transfer”。在Function2传输的数据要符合BCM定义的一套协议，分为两层：</p><ul><li>上层：bdc、cdc<ul><li>bdc用于传输数据包，接入IP协议栈的底部。</li><li>cdc用于传输控制命令，有ioctl和iovar之分。控制命令包括开关WiFi、查询或设置MAC地址等等。也可以说属于带外传输的范畴。</li></ul></li><li>下层：sdpcm，用于包装bdc、cdc。</li></ul><p>具体实现部分下一篇博客将讨论。这里仅讨论初始化阶段需要做的东西。</p><ul><li>Nuttx：drivers/wireless/ieee80211/<strong>bcmf_driver.c</strong></li><li>WICED：WICED/WWD/internal/<strong>wwd_management.c</strong></li><li>Linux：brcmfmac/<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c#L107" target="_blank" rel="noopener">brcmf_c_preinit_dcmds()</a>。之前在brcmfmac/sdio.c:<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L4086" target="_blank" rel="noopener">callback里调用brcmf_bus_started()</a>，然后层层调用到它。</li></ul><p>这阶段就是发送一些ioctl、iovar去查询一些信息，以及设置一些东西。<br><code>ioctl</code>是一些整数指令号，可以附带一些参数；<br><code>iovar</code>是字符串命令，也可以附带一些参数。</p><h5 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h5><ul><li>查询该固件的版本。发送名为<code>&quot;ver&quot;</code>的iovar，返回一个字符串。比方说它会返回”wl0: Jun 19 2016 22:40:09 version 7.45.45.17 (r644353) FWID 01-dbaba83”</li><li>查询MAC地址。发送名为<code>&quot;cur_etheraddr&quot;</code>的iovar，返回6字节的MAC地址（返回的buffer不一定只有6字节，其他的都没用）</li><li>关闭所谓的TX glomming：<code>&quot;bus:txglom&quot;</code>的iovar</li><li>开启APSTA模式：<code>&quot;apsta&quot;</code>的iovar</li><li>设置A-MPDU的参数。amsdu、ampdu的概念可参考<a href="http://www.cnblogs.com/aixin0813/p/3195664.html" target="_blank" rel="noopener">这篇博客</a>。<code>ampdu_</code>为前缀的一系列iovar</li><li>设置国家和地区：<code>&quot;country&quot;</code>的iovar</li><li><strong>注册事件</strong>，使用<code>&quot;event_msgs&quot;</code>，参数是一个一百多位的位图，每一位代表一个事件，置一则代表主机打算相应这个事件。Linux在brcmfmac/fweh.h里定义为<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h#L32" target="_blank" rel="noopener">enum brcmf_fweh_event_code</a>，nuttx在bcmf_ioctl.h里定义为<strong>enum wl_event_num_t</strong>，WICED在WICED/WWD/include/wwd_events.h里定义为<strong>enum wwd_event_num_t</strong>。</li><li><strong>WiFi up</strong>，发送<code>WLC_UP</code>的ioctl，编号是2。ifup这个命令在Linux和nuttx里都有，if的全称应该是interface，比方说<code>ifup wlan0</code>；它底层就是发送了WLC_UP指令。</li></ul><p>另外需要注意<code>roaming（漫游）</code>的问题。bcmf固件有自动漫游功能，通过<code>&quot;roam_off&quot;</code>的iovar来开关。不应该关闭；否则，如果现在连接的AP并不是信号最强的话，每隔一段时间就会自行断开当前连接，给上层一个<code>DEAUTH</code>事件，然后连接信号最强者。Linux的brcmfmac驱动有个参数名叫<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c#L72" target="_blank" rel="noopener">brcmf_roamoff</a>，默认不roam_off。而nuttx则默认roam_off，上层却缺乏断线重连的逻辑，因此相关的初始化应该去掉。</p><h5 id="连接WiFi"><a href="#连接WiFi" class="headerlink" title="连接WiFi"></a>连接WiFi</h5><p>就是join一个Access Point（AP），一个AP一般有一个名字叫SSID，以及密码（当然也有隐藏的WiFi和开放的WiFi）。对于Linux和nuttx来说决定要连接WiFi的是应用程序而不是内核，需要调用ioctl来陷入内核从而进行操作。</p><ul><li>Linux：drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c#L1951" target="_blank" rel="noopener">brcmf_cfg80211_connect()</a></li><li>WICED：WICED/WWD/internal/<strong>wwd_wifi_join()</strong></li><li>NuttX：drivers/wireless/ieee80211/bcmf_driver.c:<strong>bcmf_wl_set_ssid()</strong>，它在ioctl(SIOCSIWESSID)时候被调用。</li></ul><p>流程如下：</p><ul><li>设置wireless mode为infra或adhoc，使用ioclt为<code>WLC_SET_INFRA</code>（WICED &amp; nuttx）或<code>BRCMF_C_SET_INFRA</code>（Linux）；</li><li>设置WPA授权方式的版本号，使用iovar<code>&quot;bsscfg:sup_wpa&quot;</code>；</li><li>设置授权方式，如WPA、WPA2。使用ioctl为<code>WLC_SET_WPA_AUTH</code>；</li><li>设置加密方式，如WEP、TKIP、CCMP（其核心算法是AES）等。使用ioctl为<code>WLC_SET_WSEC</code>和<code>WLC_SET_AUTH</code>；</li><li>设置WiFi密码，使用ioctl为<code>WLC_SET_WSEC_PMK</code>，参数就是密码字符串；</li><li>设置WiFi名，使用ioctl为<code>WLC_SET_SSID</code>（WICED &amp; nuttx）或<code>BRCMF_C_SET_SSID</code>（Linux），参数是WiFi SSID字符串。</li><li>随后就等待路由器的授权信息。。。</li></ul><p>连接上路由器，并不代表获得了IP地址。IP可以静态设置，也可以动态分配（DHCP）。但这些已经不属于MAC层的范畴了，正常的操作系统都会配备相应的应用程序来完成这些功能。</p><h5 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h5><p>有时候BCM芯片会发一个很大的东西回来，是其内核寄存器的dump。Linux内核中对此命名为<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L339" target="_blank" rel="noopener">struct brcmf_trap_info</a>，并输出log信息。WICED和nuttx都假装没有这种问题。dump之后WiFi芯片将不会响应任何命令。。。</p><p>这一般说明固件不配套，可能是发送了不合法的命令，也可能发了几条命令之后片子发现自己不能执行下去了，然后就dump，卡死。这时就要多试几个固件了。。。</p><h3 id="板子试验"><a href="#板子试验" class="headerlink" title="板子试验"></a>板子试验</h3><p>只讨论WICED和nuttx的板子。</p><ul><li>WICED开发板选用<code>BCM94343WWCD1-EVB</code>，主控是STM32F411VEH6，WiFi芯片是BCM4343W。板子带有一片SPI flash，BCM的固件就存放在那里。</li><li>Redbear提供了<a href="https://github.com/redbear/WICED-SDK" target="_blank" rel="noopener">WICED 6.1的补丁</a>，直接复制到SDK目录下面就行了。</li><li>Photon和Redbear都可以跑nuttx，Redbear需要稍作移植，主要是填充BCM43438的固件，毕竟43362和43438的驱动相当通用。</li></ul><h4 id="跑WICED"><a href="#跑WICED" class="headerlink" title="跑WICED"></a>跑WICED</h4><p>安装了WICED SDK之后，在<code>43xxx_Wi-Fi</code>目录下面make。这份SDK提供了make程序从而不必使用系统的make程序。可以直接make它自带的例程，例程都放在apps目录的子目录下面：</p><pre><code>apps/├── demo│   ├── aliyun_mns│   ├── apollo│   ├── appliance│   └── ...├── snip│   ├── scan│   ├── https_server│   ├── tcp_client│   └── ...├── test│   └── ...├── waf│   ├── bootloader│   └── ...└── wwd    ├── ping    ├── scan    └── ...</code></pre><p>make后接的target这样设置：<code>&lt;例程目录&gt;.&lt;例程名称&gt;-&lt;板子名称&gt;</code>。比方说要跑apps/snip/scan里面的例程：</p><ul><li>./make snip.scan-BCM94343WWCD1 # 对于BCM94343W开发板</li><li>./make snip.scan-RB_DUO # 打了补丁之后可用的Redbear开发板</li></ul><p>值得一试的例程除了scan，还有tcp_client，后者需要在主机上跑一个Python程序，板子连接主机之后不断发送hello数据。</p><h4 id="跑nuttx"><a href="#跑nuttx" class="headerlink" title="跑nuttx"></a>跑nuttx</h4><p>目前nuttx有photon开发板的现成配置。nuttx的编译方式是，内核和apps目录分开，在内核目录下面用<code>tools/configure.sh</code>来配置板子。比方说photon：</p><ul><li>./tools/configure.sh photon/wlan</li></ul><p>然后更改.config文件中的<code>CONFIG_NSH_WAPI_SSID</code>为WiFi名，<code>CONFIG_NSH_WAPI_PASSPHRASE</code>为WiFi密码。其他按照默认配置，编译出来的nuttx.bin可用直接用photon的bootloader进行烧写、启动。</p><ul><li>sudo dfu-util -d 2b04:d006 -a 0 -s 0x08020000 -D nuttx.bin</li></ul><p>复位之后，板子会自动连上WiFi。在路由器中找板子的ip地址，然后通过telnet来访问板子的nsh。</p><pre><code>$ telnet 192.168.2.102Trying 192.168.2.102...Connected to 192.168.2.102.Escape character is &#39;^]&#39;NuttShell (NSH) NuttX-7.24nsh&gt;</code></pre><p>对于Redbear，则可以依葫芦画瓢地增加板级配置文件，也能达到这个效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf2/photon.jpeg" alt="photon" title="">                </div>                <div class="image-caption">photon</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结BCM43438的初始化流程，初始化成功的标志是连上WiFi。&lt;/p&gt;
&lt;p&gt;参考WICED SDK、NuttX，以及Linux的源码，它们的流程略有不同。Linux的驱动面面俱到；WICED的驱动虽只针对物联网设备，却写得相当冗杂；nuttx的驱动则相当简洁恰好能用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WICED可从&lt;a href=&quot;https://community.cypress.com/community/wiced-wifi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cypress官网&lt;/a&gt;上下载，注册个账号就好了。这份软件架构简直是&lt;strong&gt;一切以WICED为中心&lt;/strong&gt;，有bootloader、dct（Device Configuration Table）、OTA（Over The Air）等自创的元素，如果用它支持的平台如stm32的话，那可以非常迅速地出成果，然而如果要移植到别的CPU架构的话它并不太友好。。&lt;/li&gt;
&lt;li&gt;NuttX可从&lt;a href=&quot;https://bitbucket.org/nuttx/nuttx/src/master/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bitbucket/nuttx&lt;/a&gt;上git clone一份，或者从&lt;a href=&quot;http://sourceforge.net/projects/nuttx/files/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SourceForge&lt;/a&gt;下载代码包。SourceForge上面的7.24及以前的驱动有问题，我在bitbucket上提交了&lt;a href=&quot;https://bitbucket.org/nuttx/nuttx/commits/144e335b85fed8852e259f80181d6914b93dc659&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这份commit&lt;/a&gt;。bitbucket在墙内访问相当不稳定。。&lt;/li&gt;
&lt;li&gt;Linux可以直接访问&lt;a href=&quot;https://elixir.bootlin.com/linux/v4.13.3/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bootlin的Linux Cross Reference&lt;/a&gt;。在Linux内核中，博通&lt;strong&gt;SDIO接口的&lt;/strong&gt;网卡驱动是&lt;code&gt;brcmfmac&lt;/code&gt;，归类到&lt;code&gt;brcm80211&lt;/code&gt;，这是博通官方提供的驱动，需要non-free的固件。&lt;code&gt;b43&lt;/code&gt;的驱动是社区通过一些逆向工程实现的，只支持老版的PCIe网卡。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始化过程纯粹就是面向过程的代码，因此以下通过罗列它们的流程来进行分析。&lt;/p&gt;
&lt;p&gt;固件这玩意儿想必是厂商喜闻乐见的东西——在你编写的程序中安插黑盒子，而你又无可奈何。&lt;/p&gt;
    
    </summary>
    
    
      <category term="bcm-wifi" scheme="http://yoursite.com/tags/bcm-wifi/"/>
    
  </entry>
  
  <entry>
    <title>bcmf[1] SDIO-WiFi-phy选型</title>
    <link href="http://yoursite.com/bcmf1/"/>
    <id>http://yoursite.com/bcmf1/</id>
    <published>2018-04-26T02:58:05.000Z</published>
    <updated>2019-04-27T19:00:04.450Z</updated>
    
    <content type="html"><![CDATA[<p>物联网硬件联网的方案很多，其中WiFi相当诱人。如果说传感器分布于野外，那WiFi不一定适用，但是在室内就不同了：WiFi技术成熟，带宽大，而且很多家庭都有的路由器，就是现成的网关，功能性的东西可以迅速实现（当然也要考虑别的质量属性，比如安全性等等）。</p><p>最近正在给pulpino移植AP6212的驱动，pulpino又跑不了Linux，AP6xxx的非Linux资料又几乎没有，参考手册又没有，就一堆数据手册；碰壁许久，总算有点感想和发现，遂记录几篇文章：</p><ul><li>一、<a href="#目录">芯片选型</a></li><li>二、<a href="/bcmf2/">初始化BCM43438</a></li><li>三、<a href="/bcmf3/">与固件交互：bdc和cdc</a></li></ul><p>下面讨论的都是<strong>低端的网卡</strong>，相对于集群、数据中心啥的而言的话是，非常非常低端的东西；做大工程不行，但是做一些比较hack的东西还是绰绰有余的。</p><a id="more"></a><h3 id="WiFi模块闲谈"><a href="#WiFi模块闲谈" class="headerlink" title="WiFi模块闲谈"></a>WiFi模块闲谈</h3><ul><li>对于很多传感器、执行机构而言，它的数据量少，而且主控的性能或许不高，这样的话用各种串口WiFi模块就行了，就如满世界的ESP8266那样。ESP8266如果定制开发的话，据说可以达到1Mbps级别的数据传输速度。</li><li>如果想要高集成度，那完全可以选择各种带WiFi的单片机，比如CC3000、ESP32。ESP32纸面性能相当不错，而且提供SDK，完全可以单芯片做出产品了。这种东西也不少，例如Particle推出的一些<a href="https://www.particle.io/mesh" target="_blank" rel="noopener">物联网节点</a>就有用ESP32这款同时带WiFi和蓝牙的SOC。</li><li>如果想要有很高的IO性能，那直接选择路由器芯片，这是网关级别的片子了，比如当年的路由器神U：MT7620A，以及后续的MT7688等等，跑个OpenWRT，甚至可以实现一些稍微有点计算量的东西。</li></ul><p>但是以上的选型并不能满足所有需求。比方说要做WiFi摄像头，那SOC上就应该有CSI一类的接口，然而上述东西都没有；在mt7620上面带USB摄像头又很不伦不类。于是就有人干脆用新塘的ARM9片子加上USB WiFi模块来做摄像头；<a href="http://www.banana-pi.org/d1.html" target="_blank" rel="noopener">Banana Pi也有一款摄像头开发板</a>用的ARM9芯片，还得用OTG转接线接USB WiFi网卡才能联网。裸机开发ARM9+摄像头+USB+WiFi并不简单，所以它们上面跑着Linux，然而跑Linux性能又不好，做人机交互这种低速处理还好，想多做点控制又没那么多外设，只能外面再接一个单片机。总感觉这方案很快餐式。</p><p>如果在DSP、Cortex M7之类的片子上好好优化了图像处理算法，又苦于没有大带宽的WiFi片子，那么搭在机器人、无人机上面就总觉得缺了点东西；用现成的叉叉派、叉叉开发板，性能够强大了也有WiFi了，但是总归还是个学生作品。想当年调试RM小车的场景，一组一辆小车，小车上带个电脑跑图像处理，然后大家上场调试时候划定势力范围，每辆小车上都捆了一台路由器。。。想做稍微精细一点的东西，若只像做产品那样到处搞外包找厂家合作，去搞运作，那就很不geek了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/crazyflie1.jpg" alt="crazyflie" title="">                </div>                <div class="image-caption">crazyflie</div>            </figure></p><p>总有不少有计算、IO需求的但是又有功耗、成本之类限制的应用场景，非得用MCU主控+WiFi <strong>phy</strong>的方式去解决，而不仅仅是串口透传模块。这种模块接在PCIE、SDIO一类的总线上面，主控上实现MAC层及以上的协议栈。应用层的接口一般是socket、read、write一类的东西，数据传输速度远高于串口WiFi模块。我曾经用ESP8266来尝试传输图片，固件没有定制过，单片机上精心编写的使用DMA的代码，速度稳稳地2kb每秒；也尝试过88w8782的板子，每秒传输字节数可以上兆，商家给了keil的例程，其中关键的WiFi驱动部分就是一个闭源的lib。。很是无奈。</p><p>我能接触到的消费电子产品中用的SDIO WiFi模块，暂时基本上就两家：不是Broadcom（现在这些低端网卡属于Cypress了）就是Realtek。这两家货物相当的大众化。</p><ul><li><a href="https://wikidevi.com/wiki/Broadcom" target="_blank" rel="noopener">Broadcom的选型</a></li><li><a href="https://wikidevi.com/wiki/Realtek" target="_blank" rel="noopener">Realtek的选型</a></li></ul><h4 id="Broadcom家的SDIO-WiFi"><a href="#Broadcom家的SDIO-WiFi" class="headerlink" title="Broadcom家的SDIO-WiFi"></a>Broadcom家的SDIO-WiFi</h4><p>带WiFi的叉叉派、叉叉开发板，很多都用AMPAK的模块。这些模块都用博通家的片子。<br>AP6212模块用的真多：</p><ul><li><a href="http://www.t-firefly.com/index.php/doc/product/info/id/129.html" target="_blank" rel="noopener">Fireprime</a>用AP6212</li><li><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_NEO_Air" target="_blank" rel="noopener">带WiFi的Nano Pi</a>用AP6212</li><li><a href="http://www.orangepi.org/OrangePiZeroPlus2/" target="_blank" rel="noopener">带WiFi的Orange Pi</a>用AP6212</li><li><a href="http://www.banana-pi.org/m3.html" target="_blank" rel="noopener">带WiFi的Banana Pi</a>也用的AP6212</li><li><a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/" target="_blank" rel="noopener">树莓派三代B版</a>用的<strong>BCM43438</strong>芯片</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/orangepi.jpeg" alt="nanopi](bcmf1/nanopi.jpeg)![orangepi" title="">                </div>                <div class="image-caption">nanopi](bcmf1/nanopi.jpeg)![orangepi</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/bananapi.jpeg" alt="bananapi" title="">                </div>                <div class="image-caption">bananapi</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/ap6xxx.jpeg" alt="ap6xxx" title="">                </div>                <div class="image-caption">ap6xxx</div>            </figure><p>AP6xxx模块引脚基本兼容，可集成的功能有2.4G WiFi、5G WiFi、蓝牙、FM收音机、GPS等等，功能不同，价格由几块钱到二三十块钱不等。有一份<a href="https://wenku.baidu.com/view/cca5080089eb172dec63b752.html" target="_blank" rel="noopener">神奇的选型表</a>，以及<a href="https://wenku.baidu.com/view/eeb823f19b89680203d82532.html" target="_blank" rel="noopener">兼容性设计</a>；这两份文档貌似只能在百度文库上才能搜到。AP6212十几块钱一个，同时支持2.4G WiFi、蓝牙、收音机，用的芯片是<a href="http://www.cypress.com/file/298076/download" target="_blank" rel="noopener">BCM43438</a>，上面列举的几款开发板的WiFi其实都是一回事。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/ap6212.jpeg" alt="ap6212" title="">                </div>                <div class="image-caption">ap6212</div>            </figure></p><p>稍高端的板子用AP6335，有双频WiFi；也有一些开发板或许出于成本考虑用了AP6181，它只有WiFi，还只是2.4G的，据说野火即将推出的I.MX RT1052开发板用的就是这个。</p><p>瑞芯微也推出过基于博通家WiFi的模块，比如<a href="http://www.haoyuelectronics.com/service/RK3066/Datasheet/RK903%20datasheet_V1.2_20120309.pdf" target="_blank" rel="noopener">RK903</a>基于BCM4330，RK901基于BCM4329等。</p><h4 id="Realtek家的SDIO-WiFi"><a href="#Realtek家的SDIO-WiFi" class="headerlink" title="Realtek家的SDIO-WiFi"></a>Realtek家的SDIO-WiFi</h4><p>值得一提的是这<strong>著名的RTL8723BS</strong>，一款WiFi+蓝牙模块。著名之处在于，它被广泛用于Win8、Win10或安卓系统的山寨平板电脑、电视盒子、电视棒里面，有人专门回收这些废旧板子，拆机带板拿去卖，rtl8723bs模块一块多一个。。。它应用太广泛了，以至于很多世界各地的极客们花费心思去实现其Linux驱动，这份驱动最终<a href="https://github.com/anthonywong/rtl8723bs" target="_blank" rel="noopener">merge到4.12版本内核的staging目录下面了</a>。</p><p><a href="https://licheepizero.us/" target="_blank" rel="noopener">荔枝派zero</a>就弄了这么一个WiFi模块。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/licheepizero.jpeg" alt="licheepizero" title="">                </div>                <div class="image-caption">licheepizero</div>            </figure></p><p>Realtek的SDIO模块基本上只提供Windows的驱动，Linux驱动还比较野生。我有一个电视棒刷了Arch Linux，用内核的RTL8723BS驱动，上网速度相当的慢。。。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/rtl8723bs.jpeg" alt="rtl8723bs" title="">                </div>                <div class="image-caption">rtl8723bs</div>            </figure></p><h4 id="其他片子"><a href="#其他片子" class="headerlink" title="其他片子"></a>其他片子</h4><p>也有小众的片子，如全志出的<a href="https://linux-sunxi.org/images/8/8f/XR819_Datasheet_V1.0-EN.pdf" target="_blank" rel="noopener">XR819</a>，有些电视盒子就用了它，社区支持也不多，有些玩家刷机之后就没WiFi了，而且也难以恢复。有几块nanopi、orangepi的板子也用了这款片子。</p><h4 id="物联网开发板用的SDIO-WiFi"><a href="#物联网开发板用的SDIO-WiFi" class="headerlink" title="物联网开发板用的SDIO-WiFi"></a>物联网开发板用的SDIO-WiFi</h4><p>舍得在单片机开发板上面用SDIO的WiFi的板子不多。Particle支持的两款板子：<a href="https://docs.particle.io/guide/getting-started/intro/photon/" target="_blank" rel="noopener">Photon</a>和<a href="https://github.com/redbear/Duo" target="_blank" rel="noopener">Redbear-Duo</a>就是其中二员，它们的主控都是STM32F205RGY6。</p><ul><li>Photon有P0和P1两款，WiFi用的都是BCM43362，只有WiFi功能；它直接将STM32和BCM封在一个模块里面了，而且这个模块原理图不公开。</li><li>Redbear Duo就直接用AP6212模块了，喜闻乐见。它有WiFi+蓝牙两个功能所以叫Duo。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/photon.jpeg" alt="photon" title="">                </div>                <div class="image-caption">photon</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/redbear.jpeg" alt="redbear" title="">                </div>                <div class="image-caption">redbear</div>            </figure><p>此外Cypress也出了不少官方WICED开发板，价格不菲。它用WICED SDK，内有MCU上的底层驱动源码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/wiced.jpeg" alt="wiced" title="">                </div>                <div class="image-caption">wiced</div>            </figure></p><blockquote><p>综上所述，AP6212——或者说BCM43438这款芯片——相当流行，资料仿佛也很多，我们就选它啦！</p></blockquote><h3 id="BCM43430系列的片子"><a href="#BCM43430系列的片子" class="headerlink" title="BCM43430系列的片子"></a>BCM43430系列的片子</h3><p>Broadcom的物联网业务被Cypress收购了，这些低端SDIO WiFi phy芯片归Cypress所有了。严格说BCM43438应该叫CYW43438，但是买到的片子上面刻着的还是BCM。。。</p><ul><li>从SDIO上读到的ID为十进制的43430的芯片有两个：BCM4343W和BCM43438，前者带有WiFi、蓝牙、FM收音三个功能，后者比前者少了FM收音的功能。<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h#L43" target="_blank" rel="noopener">Linux内核里面有一堆BCM芯片的ID号</a></li><li>相传，BCM43438有两个版本：A0和A1；Cypress收购之后推出的43438都是A1版本的了。A0版本的芯片上刻着P10，A1上刻着P11；巨坑的是，<strong>两个版本的芯片固件亲测不可以通用</strong>。。。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/bcm43438.jpeg" alt="bcm43438" title="">                </div>                <div class="image-caption">bcm43438</div>            </figure></li></ul><p>43430系列的片子，WiFi功能只由SDIO或SPI接口来访问，蓝牙功能只能由串口访问。我们仅讨论SDIO接口的WiFi功能。</p><h4 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h4><ul><li>数据传输：只需要连上SDIO：四根DATA线、一根CMD线、一根CK。</li><li>中断：SDIO协议中，SDIO卡的DATA1这根线可以作为中断线，这称为<code>带内中断（in-band）</code>；而BCM芯片自己定义了一个<code>带外中断（out-of-band，OOB)</code>，即<code>WL_HOST_WAKE</code>这个引脚，可以将中断信号remap到这个引脚上。然而Redbear和Photon的板子都没用这个引脚，说明不用OOB也没问题。</li><li>复位：<code>WL_REG_ON</code>这个引脚控制片内电源的开关，可以行使复位的功能。AP6xxx模块没有引出RESET引脚。。。</li></ul><p>因此，如果用AP6xxx模块的话，外围电路可以设计的非常简单，SDIO引脚、复位，加上时钟、电源、天线，这就完事了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/bcmf1/ap6212sch.jpeg" alt="ap6212sch" title="">                </div>                <div class="image-caption">ap6212sch</div>            </figure></p><h4 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h4><p>WiFi芯片的固件是厂家打死都不会开源的东西。WICED SDK里面开源了驱动，但是BCM固件则就是一些bin文件，而且不同版本的WICED的固件都有所不同。总而言之它需要三部分：</p><ul><li>一个两三百kb的<code>大固件</code>；</li><li>一个数kb的<code>clm blob</code>。有些老版本的固件不需要这个；</li><li>一个1kb左右的<code>nvram</code>，是一个字符串数组，用于配置基本信息；</li></ul><p>我在github以及不同版本的WICED里面找到了n多套固件，罗列如下：</p><ul><li><a href="https://github.com/kszaq/brcmfmac_sdio-firmware-aml/tree/master/firmware/brcm" target="_blank" rel="noopener">Linux下的通用固件</a>，43430的有三个；</li><li><a href="https://github.com/RPi-Distro/firmware-nonfree/tree/master/brcm" target="_blank" rel="noopener">树莓派定制的固件</a>；</li><li><a href="https://github.com/redbear/Duo/tree/master/firmware/wifi" target="_blank" rel="noopener">Redbear定制的固件</a>；</li><li><a href="https://github.com/winmecs/Bcm43438-firmware" target="_blank" rel="noopener">一个野生的固件</a>；</li><li>WICED SDK的<code>resources/firmware/43438/</code>目录下面有两套固件；</li></ul><p>并不是每个大固件都需要配上一个clm blob，但是有些资源里面有。值得一提的是，WICED里面的43438和4343W的大固件其实是完全一样的，说明仅就WiFi而言二者是完全一致的。。</p><h4 id="已公开的软件资源"><a href="#已公开的软件资源" class="headerlink" title="已公开的软件资源"></a>已公开的软件资源</h4><ul><li>Linux内核下的驱动<br>在Linux下，Broadcom开源的网卡驱动有两类：<code>brcmfmac</code>和<code>brcmsmac</code>，前者是“brcm Full MAC”，后者是“brcm Soft MAC”。Soft MAC说的是比较老的PCIE接口的网卡，需要软件实现整个MAC层；Full MAC说的是SDIO、USB接口的网卡，网卡实现了MAC。详见<a href="https://wiki.archlinux.org/index.php/Broadcom_wireless" target="_blank" rel="noopener">Arch wiki上的描述</a>以及<a href="http://linuxwireless.sipsolutions.net/en/users/Drivers/brcm80211/index.html" target="_blank" rel="noopener">Linux Wireless</a>里面对bcm驱动的描述。</li><li><a href="https://wireless.wiki.kernel.org/en/users/drivers/brcm80211" target="_blank" rel="noopener">Linux wireless wiki</a>收集了Linux无线模块驱动的一些基本信息。</li><li><a href="https://community.cypress.com/community/wiced-wifi" target="_blank" rel="noopener">WICED SDK</a>里面的驱动，功能全面，但是冗余度高。</li><li><a href="http://sourceforge.net/projects/nuttx/files/" target="_blank" rel="noopener">NuttX</a>里的代码。前两年<a href="http://nuttx.org/Documentation/NuttX.html#stm32f205x" target="_blank" rel="noopener">有黑客将nuttx移植到Photon上了</a>，附带了移植了brcmfmac的驱动。我提交了<a href="https://bitbucket.org/nuttx/nuttx/commits/144e335b85fed8852e259f80181d6914b93dc659" target="_blank" rel="noopener">这份commit</a>，修改了一些原有的bug。</li></ul><p>开源的东西貌似很多，但是只有长篇大论的代码而并没有任何说明文档，可以看出厂家在小心翼翼地让大众保持在知其然而不知其所以然的状态。只能说都是套路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物联网硬件联网的方案很多，其中WiFi相当诱人。如果说传感器分布于野外，那WiFi不一定适用，但是在室内就不同了：WiFi技术成熟，带宽大，而且很多家庭都有的路由器，就是现成的网关，功能性的东西可以迅速实现（当然也要考虑别的质量属性，比如安全性等等）。&lt;/p&gt;
&lt;p&gt;最近正在给pulpino移植AP6212的驱动，pulpino又跑不了Linux，AP6xxx的非Linux资料又几乎没有，参考手册又没有，就一堆数据手册；碰壁许久，总算有点感想和发现，遂记录几篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、&lt;a href=&quot;#目录&quot;&gt;芯片选型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二、&lt;a href=&quot;/bcmf2/&quot;&gt;初始化BCM43438&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;三、&lt;a href=&quot;/bcmf3/&quot;&gt;与固件交互：bdc和cdc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面讨论的都是&lt;strong&gt;低端的网卡&lt;/strong&gt;，相对于集群、数据中心啥的而言的话是，非常非常低端的东西；做大工程不行，但是做一些比较hack的东西还是绰绰有余的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="bcm-wifi" scheme="http://yoursite.com/tags/bcm-wifi/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[6] 构建rootfs</title>
    <link href="http://yoursite.com/ucpc6/"/>
    <id>http://yoursite.com/ucpc6/</id>
    <published>2018-03-13T12:57:51.000Z</published>
    <updated>2019-04-27T15:18:21.252Z</updated>
    
    <content type="html"><![CDATA[<p>简单来讲，内核、文件系统、应用程序，三者构成一个完整可用的系统。发行版之间不同之处不在于内核啥的，而在于rootfs——它的一套系统工具；比如包管理，Ubuntu上面就是apt-get，Arch上面就是pacman，OpenWRT上面就是opkg，等等。</p><p>内核可以放在文件系统里面，如果bootloader支持文件系统的话就可以找到内核在哪里，树莓派啥的就是这样的风格。而不少嵌入式设备bootloader不会关注文件系统的事情，它只需有引导、更新内核的能力即可。所以不少板子直接将内核放在nand flash的某一个或几个block里面，如用uboot，则只需要<code>nand read xxxx xxxx xxxx</code>就可以了。而对于ucpc这块板子来说，内核在片内flash里面就地运行，文件系统完全可以放在别的地方。</p><p>更完整的系统还需要包括各种运行时库（如C库）和链接器等，而且编译器是其中的重要软件，再不济也得有个解释器（比如Sylixos里面有个C解释器）。不过编译器在嵌入式设备上面几乎无用，即使性能强如智能手机也一样，没多少人愿意在板子上做native编译，毕竟上位机工具功能才全面。而对于ucpc这块板子来说，因为现成的arm-uclinuxeabi工具链都不能编译动态链接库，所以所有应用程序都是静态链接的，于是rootfs里面就连C库和链接器都不需要了。</p><p><em>（手机请横屏看代码）</em><br><a id="more"></a></p><h3 id="helloworld例子"><a href="#helloworld例子" class="headerlink" title="helloworld例子"></a>helloworld例子</h3><p>稍微大一点的操作系统，即使是nuttx、rtthread等；它们都有所谓的根文件系统rootfs，*nix的思想是任何东西都通过rootfs来访问：一切皆为文件，文件都在同一个<code>命名空间</code>里；某物需先接入命名空间才能被识别、使用，这个过程叫<code>挂载（mount）</code>。nuttx的rootfs可以空无一物——直接用VFS作为rootfs，因为它的应用程序可以是<strong>内核中內建的</strong>；而Linux的rootfs必须依赖于某个物理存在的文件系统，任何一个物理存在的文件系统都行，因为Linux<strong>内核中并不会內建任何工具</strong>，这也可以说体现了Linux的哲学吧：提供机制而不是策略。</p><p>ucpc上试过的根文件系统类型有：initramfs、romfs、nfs、yaffs。如果将SD卡、USB大容量设备等的驱动编译进内核的话，那么fatfs、ext4等等的东西也可以作为根文件系统，不然的话就只能手动mount然后chroot，才能说是所谓根文件系统了。</p><p>现成的initramfs可以从<a href="https://elinux.org/File:Stm32_mini_rootfs.cpio.bz2" target="_blank" rel="noopener">eLinux</a>这里下载，里面是busybox的一堆命令以及/etc下面的简单的配置文件，如果不想自己配置一遍busybox编译的话可以直接解压这份rootfs来用。</p><p>下面我们做一个最最简单的rootfs作为例子，让内核启动之后打印hello world！</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void){    while (1) {        fprintf(stdout, &quot;hello world!\n&quot;);        fflush(stdout);        sleep(10);    }    return 0;}</code></pre><p>死循环是为了防止init进程退出而kernel panic。之所以要fflush这么麻烦，是因为它不flush的话还真的没输出。。。</p><p>编译生成hello可执行文件。arm-uclinuxeabi工具链详见前面的文章：</p><pre><code>$ arm-uclinuxeabi-gcc -o hello hello.c -march=armv7-m -mthumb$ lshello  hello.c  hello.gdb$</code></pre><p>然后将hello放到rootfs里面，重命名为linuxrc，这个名字是因为设备树里面的参数<code>init=linuxrc</code>：</p><pre><code>$ mkdir rootfs$ cp hello rootfs/linuxrc$</code></pre><p>另外rootfs里面还需要有<code>/dev</code>文件夹，并且手动生成console节点；因为没有写mount函数，所以刚刚挂载这个rootfs时候是没有/dev和设备节点的，而init进程的<code>stdin</code>、<code>stdout</code>、<code>stderr</code>都是/dev/console，没有的话printf就会没地方输出。</p><pre><code>$ mkdir rootfs/dev$ sudo mknod rootfs/dev/console c 5 1$ find rootfs  #然后看看rootfs里面有啥东西rootfs/rootfs/devrootfs/dev/consolerootfs/linuxrc$</code></pre><h4 id="initramfs"><a href="#initramfs" class="headerlink" title="initramfs"></a>initramfs</h4><p>Linux发行版最开始启动时挂载的rootfs一般是构建在内存中的，它里面的初始化脚本最终会chroot到真正的位于磁盘上的rootfs。实用的ramfs有两个：initrd和initramfs，相当相似，但是initrd是一个RAM disk，访问disk的话要经过block io，从而拉低了性能；而initramfs直接就是一个fs了，绕开了block io以及不必要的cache从而性能稍高，有助于提高开机速度。这两个机制都有保留，取决于传入内核的rootfs是一个镜像还是一个cpio，参考<a href="https://www.cnblogs.com/lcw/archive/2013/06/27/3159401.html" target="_blank" rel="noopener">这篇博客</a>。</p><p>initramfs内核默认就支持。我们直接将cpio编译进内核中，配置选项<code>CONFIG_INITRAMFS_SOURCE</code>是一个字符串，它就是经过打包的cpio根文件系统的路径。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc6/initramfs.jpeg" alt="initramfs" title="">                </div>                <div class="image-caption">initramfs</div>            </figure></p><p>将上面做好的rootfs<strong>打包为cpio</strong>。这需要在rootfs目录下面进行：</p><pre><code>$ cd rootfsrootfs$ find . | cpio -o -H newc &gt; ../hello.cpiorootfs$ </code></pre><p>注意，cpio如果打包的是initramfs的话，必须<code>-H newc</code>。</p><p>设备树里面，确认bootargs这样设置：<strong>root=/dev/ram rdinit=linuxrc</strong>。<br>然后编译、下载到板子上，就可以启动到hello world啦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc6/helloworld.jpeg" alt="helloworld" title="">                </div>                <div class="image-caption">helloworld</div>            </figure></p><h4 id="romfs"><a href="#romfs" class="headerlink" title="romfs"></a>romfs</h4><p>romfs需要用<code>genromfs</code>工具，它由包管理安装。<code>-d</code>指明打包的目录，<code>-f</code>指明输出的文件：</p><pre><code>$ genromfs -f hello.bin -d ./rootfs/$ </code></pre><p>将这个romfs烧写到一个地址那里，不妨烧到<strong>0x081E0000</strong>处吧，它是stm32f429ii片内flash的最后一个block。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc6/romfs1.jpeg" alt="romfs1" title="">                </div>                <div class="image-caption">romfs1</div>            </figure><p>romfs需要开启以下的选项：<br>首先是ROMFS：</p><pre><code>-&gt; File systems  -&gt; Miscellaneous filesystems    -&gt; ROM file system support</code></pre><p>然后是<code>CONFIG_MTD_BLOCK</code>：</p><pre><code>-&gt; Device Drivers  -&gt; Memory Technology Device (MTD) support    -&gt; Caching block device access to MTD devices</code></pre><p>然后是<code>CONFIG_MTD_ROM</code>：</p><pre><code>-&gt; Device Drivers  -&gt; Memory Technology Device (MTD) support    -&gt; RAM/ROM/Flash chip drivers      -&gt; Support for ROM chips in bus mapping</code></pre><p>还有<code>CONFIG_MTD_UCLINUX</code></p><pre><code>-&gt; Device Drivers  -&gt; Memory Technology Device (MTD) support    -&gt; Mapping drivers for chip access      -&gt; Generic uClinux RAM/ROM filesystem support</code></pre><p>上面最后一个选项编译的是<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/mtd/maps/uclinux.c" target="_blank" rel="noopener">drivers/mtd/maps/uclinux.c</a>，负责将ROM mapped的东西注册为mtd设备。而开启了CONFIG_MTD_BLOCK之后它就能生成/dev/mtdblock0、1、2等等了。</p><p>uclinux.c里面有一个参数：</p><pre><code class="c">static unsigned long physaddr = -1;module_param(physaddr, ulong, S_IRUGO);</code></pre><p>这是romfs的地址。上面我们将它烧到了0x081E0000了，因此在设备树里面要将其传入bootargs中。</p><p>启动之后可以看到如下的printk：</p><pre><code>[    0.720000] uclinux[mtd]: probe address=0x81e0000 size=0x3000[    0.720000] Creating 1 MTD partitions on &quot;rom&quot;:[    0.730000] 0x000000000000-0x000000003000 : &quot;ROMfs&quot;</code></pre><p>/dev/mtdblock的编号是怎么来的呢？这取决于注册该设备的<strong>时间顺序</strong>，因此如果注册了很多个mtd块设备的话，要从头到尾翻看内核log，找<strong>“Creating x MTD partitions on xxx”</strong>这段话，数数它是第几个注册的。这里是第0个注册的，因此0x081e0000处的romfs镜像对应的就是/dev/mtdlock0。需要写入bootargs中。</p><p>因此内核参数如下：<strong>root=/dev/mtdblock0 init=/linuxrc uclinux.physaddr=0x081E0000</strong></p><p>内核启动之后会有如下的printk：</p><pre><code>[    0.310000] romfs: ROMFS MTD (C) 2007 Red Hat, Inc....[    0.720000] uclinux[mtd]: probe address=0x81e0000 size=0x3000[    0.720000] Creating 1 MTD partitions on &quot;rom&quot;:[    0.730000] 0x000000000000-0x000000003000 : &quot;ROMfs&quot;...[    0.780000] VFS: Mounted root (romfs filesystem) readonly on device 31:0.</code></pre><p>接下来就是hello world了！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc6/romfs2.jpeg" alt="romfs1" title="">                </div>                <div class="image-caption">romfs1</div>            </figure></p><h4 id="yaffs"><a href="#yaffs" class="headerlink" title="yaffs"></a>yaffs</h4><p><a href="/ucpc5/#6、yaffs2">上一篇文章</a>里讲述了给内核打补丁、添加nand flash分区、添加nand flash驱动、改动bootargs等工序。整个rootfs可以通过nfs来复制到nand上，从而启动该hello world。当然如果要量产的话，还是要老老实实在bootloader里面添加yaffs的逻辑，添加USB之类的驱动，从而可以快速烧写程序。</p><h4 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h4><p><a href="/ucpc5/#1、网络">上一篇文章</a>里讲述了如何搭建nfs、挂载nfs、内核配置、改动bootargs等工序。值得一提的是，如果主机用WiFi的话，nfs传输速度有可能会极慢，有些时候甚至都挂不上nfs，还是连网线大法好。</p><h3 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h3><p>busybox是嵌入式Linux的瑞士军刀，它内置了诸如bash、ls、mount、cat、vi等等一大堆命令行工具，基本上编译通过之后丢进去就能跑通一个小系统了！</p><p>从官网上下载的源码无需任何修改，只需要配置就行了：</p><ul><li>它有<code>CONFIG_NOMMU</code>的配置</li><li><code>CONFIG_CROSS_COMPILER_PREFIX</code>设置交叉编译工具链，需要用<strong>应用程序</strong>的工具arm-uclinuxeabi-，而不是裸机程序的工具arm-none-eabi-</li><li><code>CONFIG_EXTRA_CFLAGS</code>设置为<code>-march=armv7-m -mthumb</code>，使之生成thumb2的代码</li><li><code>CONFIG_PREFIX</code>设置安装目录</li><li><strong>其他命令按需设置</strong></li><li><p>编译时，需要SKIP_STRIP：</p><p>  $ make SKIP_STRIP=y<br>  $ make install</p></li></ul><p>现在这个rootfs有/bin、/usr、/sbin这些目录了。还需要添加一些目录，比方说/etc、/sys、/proc等。规范的根目录布局参考<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank" rel="noopener">“Filesystem Hierarchy Standard”</a>规范。</p><p>/etc目录放的是一堆配置文件，可以参考busybox源码下面的<code>examples/bootfloppy/etc</code>目录。其中：</p><p><code>/etc/fstab</code>是启动时候要挂载的文件系统。可以添加dev、sysfs的东西：</p><pre><code>proc  /proc proc defaults 0 0sysfs /sys sysfs defaults 0 0tmpfs /tmp tmpfs defaults 0 0</code></pre><p><code>/etc/inittab</code>是init进程维护的东西，可以这样设置：</p><pre><code>::sysinit:/etc/init.d/rcSttyS0::respawn:/bin/shtty0::respawn:/bin/sh</code></pre><p>其中后面两行表示在ttyS0和tty0上面开启shell终端，而且这些终端退出之后可以重新登录，即respawn。另外第一行表示，它会执行<code>/etc/init.d/rcS</code>脚本。</p><p><code>/etc/init.d/rcS</code>就是一个bash脚本，可以做任何想做的事情，比方说挂载各种各样的文件系统、加载内核驱动模块等等：</p><pre><code>#! /bin/sh# see also /etc/fstab/bin/mount -a# load other drivers/sbin/modprobe usb-storage/sbin/modprobe sd_mod# and many other things....</code></pre><p>内核模块放在<code>/lib/modules/4.13.3/</code>目录下面。编译内核之后，将<code>INSTALL_MOD_PATH</code>环境变量设置为那个目录，然后通过<strong>make modules_install</strong>来安装模块。</p><pre><code>$ INSTALL_MOD_PATH=某某某 make modules_install</code></pre><p>至此，就构建了一个带有shell的rootfs啦。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc6/busybox.jpeg" alt="busybox" title="">                </div>                <div class="image-caption">busybox</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来讲，内核、文件系统、应用程序，三者构成一个完整可用的系统。发行版之间不同之处不在于内核啥的，而在于rootfs——它的一套系统工具；比如包管理，Ubuntu上面就是apt-get，Arch上面就是pacman，OpenWRT上面就是opkg，等等。&lt;/p&gt;
&lt;p&gt;内核可以放在文件系统里面，如果bootloader支持文件系统的话就可以找到内核在哪里，树莓派啥的就是这样的风格。而不少嵌入式设备bootloader不会关注文件系统的事情，它只需有引导、更新内核的能力即可。所以不少板子直接将内核放在nand flash的某一个或几个block里面，如用uboot，则只需要&lt;code&gt;nand read xxxx xxxx xxxx&lt;/code&gt;就可以了。而对于ucpc这块板子来说，内核在片内flash里面就地运行，文件系统完全可以放在别的地方。&lt;/p&gt;
&lt;p&gt;更完整的系统还需要包括各种运行时库（如C库）和链接器等，而且编译器是其中的重要软件，再不济也得有个解释器（比如Sylixos里面有个C解释器）。不过编译器在嵌入式设备上面几乎无用，即使性能强如智能手机也一样，没多少人愿意在板子上做native编译，毕竟上位机工具功能才全面。而对于ucpc这块板子来说，因为现成的arm-uclinuxeabi工具链都不能编译动态链接库，所以所有应用程序都是静态链接的，于是rootfs里面就连C库和链接器都不需要了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（手机请横屏看代码）&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[5] Linux设备驱动配置</title>
    <link href="http://yoursite.com/ucpc5/"/>
    <id>http://yoursite.com/ucpc5/</id>
    <published>2018-03-07T01:21:49.000Z</published>
    <updated>2019-04-27T15:20:06.959Z</updated>
    
    <content type="html"><![CDATA[<p>uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，<strong>就地运行</strong>（XIP，全称execute in place）。</p><p>需要使能的功能有：网络、显示、USB、SD卡、摄像头、yaffs。这些功能全部开启的话，内核大小将为4MB以上，而片内flash只有2MB，不模块化的话只能跑在SDRAM上，这回导致性能低下，所以调通设备驱动之后应该进行模块化，将关键部分编译进内核，内核塞进片内flash，从而提高性能。</p><p>以下将只描述它们如何配置，而不涉及具体驱动的软件架构。</p><ul><li>配置之前，应该设置环境变量：<strong>ARCH=arm CROSS_COMPILE=arm-none-eabi-</strong>（其他编译工具链设置也类似），不然的话会按照host的架构去配置。</li><li>配置时一般用<code>make menuconfig</code>，如果装了qt的话还可以用<code>make xconfig</code>；后者可以用鼠标操作，全屏的话看到的信息量更多。</li><li>搜索某一个配置时，不用加<code>CONFIG_</code>前缀，而且不用管大小写。</li><li>某一个配置没有显示出来，是因为它依赖的配置还没有使能；这时就要耐着性子去一个个翻找。。。</li></ul><p><em>（手机请横屏看代码）</em><br><a id="more"></a></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Linux内核实现了相当完整而庞大的网络协议栈——对于单片机来说实在过于庞大；并且，协议栈部分是必须编译进内核而不能模块化的，因此这一块只能放置于片内flash中；而且，只在defconfig的基础上使能网络的话，内核就超过了2MB了。因此在调通板子上的驱动之前，内核都只能在SDRAM上面就地运行。。参考前文bootloader的配置。</p><p>下面实现基本的网络功能：获取IP、跑通nfs。诸如DNS之类的暂时不弄。</p><h4 id="上位机搭建NFS服务器"><a href="#上位机搭建NFS服务器" class="headerlink" title="上位机搭建NFS服务器"></a>上位机搭建NFS服务器</h4><pre><code class="bash">$ sudo apt install nfs-common</code></pre><p>我的nfs目录是<code>/home/hyq/nfs</code>，为此修改配置文件<code>/etc/exports</code>：</p><pre><code>/home/hyq/nfs *(rw,sync,no_root_squash,no_subtree_check)</code></pre><p>重启服务以生效：</p><pre><code class="bash">$ sudo /etc/init.d/nfs-kernel-server restart</code></pre><h5 id="一件小事："><a href="#一件小事：" class="headerlink" title="一件小事："></a>一件小事：</h5><p>有时候调板子是这种情况：电脑要连校园网WiFi来科学上网（因为有ipv6），板子连着一个不上网的路由器，电脑又需要通过网线来连那个路由器来访问板子。这时候电脑如果不插网线就能上网，插了就上不了网了。这是因为默认的路由指向了以太网。需要通过<code>route</code>命令来将路由改到WiFi上。首先查看路由表：</p><pre><code>$ route内核 IP 路由表目标       网关         子网掩码   标志 跃点  引用 使用 接口default   OpenWrt.lan  0.0.0.0   UG  100   0    0   enp2s0...</code></pre><p>我电脑的以太网接口是enp2s0，WiFi接口是wlp1s0（别的电脑可能分别是eth0和wlan0）。default到了enp2s0，将其路由到wlp1s0：</p><pre><code>$ sudo route del default$ sudo route add default gw &lt;只连WiFi时候的网关&gt; wlp1s0</code></pre><p>此时默认就路由到WiFi上了。此时或许还可能上不了网但是能ping外网。此时就要在<code>/etc/resolv.conf</code>里面改DNS，比方说改为114.114.114.114，然后就可以上网了。</p><h4 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h4><p>在第一层次的配置中使能<code>Networking support</code>，然后在其下<code>Networking options</code>下面使能<code>TCP/IP networking</code>，我只留了这些配置：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/net-config.jpeg" alt="最小网络配置" title="">                </div>                <div class="image-caption">最小网络配置</div>            </figure></p><p>并且添加网卡驱动：分别需要MAC和phy的驱动。在<code>Device Drivers</code>-&gt;<code>Network device support</code>-&gt;<code>Ethernet driver support</code>下面选择STM32的MAC。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/net-config2.jpeg" alt="MAC配置" title="">                </div>                <div class="image-caption">MAC配置</div>            </figure></p><p>phy的驱动可以选择默认的<code>CONFIG_FIXED_PHY</code>，也可以选择SMSC的phy，都可以成功驱动LAN8720A。在<code>Device Drivers</code>-&gt;<code>Network device support</code>-&gt;<code>PHY Device support and infrastructure</code>下选择。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/net-config2.2.jpeg" alt="网卡配置" title="">                </div>                <div class="image-caption">网卡配置</div>            </figure></p><p>然后修改设备树：<br>首先在<code>stm32f429.dtsi</code>里的pinctrl节点下增加一个RMII引脚的配置，并且在ethernet节点下面添加mac地址；mac地址可以随便设置，只要不跟局域网里面的设备重合就行了：</p><pre><code class="c">/ {    ...    soc {        ...        pinctrl: pin-controller {            ...            // RMII引脚复用的配置            ethernet_rmii: rmii@0 {                pins {                    pinmux = &lt;STM32F429_PB12_FUNC_ETH_MII_TXD0_ETH_RMII_TXD0&gt;,                        &lt;STM32F429_PB13_FUNC_ETH_MII_TXD1_ETH_RMII_TXD1&gt;,                        &lt;STM32F429_PB11_FUNC_ETH_MII_TX_EN_ETH_RMII_TX_EN&gt;,                        ...                    slew-rate = &lt;3&gt;;                };            };            ...        };        ...        // ethernet节点        mac: ethernet@40028000 {            // 添加mac地址            mac-address = [C0 B1 3D 88 88 89];            // 其他属性照旧        };    };};</code></pre><p>然后在<code>stm32f429-disco.dts</code>里补充设置ethernet节点：</p><pre><code class="c">&amp;mac {    status = &quot;okay&quot;;    pinctrl-0   = &lt;&amp;ethernet_rmii&gt;;    pinctrl-names = &quot;default&quot;;    phy-mode    = &quot;rmii&quot;;    snps,reset-gpio = &lt;&amp;gpioh 2 GPIO_ACTIVE_HIGH&gt;;    snps,reset-active-low;    snps,reset-delays-us = &lt;0 10000 100000&gt;;};</code></pre><p>这些设置的来源是<a href="https://elixir.bootlin.com/linux/latest/source/Documentation/devicetree/bindings/net/stm32-dwmac.txt" target="_blank" rel="noopener">Documentation/devicetree/bindings/net/stm32-dwmac.txt</a>。这里并不需要像stm32429i-eval评估板设置的那么繁琐，只需要设置哪一套引脚、RMII模式，以及phy芯片的reset引脚即可。</p><h5 id="源码里的小bug"><a href="#源码里的小bug" class="headerlink" title="源码里的小bug"></a>源码里的小bug</h5><p>stm32的MAC初始化是<code>drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c</code>的<code>stm32_dwmac_init()</code>，它根据配置将外设设置为MII模式或RMII模式。<a href="https://elixir.bootlin.com/linux/latest/source/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c#L42" target="_blank" rel="noopener">原代码第42行左右</a>RMII模式寄存器设置错误。本网卡只有RMII模式，而stm32429i-eval的网卡工作在MII模式，估计因此他们没查出这个bug。</p><pre><code class="c">-  val = (plat_dat-&gt;interface == PHY_INTERFACE_MODE_MII) ? 0 : 1;+  val = (plat_dat-&gt;interface == PHY_INTERFACE_MODE_MII) ? 0 : MII_PHY_SEL_MASK;</code></pre><h5 id="启动的printk"><a href="#启动的printk" class="headerlink" title="启动的printk"></a>启动的printk</h5><pre><code>[    3.430000] libphy: Fixed MDIO Bus: probed[    3.470000] stm32-dwmac 40028000.ethernet: PTP uses main clock[    3.480000] stm32-dwmac 40028000.ethernet: no reset control found[    3.480000] stmmac - user ID: 0x10, Synopsys ID: 0x35[    3.490000] stm32-dwmac 40028000.ethernet: Ring mode enabled[    3.500000] stm32-dwmac 40028000.ethernet: DMA HW capability register supported[    3.510000] stm32-dwmac 40028000.ethernet: Enhanced/Alternate descriptors[    3.510000] stm32-dwmac 40028000.ethernet: Enabled extended descriptors[    3.520000] stm32-dwmac 40028000.ethernet: RX Checksum Offload Engine supported[    3.530000] stm32-dwmac 40028000.ethernet: COE Type 2[    3.530000] stm32-dwmac 40028000.ethernet: TX Checksum insertion supported[    3.540000] stm32-dwmac 40028000.ethernet: Wake-Up On Lan supported[    3.550000] stm32-dwmac 40028000.ethernet: Enable RX Mitigation via HW Watchdog Timer[    4.200000] libphy: stmmac: probed...[    4.330000] stm32_rtc 40002800.rtc: setting system clock to 2000-01-01 03:07:42 UTC (946696062)[    4.540000] SMSC LAN8710/LAN8720 stmmac-0:00: attached PHY driver [SMSC LAN8710/LAN8720] (mii_bus:phy_addr=stmmac-0:00, irq=-1)[    4.600000] stmmac_init_dma_engine, reset addr: 40028000[    4.600000] stm32-dwmac 40028000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported[    6.930000] stm32-dwmac 40028000.ethernet eth0: Link is Up - 100Mbps/Full - flow control rx/tx</code></pre><h4 id="nfs作为根文件系统"><a href="#nfs作为根文件系统" class="headerlink" title="nfs作为根文件系统"></a>nfs作为根文件系统</h4><p>首先电脑的nfs目录下面得有完整的rootfs；可以暂时先从网上<a href="https://elinux.org/File:Stm32_mini_rootfs.cpio.bz2" target="_blank" rel="noopener">下载一个可用的rootfs</a>，然后解压到那里。</p><p>然后配置内核以使能NFS；<strong>并且需要配置<code>ROOT_NFS</code></strong>：在<code>File systems</code>-&gt;<code>Network File Systems</code>下面即可配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/net-config3.jpeg" alt="nfs配置" title="">                </div>                <div class="image-caption">nfs配置</div>            </figure></p><p>最后在<a href="https://elixir.bootlin.com/linux/latest/source/arch/arm/boot/dts/stm32f429-disco.dts" target="_blank" rel="noopener">stm32f429-disco.dts</a>里面添加内核参数。现在的风格是，kernel command line加在设备树的chosen节点下面，而不是uboot传tags。</p><pre><code>/ {    chosen {        bootargs = &quot;root=/dev/nfs rw &quot;          &quot;ip=192.168.2.123:192.168.2.1:::stm32:eth0:on &quot;          &quot;nfsroot=192.168.2.202:/home/hyq/nfs&quot;;    };    ...};</code></pre><p>其中，<code>ip</code>可以设置为<code>ip=dhcp</code>，也可以像上述那样设置一个固定的地址；<code>nfsroot</code>对应到上位机的ip地址和nfs目录。</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>因为没有DNS，所以不能ping百度之类的域名，只能ping IP地址。而且，如果内核参数是<code>ip=dhcp</code>的话，可以ping通外网；如果只是一个固定地址就只能ping局域网里面的东西。。下面ping的是114.114.114.114这个DNS服务器：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/scene3.jpeg" alt="ping外网IP地址" title="">                </div>                <div class="image-caption">ping外网IP地址</div>            </figure></p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>主流内核中STM32的LTDC驱动居然放在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/gpu/drm/stm/" target="_blank" rel="noopener">drivers/gpu/drm/stm/</a>目录下面。。。想必ST认为它的DMA2D可以算是一个gpu了，于是就要用内核里面的DRM架构了。。实在志不在小。。而emcraft的uclinux中stm32显示驱动还仅仅放在<a href="https://github.com/robutest/uclinux/blob/master/drivers/video/stm32fb.c" target="_blank" rel="noopener">drivers/video/</a>目录下面。</p><p>对于单片机来说，使用DRM架构的一大缺点是它实在太庞大了，塞不进片内flash，只能模块化以跑在SDRAM里，因而性能低下；因此应该选用尽量简单的驱动以避免这一点。</p><h4 id="使用内核中的DRM驱动"><a href="#使用内核中的DRM驱动" class="headerlink" title="使用内核中的DRM驱动"></a>使用内核中的DRM驱动</h4><p>内核配置：开启DRM：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/drm.jpeg" alt="DRM" title="">                </div>                <div class="image-caption">DRM</div>            </figure></p><p>还要开启STM32的DRM支持：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/drm2.jpeg" alt="STM32 DRM" title="">                </div>                <div class="image-caption">STM32 DRM</div>            </figure></p><p>还要开启一个panel。这里为简单起见，选择simple-panel<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/drm3.jpeg" alt="panel" title="">                </div>                <div class="image-caption">panel</div>            </figure></p><p>DRM架构需要有一个panel，即外接的那个液晶屏控制器。有些RGB的lcd也要用诸如I2C接口去配置一些奇怪的参数。板子上直接将RGB用DAC转化成VGA信号了，所以选择一个“哑”的panel，即CONFIG_PANEL_SIMPLE。在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/gpu/drm/panel/panel-simple.c" target="_blank" rel="noopener">drivers/gpu/drm/panel/panel-simple.c</a>里面实现了一大堆LCD，它们只需要开关背光灯就行了。于是在里面找一个想要的尺寸——比如标准VGA信号的640x480——的屏幕，这里选择了et057090dhu，然后稍微改一下那些时钟配置，适合60HZ的VGA：</p><pre><code class="c">static const struct drm_display_mode edt_et057090dhu_mode = {    .clock = 31468,    .hdisplay =    640,    .hsync_start = 640 + 16,    .hsync_end =   640 + 16 + 96,    .htotal =      640 + 16 + 96 + 48,    .vdisplay =    480,    .vsync_start = 480 + 10,    .vsync_end =   480 + 10 + 2,    .vtotal =      480 + 10 + 2 + 33,    .vrefresh = 60,    .flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,};</code></pre><p>设备树需要增加panel-rgb节点，并且有两个endpoint相互指引。改写如下：</p><pre><code class="c">/{    panel_rgb: panel-rgb {        compatible = &quot;edt,et057090dhu&quot;;        status = &quot;okay&quot;;        port {            panel_in_rgb: endpoint {                // 链接到下面的ltdc_out_rgb节点                remote-endpoint = &lt;&amp;ltdc_out_rgb&gt;;            };        };    };    ...};&amp;ltdc {    status = &quot;okay&quot;;    pinctrl-0 = &lt;&amp;ltdc_pins&gt;;    pinctrl-names = &quot;default&quot;;    dma-ranges;    port {        ltdc_out_rgb: endpoint {            // 链接到上面的panel_in_rgb节点            remote-endpoint = &lt;&amp;panel_in_rgb&gt;;        };    };};</code></pre><p>为了启用tty终端，还需要选择<code>CONFIG_FRAMEBUFFER_CONSOLE</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/drm4.jpeg" alt="fbterm" title="">                </div>                <div class="image-caption">fbterm</div>            </figure></p><p>接上显示器，启动之后，就可以看到它在屏幕上慢悠悠地printk()了。。</p><h5 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h5><p>内核初始化结束后，会统一将未用到的外设的时钟关掉；但是这个ltdc的驱动并没有向内核注册时钟，于是它最后就被关掉了。。。于是在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/clk/clk-stm32f4.c#L143" target="_blank" rel="noopener">drivers/clk/clk-stm32f4.c</a>里为ltdc时钟添加<code>CLK_IGNORE_UNUSED</code>的属性。</p><pre><code class="c">static const struct stm32f4_gate_data     stm32f429_gates[] __initconst = {    ...    { STM32F4_RCC_APB2ENR, 26, &quot;ltdc&quot;, &quot;apb2_div&quot;,      CLK_IGNORE_UNUSED },};</code></pre><h4 id="仅使用simple-fb"><a href="#仅使用simple-fb" class="headerlink" title="仅使用simple-fb"></a>仅使用simple-fb</h4><p>这是最简单的方法：bootloader里面初始化显示器，然后给内核传参framebuffer的地址，从而不用那个庞大的DRM架构。初始化部分在bootloader里已讲述。</p><p>在<code>Device Drivers</code>-&gt;<code>Graphics support</code>-&gt;<code>Frame buffer Devices</code>下找到<code>Simple framebuffer support</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/fb.jpeg" alt="simple-fb" title="">                </div>                <div class="image-caption">simple-fb</div>            </figure></p><p>在设备树的chosen节点下增加一个framebuffer节点：</p><pre><code class="c">/ {    chosen {        framebuffer0: framebuffer@83f00000 {            compatible = &quot;simple-framebuffer&quot;;            reg = &lt;0x83f00000 (640 * 480 * 2)&gt;;            width = &lt;640&gt;;            height = &lt;480&gt;;            stride = &lt;(640 * 2)&gt;;            format = &quot;r5g6b5&quot;;            clocks = &lt;&amp;rcc 1 CLK_LCD&gt;;        };    };};</code></pre><p>其中reg属性是framebuffer的地址，其余属性顾名思义。</p><p>显示驱动就可以塞进内核从而跑在片内flash里了。启动之后明显感到刷屏速度增加了数倍。</p><h3 id="USB主机"><a href="#USB主机" class="headerlink" title="USB主机"></a>USB主机</h3><p>STM32F429有两个USB 2.0，一个是全速USB，一个是全速、高速USB，二者片内集成了全速的phy，而后者需要外接phy芯片才能实现高速USB。为简单起见，uc-PC只引出了两个全速USB。虽然它们的寄存器组都非常相似，而且它们都使用Linux内核中相同的驱动，但是它们的表现不太一样。高速USB工作在全速USB下会有点不爽。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>跟很多SOC一样，stm32的很多外设都是Designware的IP，所以驱动比较通用；在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/dwc2/params.c#L149" target="_blank" rel="noopener">drivers/usb/dwc2</a>里面见到stm32的USB驱动竟诸如树莓派（BCM2835）之类的USB驱动并列时，不必惊讶。内核配置在<code>Device Drivers</code>-&gt;<code>USB support</code>下面找到<code>DesignWare USB2 DRD Core Support</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb.jpeg" alt="stm32 dw usb" title="">                </div>                <div class="image-caption">stm32 dw usb</div>            </figure></p><p>设备树里面添加两个USB节点：</p><pre><code class="c">&amp;usbotg_hs {    compatible = &quot;st,stm32f4x9-fsotg&quot;;    dr_mode = &quot;host&quot;;    pinctrl-0 = &lt;&amp;usbotg_fs_pins_b&gt;;    pinctrl-names = &quot;default&quot;;    status = &quot;okay&quot;;};&amp;usbotg_fs {    compatible = &quot;st,stm32f4x9-fsotg&quot;;    dr_mode = &quot;host&quot;;    pinctrl-0 = &lt;&amp;usbotg_fs_pins_a&gt;;    pinctrl-names = &quot;default&quot;;    status = &quot;okay&quot;;};</code></pre><p>但是按照默认代码，高速USB启动时候有错：</p><pre><code>[4.320000] dwc2 40040000.usb: dwc2_core_reset() HANG! Soft Reset GRSTCTL=80000001</code></pre><p>这是因为，dwc的USB HS在配置之前需要复位：通过置位GRSTCTL的第0位，然后等待硬件清零。stm32的USB HS默认是外接PHY芯片的高速模式，软件复位时候需要等PHY芯片。但是板子只有内置PHY。选择内置PHY需要置位GUSBCFG的第6位。</p><p><a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/dwc2/platform.c#L418" target="_blank" rel="noopener">drivers/usb/dwc2/platform.c:dwc2_driver_probe()</a>函数中，首先软件复位，然后在后面的<a href="https://elixir.bootlin.com/linux/latest/source/drivers/usb/dwc2/hcd.c#L136" target="_blank" rel="noopener">drivers/usb/dwc2/hcd.c:dwc2_fs_phy_init()</a>才设置为内置PHY。前面的软件复位等的是外部PHY，于是卡死，无论后面再怎么设置内置PHY。因此需要在前面先将其设置为全速USB模式：</p><pre><code class="c">    // 第418行前面，先设置为全速USB模式    // 其实严格来说应该用writel接口的。。。    *(uint32_t*)0x4004000c |= 0x00000040;    msleep(1);    dwc2_core_reset_and_force_dr_mode(hsotg);</code></pre><p>然后就能启动了。虽然下面的printk还是有点问题，但是启动之后这个USB是没问题的，姑且就不管它了。</p><pre><code>[4.950000] dwc2 40040000.usb: dwc2_wait_for_mode: Couldn&#39;t set host mode[4.960000] dwc2 40040000.usb: DWC OTG Controller[4.960000] dwc2 40040000.usb: new USB bus registered, assigned bus number 1[4.970000] dwc2 40040000.usb: irq 50, io mem 0x40040000[5.010000] hub 1-0:1.0: USB hub found[5.020000] hub 1-0:1.0: 1 port detected</code></pre><h4 id="添加简单设备：USB串口"><a href="#添加简单设备：USB串口" class="headerlink" title="添加简单设备：USB串口"></a>添加简单设备：USB串口</h4><p>直接添加驱动就可以了，比方说PL2303驱动：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb2.jpeg" alt="pl2303驱动配置" title="">                </div>                <div class="image-caption">pl2303驱动配置</div>            </figure></p><p>启动后插上PL2303串口，就可以有<strong>/dev/ttyUSB0</strong>了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/scene6.jpeg" alt="pl2303插入板子" title="">                </div>                <div class="image-caption">pl2303插入板子</div>            </figure></p><p>（其实USB hub是相当通用的233）</p><h4 id="添加U盘驱动"><a href="#添加U盘驱动" class="headerlink" title="添加U盘驱动"></a>添加U盘驱动</h4><p>需要先在<code>Device Drivers</code>-&gt;<code>SCSI device support</code>里面使能SCSI以及SCSI disk：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb3.jpeg" alt="SCSI" title="">                </div>                <div class="image-caption">SCSI</div>            </figure></p><p>然后在<code>Device Drivers</code>-&gt;<code>USB support</code>下面使能USB Mass Storage：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb4.jpeg" alt="USB storage" title="">                </div>                <div class="image-caption">USB storage</div>            </figure></p><p>还要有一个文件系统：比方说fatfs，在<code>File systems</code>-&gt;<code>DOS/FAT/NT Filesystems</code>下面：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb5.jpeg" alt="VFAT" title="">                </div>                <div class="image-caption">VFAT</div>            </figure></p><p>而且还需要有一个字符编码，即所谓的”Native language support”，不然U盘会挂载失败。这里选用”NLS ISO 8859-1”：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb6.jpeg" alt="nls" title="">                </div>                <div class="image-caption">nls</div>            </figure></p><p>插入U盘后就可以有以下printk：</p><pre><code>[ 49.210000] usb 2-1: new full-speed USB device number 2 using dwc2[ 49.460000] usb 2-1: not running at top speed; connect to a high speed hub[ 49.480000] usb 2-1: New USB device found, idVendor=14cd, idProduct=1212[ 49.490000] usb 2-1: New USB device strings: Mfr=1, Product=3, SerialNumber=2[ 49.500000] usb 2-1: Product: Mass Storage Device[ 49.510000] usb 2-1: Manufacturer: Generic[ 49.520000] usb 2-1: SerialNumber: 121220130416[112.900000] SCSI subsystem initialized[112.990000] usb-storage 2-1:1.0: USB Mass Storage device detected[113.010000] scsi host0: usb-storage 2-1:1.0[113.020000] usbcore: registered new interface driver usb-storage[114.080000] scsi 0:0:0:0: Direct-Access     Mass     Storage Device   1.00 PQ: 0 ANSI: 0 CCS[120.110000] sd 0:0:0:0: [sda] 15523840 512-byte logical blocks: (7.95 GB/7.40 GiB)[120.130000] sd 0:0:0:0: [sda] Write Protect is off[120.140000] sd 0:0:0:0: [sda] Mode Sense: 03 00 00 00[120.160000] sd 0:0:0:0: [sda] No Caching mode page found[120.170000] sd 0:0:0:0: [sda] Assuming drive cache: write through[120.200000] random: crng init done[120.210000]  sda: sda1 sda2[120.230000] sd 0:0:0:0: [sda] Attached SCSI removable disk</code></pre><p>可见它已经识别到/dev/sda1、/dev/sda2了。这个U盘里是树莓派的rootfs，其中第一个分区是fat格式，可以挂载来看看：</p><pre><code>/ # mount -t vfat /dev/sda1 /mnt/[  233.320000] FAT-fs (sda1): Volume was not properly unmounted. Some data may be corrupt. Please run fsck./ # ls mntbcm2709-rpi-2-b.dtb  fixup.dat            start.elfbcm2710-rpi-3-b.dtb  fixup_cd.dat         start_cd.elfbootcode.bin         fixup_db.dat         start_db.elfcapture              fixup_x.dat          start_x.elfcmdline.txt          kernel7.imgconfig.txt           overlays/ # </code></pre><h4 id="添加键盘驱动"><a href="#添加键盘驱动" class="headerlink" title="添加键盘驱动"></a>添加键盘驱动</h4><p>键盘驱动也相当通用，直接配置它即可。在<code>Device Drivers</code>-&gt;<code>HID support</code>里面选择<code>Generic HID driver</code>，并且在<code>USB HID drivers</code>下面还要选<code>USB HID transport layer</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb7.jpeg" alt="usb键盘" title="">                </div>                <div class="image-caption">usb键盘</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb8.jpeg" alt="usb键盘" title="">                </div>                <div class="image-caption">usb键盘</div>            </figure><p>然后插上一个<strong>无线键盘</strong>（一定要无线键盘或者机械键盘，普通的有线键盘不行。。），就可以有下面的printk：</p><pre><code>[  830.670000] usb 2-1: new full-speed USB device number 3 using dwc2[  830.930000] usb 2-1: New USB device found, idVendor=24ae, idProduct=2010[  830.940000] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0[  830.950000] usb 2-1: Product: Rapoo 2.4G Wireless Device[  830.960000] usb 2-1: Manufacturer: RAPOO[  831.000000] input: RAPOO Rapoo 2.4G Wireless Device as /devices/platform/soc/50000000.usb/usb2/2-1/2-1:1.0/0003:24AE:2010.0001/input/input0[  831.010000] hid-generic 0003:24AE:2010.0001: input,hidraw0: USB HID v1.10 Mouse [RAPOO Rapoo 2.4G Wireless Device] on usb-50000000.usb-1/input0[  831.080000] input: RAPOO Rapoo 2.4G Wireless Device as /devices/platform/soc/50000000.usb/usb2/2-1/2-1:1.1/0003:24AE:2010.0002/input/input1[  831.160000] hid-generic 0003:24AE:2010.0002: input,hiddev96,hidraw1: USB HID v1.10 Device [RAPOO Rapoo 2.4G Wireless Device] on usb-50000000.usb-1/input1[  831.210000] input: RAPOO Rapoo 2.4G Wireless Device as /devices/platform/soc/50000000.usb/usb2/2-1/2-1:1.2/0003:24AE:2010.0003/input/input2[  831.290000] hid-generic 0003:24AE:2010.0003: input,hidraw2: USB HID v1.10 Keyboard [RAPOO Rapoo 2.4G Wireless Device] on usb-50000000.usb-1/input2</code></pre><p>此时敲击键盘，屏幕上的终端将会有显示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/usb9.jpeg" alt="键盘orz" title="">                </div>                <div class="image-caption">键盘orz</div>            </figure></p><p>其实Linux的input事件是全局性的，因此只要驱动配好了，就有反应了。</p><h5 id="为啥不能用普通的有线键盘？"><a href="#为啥不能用普通的有线键盘？" class="headerlink" title="为啥不能用普通的有线键盘？"></a>为啥不能用普通的有线键盘？</h5><p>stm32的USB在Linux下的驱动有个很大的问题：它不识别低速设备。。。整天枚举失败。。。这估计是stm32跑Linux的性能太低了，以至于设备跑得比stm32都要快，于是就说设备不接受地址云云。。而低端的有线键盘都是低速设备，于是枚举失败。。</p><pre><code>[ 1506.090000] usb 2-1: new low-speed USB device number 6 using dwc2[ 1506.310000] usb 2-1: device descriptor read/64, error -71</code></pre><h3 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h3><p>emcraft的4.2内核中，SD卡驱动直接用arm通用的驱动”arm,primecell”，这个compatible在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/of/platform.c#L376" target="_blank" rel="noopener">drivers/of/platform.c</a>里面匹配，并生成一个amba总线。另外它在drivers/mmc/host/mmci.c里面实现了一个variant_stm32f4，从而接入Linux的mmc驱动栈中。</p><p>按理说主流的Linux 4.13内核也是可以这么干的，但是这里的drivers/mmc/host/mmci.c的数据结构跟前者并不完全相同，而且逻辑处理也不同了。这导致SD卡整天不能识别。。</p><h4 id="方便起见，直接换能用的代码"><a href="#方便起见，直接换能用的代码" class="headerlink" title="方便起见，直接换能用的代码"></a>方便起见，直接换能用的代码</h4><p>将emcraft的mmci.c、mmci.h复制过来直接用。。。<br>内核配置：选择<code>ARM AMBA Multimedia Card Interface support</code>以及<code>MMC block device driver</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/mmc.jpeg" alt="mmc配置" title="">                </div>                <div class="image-caption">mmc配置</div>            </figure></p><p>设备树增加mmc节点，基本照抄emcraft的，不过并没用DMA，因为性能比较低下，DMA很容易下溢死掉：</p><pre><code class="c">sdio:sdi@40012C00 {    compatible = &quot;arm,primecell&quot;;    reg = &lt;0x40012C00 0x400&gt;;    interrupts = &lt;49&gt;;    max-frequency = &lt;25000000&gt;;    bus-width = &lt;4&gt;;    voltage-ranges = &lt;3200 3300 3300 3400&gt;;    clocks = &lt;&amp;rcc 0 171&gt;;    clock-names = &quot;apb_pclk&quot;;    arm,primecell-periphid = &lt;0x40480180&gt;;    status = &quot;disabled&quot;;};...&amp;sdio {    status = &quot;okay&quot;;    pinctrl-names = &quot;default&quot;;    pinctrl-0 = &lt;&amp;sdio_pins&gt;;    cd-gpio = &lt;&amp;gpioh 15 GPIO_ACTIVE_LOW&gt;;};</code></pre><p>其中<code>cd-gpio</code>是卡识别的GPIO。</p><h4 id="挂载SD卡"><a href="#挂载SD卡" class="headerlink" title="挂载SD卡"></a>挂载SD卡</h4><p>插卡后，将有以下的printk：</p><pre><code>[ 5492.300000] mmc0: host does not support reading read-only switch, assuming write-enable[ 5492.310000] mmc0: new SD card at address 0001[ 5492.320000] mmcblk0: mmc0:0001  971 MiB [ 5492.340000]  mmcblk0: p1 p2/ # ls /dev/mmcblk0*/dev/mmcblk0    /dev/mmcblk0p1  /dev/mmcblk0p2/ # </code></pre><p>此时就可以正常挂载它了。不过有时候会出现EIO错误；发出EIO的地方是<a href="https://elixir.bootlin.com/linux/latest/source/drivers/mmc/host/mmci.c#L961" target="_blank" rel="noopener">mmci.c：mmci_data_irq</a>第995行左右的 if (status &amp; MCI_RXOVERRUN)，这是<strong>SDIO的FIFO溢出了</strong>，说明主控取数据太慢了。。解决的办法是<strong>开硬件流控制</strong>，当sdio发现fifo溢出时候会卡一下时钟，免得sd卡跑的太快。这就需要在variant_stm32f4里面加一个控制位：</p><pre><code>.clkreg_enable          = MCI_ST_UX500_HWFCEN,</code></pre><p>这是SDIO_CLKCR的第14位。</p><p>有时候也会有EILSEQ错误，也是在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/mmc/host/mmci.c#L949" target="_blank" rel="noopener">mmci.c：mmci_data_irq</a>里面发出的，<strong>起因是CRC错误</strong>，这可能是因为走线不太好或者接触不良啥的。于是<strong>降低时钟频率</strong>：调高SDIO_CLKCR的低8位分频数，于是variant_stm32f4的clkreg_enable变成：</p><pre><code>.clkreg_enable          = MCI_ST_UX500_HWFCEN | 0x00000006,</code></pre><p>然后就没错了。。。</p><h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>Linux里面集成了STM32的DCMI驱动，直接用就行了。</p><h4 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h4><p>在<code>Device Drivers</code>-&gt;<code>Multimedia support</code>-&gt;<code>V4L platform devices</code>里面使能DCMI的驱动：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/dcmi.jpeg" alt="STM32 DCMI" title="">                </div>                <div class="image-caption">STM32 DCMI</div>            </figure></p><p>然后添加摄像头驱动。记得要<strong>先取消掉<code>Autoselect ancillary drivers</code>的选项</strong>，下面才有一系列的摄像头驱动可选：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/dcmi2.jpeg" alt="摄像头驱动" title="">                </div>                <div class="image-caption">摄像头驱动</div>            </figure></p><p>不妨添加OV2640的驱动。这是一个200万像素的摄像头，可以输出RGB、YUV、JPEG格式的照片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/dcmi3.jpeg" alt="OV2640驱动" title="">                </div>                <div class="image-caption">OV2640驱动</div>            </figure></p><p>然后设备树中，<strong>在I2C节点下面</strong>添加OV2640的节点：</p><pre><code class="c">&amp;i2c1 {    status = &quot;okay&quot;;    ov2640: camera@30 {        compatible = &quot;ovti,ov2640&quot;;        reg = &lt;0x30&gt;;        clocks = &lt;&amp;clk_ext_camera&gt;;        clock-names = &quot;xvclk&quot;;        status = &quot;okay&quot;;        port {            // 指向下面的dcmi_0 endpoint            ov2640_0: endpoint {                remote-endpoint = &lt;&amp;dcmi_0&gt;;            };        };    };};&amp;dcmi {    status = &quot;okay&quot;;    port {        dcmi_0: endpoint {            // 指向上面的ov2640 endpoint            remote-endpoint = &lt;&amp;ov2640_0&gt;;            bus-width = &lt;8&gt;;            hsync-active = &lt;0&gt;;            vsync-active = &lt;0&gt;;            pclk-sample = &lt;1&gt;;        };    };};</code></pre><p>配置基本上照抄stm32429i-eval的配置。</p><p>启动之后可以看到摄像头的printk：</p><pre><code>[    5.600000] stm32f4-i2c 40005400.i2c: STM32F4 I2C driver registered[    5.760000] Linux video capture interface: v2.00[    5.870000] stm32-dcmi 50050000.dcmi: Probe done[    5.970000] ov2640 0-0030: ov2640 Product ID 26:42 Manufacturer ID 7f:a2[    5.990000] i2c i2c-0: OV2640 Probed</code></pre><h4 id="v4l2应用程序测试"><a href="#v4l2应用程序测试" class="headerlink" title="v4l2应用程序测试"></a>v4l2应用程序测试</h4><p>v4l2有个官方测试程序<a href="https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/capture.c.html" target="_blank" rel="noopener">capture.c</a>，它将摄像头数据写入文件中。可以改写一下，将裸RGB数据写到/dev/fb0中，那么就可以在显示器上看到摄像头的数据了。比方说这样写：</p><pre><code class="c">// 先打开/dev/fb0fp = fopen(&quot;/dev/fb0&quot;, &quot;w&quot;);framebuffer = malloc(640*480*2);// 在主循环里面将数据写入framebufferstatic void process_image(const void *p, int size){    short *fb = framebuffer, *src = p;    if (out_buf) {        for(int y = 0; y &lt; 240; y++)            for(int x = 0; x &lt; 320; x++)                fb[y*2*640 + x*2] = src[y*320 + x];        fseek(fp, 0, SEEK_SET);        fwrite(fb, 640*480*2, 1, fp);    }    fflush(stderr);    fprintf(stderr, &quot;.&quot;);    fflush(stdout);}</code></pre><p>编译之后，使用<code>.capture -o -f -c 10</code>，即是获取10张照片并写入framebuffer。可以在显示器上看到照片：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/scene5.jpeg" alt="摄像头测试" title="">                </div>                <div class="image-caption">摄像头测试</div>            </figure></p><p>不过由于STM32的DMA最多只能搬运64k个单位的数据，以32字为单位的话最多就是256kb大小的数据。于是摄像头只能设置为320x240大小。并且由于应用程序在SDRAM上跑，性能低下，以至于两秒钟才能出一张图片。。。而且SDRAM的带宽太小，拍照时还会时常说DMA下溢orz。。。据ST的手册推荐的话，应该利用DMA的双缓冲特性从而突破64k的限制，不过内核中并没有实现这一点。</p><h3 id="yaffs2"><a href="#yaffs2" class="headerlink" title="yaffs2"></a>yaffs2</h3><p>yaffs已经是一个相当老的文件系统了。。。它在几十上百MB的SLC上面跑到很欢快，但是并不太适用于MLC、TLC之类的几GB以上的大容量nand flash。不过对于uc-PC来说已经足够了。yaffs2适应于大页（2kb）的nand flash，yaffs适应于小页（512B）的nand flash。yaffs2声称它可工作在yaffs模式下面从而向前适应（但是我实验结果发现它并不如此）。</p><p>yaffs可以<a href="https://yaffs.net/get-yaffs" target="_blank" rel="noopener">从它官网上下载</a>。</p><h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p>根据它的<a href="http://www.aleph1.co.uk/gitweb/?p=yaffs2.git;a=blob;f=README-linux;h=93cf4a14ce41deadff15868587ab48aa28701d95;hb=1f3d64d1d804fef6715126dead54bf30b176c67e" target="_blank" rel="noopener">README-linux</a>，使用以下命令去给内核打补丁：</p><pre><code>./patch-ker.sh  c m &lt;内核目录&gt;</code></pre><p>然后内核配置时候就可以有yaffs的选项了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/yaffs.jpeg" alt="yaffs配置" title="">                </div>                <div class="image-caption">yaffs配置</div>            </figure></p><p>yaffs2已经可以支持4.9的内核了。不过在4.13内核上编译有问题，提示CURRENT_TIME这个宏未定义。发现这是因为Linux打算解决y2038的千年虫问题，需要改用别的计时方式。我直接用了current_kernel_time()代替了。</p><p>接下来要在内核里面添加nand flash的驱动。为方便起见，使用platform-nand驱动，即<code>CONFIG_MTD_NAND_PLATFORM</code>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc5/yaffs2.jpeg" alt="platform nand驱动" title="">                </div>                <div class="image-caption">platform nand驱动</div>            </figure></p><p>仿照<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/mach-omap1/board-h2.c" target="_blank" rel="noopener">arch/arm/mach-omap1/board-h2.c</a>，在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/mach-stm32/board-dt.c" target="_blank" rel="noopener">arch/arm/mach-stm32/board-dt.c</a>里面定义分区表以及驱动信息。</p><p>试探性的定义了三个分区：</p><pre><code class="c">/* 分区表 */static struct mtd_partition stm32_nand_partitions[] = {    {        .name       = &quot;first&quot;,        .offset     = 0,        .size       = 128 * 1024,        .mask_flags = MTD_WRITEABLE,    /* force read-only */    },    {        .name       = &quot;second&quot;,        .offset     = MTDPART_OFS_APPEND,        .size       = 256 * 1024,        .mask_flags = MTD_WRITEABLE,    /* force read-only */    },    {        .name       = &quot;rootfs&quot;,        .offset     = MTDPART_OFS_APPEND,        .size       = 120 * SZ_1M,    },};</code></pre><p>然后是platform data：</p><pre><code class="c">static struct platform_nand_data stm32_nand_platdata = {    .chip = {        // 分区表        .nr_partitions = ARRAY_SIZE(stm32_nand_partitions),        .partitions = stm32_nand_partitions,    },    .ctrl = {        // 读写驱动程序        .cmd_ctrl  = fmc_send_cmd,        .dev_ready = fmc_read_rb,    },};</code></pre><p>接着是platform device：</p><pre><code class="c">static struct platform_device stm32_nand_device = {    .name = &quot;gen_nand&quot;,    .dev  = {        .platform_data = &amp;stm32_nand_platdata,    },};</code></pre><p>最后，在模块构造函数里面注册platform device：</p><pre><code class="c">static void __init board_stm32_ucpc_init(void){    printk(&quot;STM32 UCPC: nand platform device&quot;);    platform_add_devices(stm32_devices, ARRAY_SIZE(stm32_devices));}</code></pre><p>启动之后，可以看到识别到三个分区：</p><pre><code>[    0.970000] nand: device found, Manufacturer ID: 0xec, Chip ID: 0xf1[    0.980000] nand: Samsung NAND 128MiB 3,3V 8-bit[    0.980000] nand: 128 MiB, SLC, erase size: 128 KiB, page size: 2048, OOB size: 64[    0.990000] Scanning device for bad blocks[    1.090000] Creating 3 MTD partitions on &quot;gen_nand.0&quot;:[    1.100000] 0x000000000000-0x000000020000 : &quot;first&quot;[    1.120000] 0x000000020000-0x000000060000 : &quot;second&quot;[    1.150000] 0x000000060000-0x000007860000 : &quot;rootfs&quot;</code></pre><h4 id="yaffs作为根文件系统"><a href="#yaffs作为根文件系统" class="headerlink" title="yaffs作为根文件系统"></a>yaffs作为根文件系统</h4><p>查看dmesg，可以看到有<code>Creating xxx MTD partitions on xxx</code>的信息。根据它出现的<strong>时间先后顺序</strong>，这些块设备依次形成<code>/dev/mtdblock0</code>、<code>/dev/mtdblock1</code>、<code>/dev/mtdblock2</code>等等。将含有rootfs的mtd分区传参给内核。</p><p>但是在这之前先得将rootfs烧录进nand flash。我使用了最简单的方法：先uboot通过tftp启动一个跑在SDRAM上的内核，挂载mtd分区<strong>以及nfs</strong>，然后从nfs上面拷贝rootfs到mtd分区里面。。。然后改写kernel command line，将mtd分区作为rootfs传参。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;uc-PC板子上跑的是Linux 4.13.3，使用设备树。内核不经压缩，&lt;strong&gt;就地运行&lt;/strong&gt;（XIP，全称execute in place）。&lt;/p&gt;
&lt;p&gt;需要使能的功能有：网络、显示、USB、SD卡、摄像头、yaffs。这些功能全部开启的话，内核大小将为4MB以上，而片内flash只有2MB，不模块化的话只能跑在SDRAM上，这回导致性能低下，所以调通设备驱动之后应该进行模块化，将关键部分编译进内核，内核塞进片内flash，从而提高性能。&lt;/p&gt;
&lt;p&gt;以下将只描述它们如何配置，而不涉及具体驱动的软件架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置之前，应该设置环境变量：&lt;strong&gt;ARCH=arm CROSS_COMPILE=arm-none-eabi-&lt;/strong&gt;（其他编译工具链设置也类似），不然的话会按照host的架构去配置。&lt;/li&gt;
&lt;li&gt;配置时一般用&lt;code&gt;make menuconfig&lt;/code&gt;，如果装了qt的话还可以用&lt;code&gt;make xconfig&lt;/code&gt;；后者可以用鼠标操作，全屏的话看到的信息量更多。&lt;/li&gt;
&lt;li&gt;搜索某一个配置时，不用加&lt;code&gt;CONFIG_&lt;/code&gt;前缀，而且不用管大小写。&lt;/li&gt;
&lt;li&gt;某一个配置没有显示出来，是因为它依赖的配置还没有使能；这时就要耐着性子去一个个翻找。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;（手机请横屏看代码）&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[4] 小议“设备树”</title>
    <link href="http://yoursite.com/ucpc4/"/>
    <id>http://yoursite.com/ucpc4/</id>
    <published>2018-03-01T07:33:52.000Z</published>
    <updated>2019-04-27T18:59:05.773Z</updated>
    
    <content type="html"><![CDATA[<p>讲设备树的文章不少。以下是一些挺有意思的文章：</p><ul><li><a href="http://www.wowotech.net/device_model/why-dt.html" target="_blank" rel="noopener">蜗窝科技的博客</a>紧扣Linux内核来讲设备树的来历与用法；</li><li>Thomas Petazzoni是Bootlin公司（以前叫Free Electrons，一家很有水平的专注Linux的法国公司）的CTO，他写过一份讲义叫<a href="https://bootlin.com/pub/conferences/2013/elce/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf" target="_blank" rel="noopener">《傻瓜都懂的设备树》</a>，详细地介绍了设备树的语法与Linux内核中现实的用例；</li><li><a href="https://elinux.org/images/0/0c/Rowand--devicetree_kernel_internals.pdf" target="_blank" rel="noopener">device tree kernel internals</a>这篇报告更加详细地描述了设备树的语法、编译过程，并分析了设备树展开过程的一些源码；</li><li>还是Thomas Petazzoni，他在2015年的ELC会议上抱怨说：<a href="https://events.static.linuxfound.org/sites/events/files/slides/petazzoni-dt-as-stable-abi-fairy-tale.pdf" target="_blank" rel="noopener">不同内核里设备树接口要保持可移植性，这简直是个神话</a>；</li></ul><p>很多介绍设备树的文章都会开门见山地介绍设备树的各种概念，然后罗列出设备树的语法。<strong>不过很少有人会从头到尾讲透驱动程序和设备树，然后旗帜鲜明地指出，设备树描述的就是平台设备（platform_device），或许他们默认了你已经懂得那些前提知识</strong>。以下记录了我的一些思考，尝试从<code>面向对象</code>的角度去切入。</p><p><em>（手机请横屏看代码）</em><br><a id="more"></a></p><h3 id="C语言实现面向对象的概念"><a href="#C语言实现面向对象的概念" class="headerlink" title="C语言实现面向对象的概念"></a>C语言实现面向对象的概念</h3><p>“面向对象”与其说是一种程序设计方法（方法论），不如说是一种思维（世界观）。我的一位老师粗略估计了一下：如果你用面向过程的思维去写代码维护代码，顶多能弄50万行；而用面向对象的思维的话，还不知道上限是多少。Windows XP泄露出来的源码就有4500万行了，前段时间泄露出来的Win10源码大小有12TB，一般人下下来都存不下。</p><p>如今Linux内核也有接近2000万行代码，uboot都有80万行代码了，而它们都用C语言写成，想必是用了不同于面向过程的思维和技巧了。</p><p>C语言可以实现相当多的面向对象的概念，有相当多的书籍讲述了object oriented C（OOC），关键就是使用struct去封装成员对象和函数指针，函数指针就是方法；指针很自由，可以表达各种概念。其中，<a href="http://customers.hbci.com/~rpopp/Books/Object-oriented%20Programming%20With%20ANSI-C.pdf" target="_blank" rel="noopener"><strong><em><code>Object-oriented Programming With ANSI-C</code></em></strong></a>这本书里的实现方法相当优雅，它并不局限于struct，而且它将void指针玩出花来了，可以说离仅使用基本面向对象语法的C++就差个class关键字了。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>声明一个<code>struct</code>就是声明一个<code>类</code>。定义一个struct就是将类<code>实例化</code>为<code>对象</code>。</p><p>一个类里面声明有<code>属性</code>和<code>方法</code>。使用struct的话，属性就照常写，方法就写为<code>函数指针</code>。比方说在<strong>一个头文件里</strong>声明foo类，里面有一个成员叫bar，然后有一个方法get_bar，返回实际对象里的bar值：</p><pre><code class="c">struct foo {    // 属性    int bar;    // 接口    int (*get_bar)(struct foo*);};</code></pre><p>get_bar()函数一般在<strong>某一个C文件里</strong>实现为static函数：</p><pre><code class="c">static int my_get_bar(struct foo* f){    return f-&gt;bar;}</code></pre><p>然后，在<strong>同一个C文件里面</strong>实现<strong>全局可见</strong>的<code>构造函数</code>：</p><pre><code class="c">struct foo* new_foo(void){    struct foo* f = (struct foo*)    malloc(sizeof(struct foo));    if (!f)        return NULL;    // 然后可有一些默认初始化    f-&gt;bar = 0;    // 还要初始化接口函数指针！    f-&gt;get_bar = my_get_bar;    return f;}</code></pre><p>最后，这样使用这个类：</p><pre><code class="c">// new一个对象：struct foo* f = new_foo();// 通过接口访问该对象int the_bar = f-&gt;get_bar(f);// 删除这个对象free(f);</code></pre><p>上述的实现方法展示了最基础的类的封装。接口除了基本的getter和setter之外，<code>构造函数</code>和<code>析构函数</code>也可以定义为函数指针。这时候可以写出通用的new和delete函数统一管理所有的类。Linux内核里有多种宏可以达到new和delete的目的，比方说可以通过<code>MODULE_init()</code>宏修饰构造函数，通过<code>MODULE_exit()</code>宏修饰析构函数。</p><p><code>封装</code>不仅仅是属性和方法的整合，还包括要<code>数据隐藏</code>：只能通过一些接口来访问一个对象的属性。鉴于C语言缺乏private等语法，数据隐藏有以下方法：</p><ul><li>像上面提到的<a href="http://customers.hbci.com/~rpopp/Books/Object-oriented%20Programming%20With%20ANSI-C.pdf" target="_blank" rel="noopener">OO ANSI-C</a>那本书那样使用void指针。void指针也称自由指针，这样的话struct里面的东西就完全private了，只能通过接口来访问。</li><li>或者，靠程序员的自律（Linux内核就是这样干的）</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>（继承也称泛化。“A<code>泛化</code>为B”，跟“B<code>继承</code>了A”是一个意思。）</p><p>现在假设另一个类foo2<code>继承</code>了foo，可以这样声明：</p><pre><code class="c">struct foo2 {    struct foo *super;};</code></pre><p>然后foo2的构造函数如下：</p><pre><code class="c">struct foo2 *new_foo2(void){    struct foo2 *f2 = (struct foo2)        malloc(sizeof(struct foo2));    if (!f2)        return NULL;    // 构造父类    f2-&gt;super = new_foo();    if (!f2-&gt;super) {        free(f2);        return NULL;    }    return f2;}</code></pre><p>如果需要访问foo2继承自foo的属性，则通过foo2-&gt;super的接口来访问。也可以在foo2里面重新造轮子，先做一些自己的东西，然后再调用super的方法（Linux内核里面经常这样做）。</p><p><strong>可见，要实现继承，一般在子类里面定义一个父类（或它的指针）</strong>。如果是<code>多继承</code>，那就多构造几个父类。值得注意的是，要逐个构造不同的类时，只要有一个类没有成功构造，之前所成功构造的类都得析构。这样的话会写得很麻烦，于是Linux内核推荐使用<code>goto</code>语句：</p><pre><code class="c">    struct f1 *f1 = new_f1();    if (!f1) goto NULL_F1;    struct f2 *f2 = new_f2();    if (!f2) goto NULL_F2;    struct f3 *f3 = new_f3();    if (!f3) goto NULL_F3;    ...    // 成功    return foobar;    // 各种程度的失败NULL_F3:    free(f2);NULL_F2:    free(f1);NULL_F1:    return NULL;</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>因为使用了函数指针，指针非常自由，因而可以将其替换为任何合适的函数。于是子类可以<code>重写（overridding）</code>父类的方法，这体现了<code>多态</code>。</p><p><code>重载（overloading）</code>是一种语言特性，然而C语言并不能提供这种特性，所以在需要重载的地方使用多个函数。比方说Linux的<code>wait3()</code>、<code>wait4()</code>等一系列wait系统调用，wait3表示它有3个参数，wait4表示它有4个参数。。。</p><h4 id="举个例子：内核中STM32的串口驱动"><a href="#举个例子：内核中STM32的串口驱动" class="headerlink" title="举个例子：内核中STM32的串口驱动"></a>举个例子：内核中STM32的串口驱动</h4><p>其实不只是STM32，其他片子的串口都实现为一个tty驱动。tty不只有串口终端，还有framebuffer终端、网络终端等等，它们都统一为一个相当复杂的tty架构，不过下面仅简单探讨一些类的继承关系。</p><p>它涉及到<code>tty_driver</code>、<code>uart_port</code>、<code>stm32_port</code>这3个类，它们这样定义：</p><p><a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/tty_driver.h#L296" target="_blank" rel="noopener">include/linux/tty_driver.h</a></p><pre><code class="c">struct tty_driver {    ...    const struct tty_operations *ops;    ...};</code></pre><p><a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/serial_core.h#L117" target="_blank" rel="noopener">include/linux/serial_core.h</a></p><pre><code class="c">struct uart_port {    ...    const struct uart_ops *ops;    ...    struct tty_driver *tty_driver;};</code></pre><p><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/stm32-usart.h#L214" target="_blank" rel="noopener">drivers/tty/serial/stm32-usart.h</a></p><pre><code class="c">struct stm32_port {    struct uart_port port;    ...};</code></pre><p>其中，tty_operations和uart_ops都是函数指针表。从上面代码片段可以看出，uart_port继承了tty_driver，stm32_port继承了uart_port。</p><p>值得注意的是，tty_operations里的函数，不实现在tty相关的c文件里，而实现在serial相关的c文件里；uart_port的函数，不实现在serial相关c文件里，而实现在每一个芯片的串口驱动的c文件里面。这说明前两个类是<strong>抽象类</strong>。</p><p>假设我们要发送数据。tty_operations里有个<code>write()</code>，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/serial_core.c#L546" target="_blank" rel="noopener">drivers/tty/serial/serial_core.c</a>里将其实现为<code>uart_write()</code>；它将数据填入缓冲区后，最终调用了uart_ops的<code>start_tx()</code>，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/stm32-usart.c#L393" target="_blank" rel="noopener">drivers/tty/serial/stm32-usart.c</a>里将其实现为<code>stm32_start_tx()</code>，最终依靠DMA或者轮询（polling IO）的方式将数据写入串口数据寄存器中。</p><p>还应注意到的是，它们构造父类的风格并不统一：uart_port想要继承tty_driver，则通过<code>alloc_tty_driver()</code>来new一个父类，然后<code>tty_set_operations()</code>等建立与父类的联系，最后<code>tty_register_driver()</code>注册驱动函数。而stm32_port要继承uart_port就直接在子类内部定义一个父类对象就完事了。</p><h4 id="container-of（）"><a href="#container-of（）" class="headerlink" title="container-of（）"></a>container-of（）</h4><p>写驱动时常需要继承一些已有的类，比方说一个字符设备驱动继承cdev，或者如1.4的例子stm32串口设备继承uart_port。C语言里父类定义在子类内部，而内核的基础设施传参时只将父类对象的指针传进来，但是驱动程序要用到的又是子类对象。所以问题就是，如何通过父类对象找到子类对象。</p><p>有一个解决办法是，将父类定义为子类的<strong>第一个成员</strong>，这样的话就可以通过强制类型转换，直接得到子类。比如：</p><pre><code class="c">struct son {    struct father father;    ...};</code></pre><p>如果有一个指针<code>struct father *f</code>，而且知道它肯定是被继承为son的对象，那么这个指针可以强转为<code>struct son*</code>指针。</p><p>但是多继承的情况就无法这样做了；而且只能将父类定义为第一个成员，简直太死板了。于是Linux内核里面定义了一个<code>contailer_of()</code>宏，通过结构体成员的地址找到整个结构体的地址。定义在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/kernel.h#L858" target="_blank" rel="noopener">include/linux/kernel.h</a>：</p><pre><code class="c">#define container_of(ptr, type, member) ({   \    void *__mptr = (void *)(ptr); \    ((type *)(__mptr - offsetof(type, member))); })</code></pre><p>意思是，该成员的地址减去其在结构体中的偏移量，就是包含它的那个结构体的地址。其中<code>offsetof()</code>宏定义在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/stddef.h" target="_blank" rel="noopener">include/linux/stddef.h</a>：</p><pre><code>#ifdef __compiler_offsetof#define offsetof(TYPE, MEMBER)    __compiler_offsetof(TYPE, MEMBER)#else#define offsetof(TYPE, MEMBER)    ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)#endif</code></pre><p>gcc预定义了<code>__compiler_offsetof()</code>宏，可以直接用。如果编译器没有这个手段的话，那么就将其定义为<strong>在0地址处的那个结构体的那个成员的偏移量</strong>。。。</p><p>值得一提的是，gcc对C语言做了大量的扩展，比方说它允许花括号括着的<code>块结构</code>有返回值：注意到那个圆括号花括号的组合<code>({...})</code>，返回的是块结构中最后一句话的返回值。另外它还允许在块结构中定义函数，于是gcc的<a href="https://www.codeproject.com/tips/614570/lambda-in-c-gcc" target="_blank" rel="noopener">C语言可以神奇地写出lamda函数</a>。。。</p><h3 id="Linux设备驱动模型"><a href="#Linux设备驱动模型" class="headerlink" title="Linux设备驱动模型"></a>Linux设备驱动模型</h3><p>在2.5版本的内核中集中精力重新设计了设备驱动程序的架构，提出了一个精心设计的<code>设备模型</code>。想要实现的效果便是：如果内核发现一个设备，而且内核中有其驱动，那么内核就可以把该设备暴露到用户空间中，以待应用程序操作。而且引入sysfs，并以kobj作为sysfs里面每个对象的基类。</p><h4 id="著名的设备、驱动、总线三剑客"><a href="#著名的设备、驱动、总线三剑客" class="headerlink" title="著名的设备、驱动、总线三剑客"></a>著名的设备、驱动、总线三剑客</h4><p>外设通过总线挂到CPU上，整个系统看上去长这样（图自<a href="https://doc.lagout.org/operating%20system%20/linux/Essential%20Linux%20Device%20Drivers.pdf" target="_blank" rel="noopener"><em>essential linux device drivers</em></a>）：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc4/block-pc.jpeg" alt="system" title="">                </div>                <div class="image-caption">system</div>            </figure></p><p>经过抽象，引入<code>device</code>、<code>device_driver</code>、<code>bus_type</code>这三个类；现实世界中device通过bus挂载到CPU上，device通过bus_type与device_driver联系起来。它们都声明在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/include/linux/device.h" target="_blank" rel="noopener">include/linux/device.h</a>中：</p><pre><code class="c">struct device {    ...    struct bus_type    *bus;    struct device_driver *driver;    ...};struct device_driver {    ...    /* 一堆函数指针 */    ...};struct bus_type {    ...    /* 一堆函数指针 */    ...};</code></pre><p>这三个类中最为复杂的是device类，另外两个类基本上是一些方法。下面罗列了它们一些简单的特性：</p><ul><li>device_driver和device都会注册到一个bus上。bus_type里面最重要的方法是<code>match()</code>，如果判断设备和驱动相匹配，将调用device_driver的<code>probe()</code>方法，交给device_driver来完成接下来的工作。</li><li>device_driver里的<code>probe()</code>方法也被称为驱动程序的入口，probe成功后设备将有一系列<code>file_operations</code>从而可以被应用程序访问，此时设备的实例就产生了。</li><li>device内有device指针和链表，让device之间形成一个树状结构去模拟现实系统中的情况；</li><li>device又有kobject，通过kobj的指针在<strong>sysfs</strong>里又形成一个树状结构；</li><li>device里还有of_node，对应到<strong>设备树</strong>上的节点。这又是一个树状结构；</li><li>device内有个struct class*，为了方便在sysfs将设备归类。</li></ul><p>device类集中了设备的属性，device_driver、bus_type等类集中了设备的操作；从面向对象的角度可以有数种解读，比如：</p><ul><li>device、device_driver、bus_type是相互独立的类；其中device依赖bus_type，device和device_driver之间是关联关系。这是一种合乎常理的理解，很多资料也从这个角度理解。</li><li>device是以device_driver、bus_type等为父类的<strong>多继承</strong>。要实例化一个device，先实例化父类driver和bus。这也是一个合理的解读角度。</li></ul><h4 id="平台设备、平台驱动、平台总线"><a href="#平台设备、平台驱动、平台总线" class="headerlink" title="平台设备、平台驱动、平台总线"></a>平台设备、平台驱动、平台总线</h4><p>PC上的设备大都接在PCI一类的总线上，可动态探索设备、动态分配地址空间、动态分配中断资源。这时总线的处理程序就可以动态生成device来与driver配对了。</p><p>但是对于像ARM这种将内存空间和设备空间统一编址的架构来说，很多设备并不挂载在可以动态探知设备的总线上，而是有固定的地址供CPU寻址。<strong>STM32所有外设都这样</strong>（当然也有不少ARM架构的SOC有PCI总线）。这些设备都叫<code>平台设备（platform device）</code>。为符合Linux设备模型，就专门造出了一个虚拟的总线叫<code>平台总线（platform bus)</code>，上面注册有平台设备与<code>平台驱动（platform driver）</code>。它们分别继承自device、bus_type、device_driver。</p><p>由于平台设备不能动态探知，所以内核应该事先知道这些设备，于是platform_device对象应该写死在内核里面。2.6.x内核里面就是这样干的。所以当年如果你要实现一个驱动，除了要实现platform_driver，还要在某一个地方定义一个static的platform_device（或者继承它的子类），然后在使用<code>MODULE_init()</code>宏修饰的构造函数里面注册driver和device（MODULE_init的工作方式是将一堆函数指针存到某一个section里，形成一个数组，以便内核初始化时候逐个调用）。</p><p>平台总线的match()方法，对比的是平台设备和平台驱动的<strong>name字段是否相同</strong>，以此来配对设备和驱动。比方说，我在一个地方定义一个设备：</p><pre><code class="c">static struct platform_device foo_device = {    .name        = &quot;foo&quot;,    ...};</code></pre><p>然后在另一个地方定义一个驱动：</p><pre><code class="c">static struct platform_driver foo_driver = {    .driver    = {        .name        = &quot;foo&quot;,    };    .probe = foo_probe,    ...};</code></pre><p>在构造函数里面注册设备和驱动：</p><pre><code class="c">// 在一个地方添加设备platform_add_devices(&amp;foo_device, 1);...// 在另一个地方添加驱动platform_driver_register(&amp;foo_driver);</code></pre><p>随后驱动中的foo_probe()函数将被调用。</p><p>有不少代码，driver定义在它驱动目录下的文件里，device或许又定义在板级初始化目录下的文件里面，显得相当随心所欲。如今内核中这种代码也还存在，比方说omap使用了<code>plat_nand</code>设备：<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/mtd/nand/plat_nand.c" target="_blank" rel="noopener">drivers/mtd/nand/plat_nand.c</a>里注册驱动，<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/mach-omap1/board-h2.c" target="_blank" rel="noopener">arch/arm/mach-omap1/board-h2.c</a>里面定义了nand flash的分区信息，并注册设备。</p><p>ARM架构片子浩如烟海，而且外设基本上都是平台设备，这导致内核里板级初始化部分相当混乱，充斥着长达数万行的静态声明的结构体和函数，又多又杂。这令Linus本人忍无可忍，终于<a href="https://lkml.org/lkml/2011/3/17/492" target="_blank" rel="noopener">在2011年3月17日将ARM社区臭骂一顿，斥其为痔疮（a f**king pain in the ass）</a>。经过激烈的讨论，ARM从内核3.x之后便引入<code>设备树</code>来代替代码里面的平台设备了。。。</p><h3 id="如何刻画一个设备？"><a href="#如何刻画一个设备？" class="headerlink" title="如何刻画一个设备？"></a>如何刻画一个设备？</h3><p>现在我们要用另一种机制来代替平台设备。它简单明了，并且运行时转化为平台设备。</p><p>一个设备就是一个<code>对象</code>，世间万物都是对象。每个对象拥有一系列<code>属性</code>，属性即是<code>名</code>和<code>值</code>的对应；现在<strong>不想声明类而直接把对象表达出来</strong>。</p><h4 id="可选用的语言"><a href="#可选用的语言" class="headerlink" title="可选用的语言"></a>可选用的语言</h4><p>假若我们要表达一个名字为”serial1”，波特率为115200的串口，当然现实世界的串口属性远不止这些，还有它寄存器组的地址、中断源、DMA通道、时钟源等等。</p><p>如果直接用c语言数据结构来表示的话，显然就要先声明一个类再实例化：</p><pre><code class="c">struct usart_struct {    const char *name;    unsigned baudrate;}usart = {    .name = &quot;serial1&quot;,    .baudrate = 115200,};</code></pre><p>因为设备实在太千奇百怪多种多样了，如果每一种芯片的外设都这么搞的话，那代码就相当臃肿了。其实不少语言都能直接<strong>随心所欲地</strong>定义对象，它们可有两种风格：</p><ul><li>标签式的风格，标签接标签，标签套标签。如XML：<pre><code class="xml">&lt;usart&gt;  &lt;name&gt;serial1&lt;/name&gt;  &lt;baudrate&gt;115200&lt;/baudrate&gt;&lt;/usart&gt;</code></pre></li><li>数据结构式的风格。如json：<pre><code class="json">{&quot;usart&quot;: {  &quot;name&quot;: &quot;serial1&quot;,  &quot;baudrate&quot;: 115200}}</code></pre></li></ul><p>其实，还真有一些工程的设备树就是json，<a href="https://github.com/xboot/xboot" target="_blank" rel="noopener">XBoot</a>就是这样。。。</p><p>Linux内核中，我们会用设备树来描述，其文件后缀是dts：</p><pre><code>/ {    usart:serial1@0 {        baudrate = &lt;115200&gt;;    };};</code></pre><p>看上去像极了json，因为它们都是数据结构式的风格。其实内核编译dts之前先过一遍c预处理器，所以可以使用各种宏定义，包含头文件等等。</p><p>除了单纯刻画出对象的属性，还得表达不同对象之间的关系。对于硬件设备而言可以有以下的例子：</p><ul><li><code>串口</code>和<code>时钟管理器</code>这两个设备体现了<code>依赖关系（dependency）</code>：串口依赖于时钟管理器产生时钟，初始化串口之前必须初始化时钟，初始化完时钟之后串口一般就不必理会时钟了；</li><li><code>串口</code>和<code>串口对应的GPIO</code>体现了<code>聚合关系（aggregation）</code>：串口可以包含一些GPIO，但是这些GPIO不依赖串口而存在（或者说这些GPIO还可以用于其他的外设），初始化时并不强制要求谁先谁后；</li><li><code>串口</code>等一系列外设和<code>SOC芯片</code>体现了<code>组合关系（composition）</code>：一系列外设组合成为SOC芯片；</li><li><code>串口</code>和<code>DMA</code>这两个设备体现的是一种比较通用的<code>关联关系（association）</code>：它们是独立的两个设备，并且相互知道对方的存在；</li></ul><p>如果要表达<code>组合关系</code>这种强烈的整体和局部的关系，那么直接把小的一方定义在大的一方之内就行了。但是如果两个对象比较独立，它们之间的关系就没有整体和局部那么的强烈，那么就需要有一个表达<code>引用</code>的语法，即在一个对象中去引用另一个对象，此时单纯的XML或者json就表达不出来了；而dts就可以表达出来。</p><h4 id="设备树基本语法"><a href="#设备树基本语法" class="headerlink" title="设备树基本语法"></a>设备树基本语法</h4><p>一张图就够了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc4/dts-basic.jpeg" alt="设备树基本语法" title="">                </div>                <div class="image-caption">设备树基本语法</div>            </figure></p><p>关注点是，</p><ul><li>语句末要加分号</li><li>在哪里定义该节点的名字（Node name，在花括号之前，<strong>label之后</strong>）</li><li>在哪里定义该外设寄存器组的地址（Unit address，@符号）</li><li>属性名和属性值怎么定义（Property name和Property value，等于号来连接）</li><li>布尔属性（没有写值，仅表示这个属性声明与否）</li><li>数组怎么定义（a-string-list-property，用逗号分割的值）</li><li>一个属性有多个值该怎么定义（a-cell-property，尖括号中空格分隔的值）</li><li><strong>标号怎么定义（Label，节点名字之前，用冒号）</strong></li><li><strong>怎么引用别的节点（phandel，&amp;符号）</strong></li></ul><p>dts文件里面的节点里，一系列同名的节点描述的都是同一个对象，它们的属性相互叠加，若有冲突，则以最后出现的描述为准，是谓“后来居上”。比方说在<strong>靠前</strong>的地方这样描述这个串口：</p><pre><code class="dts">/ {    soc {        ...        serial@40011000 {            status = &quot;disabled&quot;;            dma-names = &quot;rx&quot;, &quot;tx&quot;;            ...        };    };};</code></pre><p>然后在<strong>靠后</strong>的地方又这样描述一遍：</p><pre><code class="dts">/ {    soc {        // 记得要重新画一次设备树，然后        // 在相同的枝干下面写同名节点        serial@40011000 {            status = &quot;okay&quot;;        };    };};</code></pre><p>最后生成的效果是：</p><pre><code class="dts">/ {    soc {        ...        serial@40011000 {            status = &quot;okay&quot;;            dma-names = &quot;rx&quot;, &quot;tx&quot;;            ...        };    };};</code></pre><p>注意到，status属性被改为okay了。</p><p>特别要强调的是，如果要在两个文件里面这样干，那么两个文件里面都得画上<strong>结构相同的设备树</strong>，然后在<strong>相同的枝干上写同名的节点</strong>，这才有效。就像上面例子中画了两次设备树，在根节点下soc节点下重写了serial节点。这显然很麻烦。不过可以使用<code>标号</code>和<code>引用</code>来简化。</p><p>还有这种操作：拿STM32的设备树作为例子：<br>在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/boot/dts/stm32f429.dtsi#L422" target="_blank" rel="noopener">arch/arm/boot/dts/stm32f429.dtsi</a>里面这样定义串口：</p><pre><code class="dts">/ {    soc {        ...        // 跟上面相比，加了标号        usart1: serial@40011000 {            status = &quot;disabled&quot;;            dma-names = &quot;rx&quot;, &quot;tx&quot;;            ...        };    };};</code></pre><p>然后在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/arch/arm/boot/dts/stm32429i-eval.dts#L286" target="_blank" rel="noopener">arch/arm/boot/dts/stm32f429i-eval.dts</a>里面，include刚才那个设备树，接着使用标号改写这个节点：</p><pre><code class="dts">#include &lt;stm32f429.dtsi&gt;...// 直接引用那个标号就行了&amp;usart1 {    status = &quot;okay&quot;;};</code></pre><p>最后达到相同的效果。</p><h4 id="设备树对应到驱动程序"><a href="#设备树对应到驱动程序" class="headerlink" title="设备树对应到驱动程序"></a>设备树对应到驱动程序</h4><p>设备树会展开为平台设备，但是它并不通过name字段去与平台驱动相匹配，而是通过<code>compatible</code>属性与driver中的<code>compatible</code>相匹配。compatible都是一个字符串。<br>比方说STM32F429的串口在设备树中这样写：</p><pre><code class="c">usart1: serial@40011000 {    compatible = &quot;st,stm32-usart&quot;,         &quot;st,stm32-uart&quot;;    ...};</code></pre><p>在<a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/tty/serial/stm32-usart.c#L709" target="_blank" rel="noopener">drivers/tty/serial/stm32-usart.c</a>中这样定义compatible：</p><pre><code class="c">static const struct of_device_id stm32_match[] = {    { .compatible = &quot;st,stm32-usart&quot;, .data = &amp;stm32f4_info},    { .compatible = &quot;st,stm32-uart&quot;, .data = &amp;stm32f4_info},    { .compatible = &quot;st,stm32f7-usart&quot;, .data = &amp;stm32f7_info},    { .compatible = &quot;st,stm32f7-uart&quot;, .data = &amp;stm32f7_info},    {},};...static struct platform_driver stm32_serial_driver = {    .driver    = {        .of_match_table = of_match_ptr(stm32_match),    },    ...};</code></pre><p>设备树和驱动中的compatible字段都可以不只有一个，只要<strong>任何一个字符串相同</strong>，就可以匹配上了。</p><p>注意到<code>of_device_id</code>列表里面，每一个compatible项目都对应了一个data成员。驱动匹配上设备后，可以顺藤摸瓜找到相关的data，从而在一个驱动程序里面实现多个相似设备的驱动。</p><h4 id="“设备树绑定”，以及“设备树绑定”的文档"><a href="#“设备树绑定”，以及“设备树绑定”的文档" class="headerlink" title="“设备树绑定”，以及“设备树绑定”的文档"></a>“设备树绑定”，以及“设备树绑定”的文档</h4><p>设备树中应该描述哪些属性，属性值应该怎么设置？写BSP的程序员可以自由去定义，然后通过一系列设备树相关接口找到设备树中设置的值。比方说STM32的串口：</p><pre><code class="c">usart1: serial@40011000 {    compatible = &quot;st,stm32-usart&quot;,         &quot;st,stm32-uart&quot;;    reg = &lt;0x40011000 0x400&gt;;    interrupts = &lt;37&gt;;    clocks = &lt;&amp;rcc 0 STM32F4_APB2_CLOCK(USART1)&gt;;    dmas = &lt;&amp;dma2 2 4 0x400 0x0&gt;,           &lt;&amp;dma2 7 4 0x400 0x0&gt;;    dma-names = &quot;rx&quot;, &quot;tx&quot;;    pinctrl-0 = &lt;&amp;usart1_pins_a&gt;;    pinctrl-names = &quot;default&quot;;    status = &quot;okay&quot;;};</code></pre><p>它有各种属性，驱动程序里逐个查找这些属性的配置，比方说：</p><ul><li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/of/device.c#L24" target="_blank" rel="noopener">of_match_device()</a>通过匹配<code>compatible</code>，找到3.3中所述<code>of_device_id</code>表中对应项，以方便提取其对应的<code>data</code>，作为驱动程序里面自定义的<strong>私有数据</strong>。</li><li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/base/platform.c#L67" target="_blank" rel="noopener">platform_get_resource()</a>和<a href="https://elixir.bootlin.com/linux/v4.13.3/source/lib/devres.c#L134" target="_blank" rel="noopener">devm_ioremap_resource()</a>配对使用，提取出设备树节点的<code>reg</code>属性。</li><li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/base/platform.c#L87" target="_blank" rel="noopener">platform_get_irq()</a>提取<code>interrupts</code>属性。</li><li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/clk/clk-devres.c#L17" target="_blank" rel="noopener">devm_clk_get()</a>提取<code>clocks</code>属性。</li><li><a href="https://elixir.bootlin.com/linux/v4.13.3/source/drivers/dma/dmaengine.c#L752" target="_blank" rel="noopener">dma_request_slave_channel()</a>输入<code>dma-names</code>里某一个字符串，查找出对应的<code>dmas</code>属性。比方说通过”rx”找到&lt;&amp;dma2 2 4 0x400 0x0&gt;。</li></ul><p>这些属性可能的配置，以及处理这些配置的代码，<strong>综合起来叫<code>设备树绑定（devicetree bindings）</code></strong>。在源码<code>Documentation/devicetree/bindings/</code>目录下面罗列了一大堆<strong>描述设备树绑定的文档</strong>。</p><p>应该说，设备树绑定长什么样，这取决于程序员的设计；有不少属性的用途是“众所周知”的，比方说</p><ul><li>compatible属性用于匹配驱动</li><li>reg属性用于描述改外设接口寄存器的地址空间</li><li>pinctrl-0、pinctrl-names用于描述该外设对应到的GPIO</li><li><strong>status表示这个外设是否启用</strong></li></ul><p>有不少属性是该驱动所特有的，比方说，根据<a href="https://elixir.bootlin.com/linux/v4.13.3/source/Documentation/devicetree/bindings/serial/st,stm32-usart.txt" target="_blank" rel="noopener">Documentation/devicetree/bindings/serial/st,stm32-usart.txt</a>文档，还有一个<strong>布尔属性</strong>叫”st,hw-flow-ctrl”，表示是否启用USART的流控功能。</p><p><strong>设备树复杂的地方并不在于它的语法，而恰恰在于设备树绑定</strong>。不同的程序员写出的设备树绑定不尽相同，同一个外设在不同芯片中的设备树绑定相差甚远，甚至同名的属性功效完全不同。最典型的例子就是pinctrl了，它管GPIO引脚复用；换一款芯片、换一个BSP，或许也得重新学习一遍它的pinctrl。。。</p><p>所以，设备树仿佛变成了最不具有可移植性的那部分了。Linus顺利地将ARM芯片的混乱性，从板级初始化程序中成功转嫁到设备树绑定中去了，然后他仿佛就不管后事了。。。这也为人所诟病：Thomas Petazzoni在2015年的ELC会议上抱怨说：<a href="https://events.static.linuxfound.org/sites/events/files/slides/petazzoni-dt-as-stable-abi-fairy-tale.pdf" target="_blank" rel="noopener">不同内核里设备树绑定要保持可移植性，这简直是个神话</a>。他说，很多厂商推出的系列芯片，它们的数据手册并不存在（doesn’t exist），以至于社区的工程师们要发挥想象力猜测它的功能；不少外设寄存器设计得相当傻逼（stupid），有很多神秘而唐突的使能位叫人捉摸不透，要维护这些驱动简直是折磨。他举出了Marvell和全志的芯片作为反面例子：这些芯片手册又冇，上流社会又要设备树绑定的移植性好；又举出Atmel芯片作为正面例子：Atmel的数据手册流传甚广，但是Atmel的维护者明确地声明：我的设备树绑定不能保证移植性。<a href="https://www.youtube.com/watch?v=rPRqIS9q6CY" target="_blank" rel="noopener">油管视频在此</a>。</p><p>不管怎样，时至今日，ARM端的代码已经深刻地与设备树相耦合了。话说回来，设备树也是一个相当优雅的设计，或许这是应对ARM架构芯片纷繁复杂的驱动的最好解决方法了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲设备树的文章不少。以下是一些挺有意思的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.wowotech.net/device_model/why-dt.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蜗窝科技的博客&lt;/a&gt;紧扣Linux内核来讲设备树的来历与用法；&lt;/li&gt;
&lt;li&gt;Thomas Petazzoni是Bootlin公司（以前叫Free Electrons，一家很有水平的专注Linux的法国公司）的CTO，他写过一份讲义叫&lt;a href=&quot;https://bootlin.com/pub/conferences/2013/elce/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《傻瓜都懂的设备树》&lt;/a&gt;，详细地介绍了设备树的语法与Linux内核中现实的用例；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://elinux.org/images/0/0c/Rowand--devicetree_kernel_internals.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;device tree kernel internals&lt;/a&gt;这篇报告更加详细地描述了设备树的语法、编译过程，并分析了设备树展开过程的一些源码；&lt;/li&gt;
&lt;li&gt;还是Thomas Petazzoni，他在2015年的ELC会议上抱怨说：&lt;a href=&quot;https://events.static.linuxfound.org/sites/events/files/slides/petazzoni-dt-as-stable-abi-fairy-tale.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不同内核里设备树接口要保持可移植性，这简直是个神话&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多介绍设备树的文章都会开门见山地介绍设备树的各种概念，然后罗列出设备树的语法。&lt;strong&gt;不过很少有人会从头到尾讲透驱动程序和设备树，然后旗帜鲜明地指出，设备树描述的就是平台设备（platform_device），或许他们默认了你已经懂得那些前提知识&lt;/strong&gt;。以下记录了我的一些思考，尝试从&lt;code&gt;面向对象&lt;/code&gt;的角度去切入。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（手机请横屏看代码）&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[3] 板子验证与bootloader移植</title>
    <link href="http://yoursite.com/ucpc3/"/>
    <id>http://yoursite.com/ucpc3/</id>
    <published>2018-02-28T16:23:39.000Z</published>
    <updated>2019-04-27T15:24:04.403Z</updated>
    
    <content type="html"><![CDATA[<p>稍微复杂一点的的嵌入式系统，底层初始化和操作系统的引导都由bootloader完成。bootloader可以很简单，只需要将内存初始化好、将操作系统加载好就行；也可以比较复杂，比如大名鼎鼎的<a href="http://www.denx.de/wiki/U-Boot/" target="_blank" rel="noopener">u-boot</a>，或者不那么有名的<a href="https://www.barebox.org/" target="_blank" rel="noopener">barebox</a>等等，都有大量的功能，管理着大量的外设，可以从各种各样的地方启动系统（flash、SD卡、U盘、网络服务器等等），并且有一个简单的或许可以跑脚本的shell。相当复杂的bootloader比如BIOS、UEFI等等甚至都有图形界面，能键盘鼠标操作。</p><p>对于我们的板子而言，只需要启动存储在片内flash的Linux就够了，所以bootloader只需要初始化好内存，然后直接跳转到Linux。但是为了初步验证板子各部分的功能，首先应该跑通一个比较完整的uboot；所幸的是，github上有人为stm32f429-disc移植了uboot，驱动已经十分全面，剩下的就是要细心地改GPIO口，并且查漏补缺。</p><ul><li><a href="https://github.com/hhuysqt/afboot-stm32" target="_blank" rel="noopener">afboot-stm32</a>是专为STM32板子上启动Linux的最小bootloader；</li><li><a href="https://github.com/robutest/u-boot" target="_blank" rel="noopener">这个版本的uboot</a>已移植到了429 discovery；</li></ul><p><em>（手机请横屏看代码）</em><br><a id="more"></a></p><h3 id="uboot改动"><a href="#uboot改动" class="headerlink" title="uboot改动"></a>uboot改动</h3><p>这个uboot是老版本的，没有引入kbuild，配置板子靠的是<code>include/configs/</code>下面一系列头文件里面的宏定义。这里直接沿用<code>include/configs/stm32429-disco.h</code>的配置头文件。</p><h4 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h4><p>改配置文件即可。将其配置为168MHz：</p><pre><code class="c">#define CONFIG_STM32_SYS_CLK_PLL#define CONFIG_STM32_PLL_SRC_HSE#define CONFIG_STM32_HSE_HZ 25000000#define CONFIG_STM32_PLL_M  25#define CONFIG_STM32_PLL_N  336#define CONFIG_STM32_PLL_P  2#define CONFIG_STM32_PLL_Q  7</code></pre><p>其实，不管外面的晶振频率几何，进PLL第一步就是将频率分频降为1MHz，然后再倍频。这里倍频到336MHz。然后2分频为168MHz到HCLK，7分频为48MHz给USB。</p><h4 id="SDRAM初始化"><a href="#SDRAM初始化" class="headerlink" title="SDRAM初始化"></a>SDRAM初始化</h4><p>在<code>cpu/arm_cortexm3/stm32/fmc.c</code>里，首先修改<code>ext_ram_fmc_gpio</code>数组中的引脚。</p><p>然后<code>ExtMemInit()</code>函数里面改内存时序参数：</p><pre><code class="c">// burst, 84MHz, CAS=2, 4 banks, 16 bits data, 13 bit RA, 10 bit CASTM32_FMC_DRAM-&gt;sdcr[0] = 0x0000195A;// TRCD=2, TRP=2, TWR=2, TRC=6, TRAS=4, TXSR=6, TMRD=2STM32_FMC_DRAM-&gt;sdtr[0] = 0x01115351;</code></pre><p>内存<code>MRS</code>和刷新频率设置。</p><pre><code class="c">// single write burst, CAS = 2, burst length = 2STM32_FMC_DRAM-&gt;sdcmr = 0x00044214;STM32_FMC_DRAM-&gt;sdrtr = ((636*8) &lt;&lt; 1);</code></pre><p>SDRAM的MRS设置都是通用的，可参考<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory" target="_blank" rel="noopener">这个wiki</a>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc3/sdrammrs.jpeg" alt="SDRAM的MRS设置" title="">                </div>                <div class="image-caption">SDRAM的MRS设置</div>            </figure></p><p>最后是<strong>SDRAM</strong>重定位！原本SDRAM bank1的地址是0xC0000000以上的，在所谓<code>片外外设区</code>里，按照ARM的意思是不可以执行代码的；STM32可以通过<code>SYSCFG</code>寄存器将它重定位到0x80000000以及0x00000000地址上，就可以在上面执行代码了。不过诡异的是，我的429 discovery板子即使不重定位也能执行代码，但是我买的芯片不重定位就不能执行代码（会引发busfault）。</p><pre><code class="c">/* * Remapping SDRAM bank1 to 0x80000000 and 0x00000000 */STM32_RCC-&gt;apb2enr  |= ((uint32_t)0x00004000);STM32_SYSCFG-&gt;memrmp = ((uint32_t)0x00000404);</code></pre><h5 id="uboot启动之后。。。"><a href="#uboot启动之后。。。" class="headerlink" title="uboot启动之后。。。"></a>uboot启动之后。。。</h5><p>可以用一系列内存读写的命令测试SDRAM是否安好：</p><pre><code>STM32429-DISCO&gt; md 0x8000000080000000: 00000000 00000000 00000000 00000000    ................80000010: 00000000 00000000 00000000 00000000    ................80000020: 00000000 00000000 00000000 00000000    ................80000030: 00000000 00000000 00000000 00000000    ...................STM32429-DISCO&gt; mw 0x80000000 0x12348765 4STM32429-DISCO&gt; mw 0x80000010 0x87654321 4STM32429-DISCO&gt; md 0x80000000             80000000: 12348765 12348765 12348765 12348765    e.4.e.4.e.4.e.4.80000010: 87654321 87654321 87654321 87654321    !Ce.!Ce.!Ce.!Ce.80000020: 00000000 00000000 00000000 00000000    ................80000030: 00000000 00000000 00000000 00000000    ...................</code></pre><p>如果读写数据不对，那么多半是芯片没焊好。。简单测得SDRAM顺序读写速度约70MB每秒。</p><h4 id="增加nand-flash驱动"><a href="#增加nand-flash驱动" class="headerlink" title="增加nand-flash驱动"></a>增加nand-flash驱动</h4><p>首先在SDRAM初始化完成之后，顺便初始化nand flash：</p><pre><code class="c">// ECC 2k, TAR=TCLR=1, ECC disable, 8 bits, NAND flash, wait featureSTM32_FMC_NAND-&gt;pcrx  = 0x00060008;// SET = 2, WAIT = 4, HOLD = 2, HIZ = 2STM32_FMC_NAND-&gt;pmemx = 0x02020402;STM32_FMC_NAND-&gt;pattx = 0x02020402;// enable NAND bankSTM32_FMC_NAND-&gt;pcrx |= 0x00000004;</code></pre><p>然后，自行添加必要函数。我在<code>drivers/mtd/nand/stm32_nand.c</code>里面添加：</p><pre><code class="c">#define FSMC_NAND_REG_DATA ((volatile uint8_t*)0x70000000)#define FSMC_NAND_REG_CMD  ((volatile uint8_t*)0x70010000)#define FSMC_NAND_REG_ADDR ((volatile uint8_t*)0x70020000)#define GPIOD_IDR ((volatile uint32_t*)0x40020c10)static void fmc_send_cmd(struct mtd_info *mtd, int cmd, unsigned int ctrl){    (void)mtd;    if(cmd != NAND_CMD_NONE) {        if(ctrl &amp; NAND_CLE)            *FSMC_NAND_REG_CMD = (uint8_t)cmd;        else if(ctrl &amp; NAND_ALE)            *FSMC_NAND_REG_ADDR = (uint8_t)cmd;    }}static int fmc_read_rb(struct mtd_info *mtd){    (void)mtd;    // read PD6 for BUSY    return *GPIOD_IDR &amp; (1L &lt;&lt; 6);}</code></pre><p>其实STM32的nand flash控制器并没有忙的标志，所以只好读GPIO的忙电平；ST官方例程也是这么干的。。</p><p>随后，向MTD层注册上面的两个函数：</p><pre><code class="c">int board_nand_init(struct nand_chip *nand){    // 设置读写寄存器的地址    nand-&gt;IO_ADDR_R = nand-&gt;IO_ADDR_W = FSMC_NAND_REG_DATA;    // 设置那两个函数    nand-&gt;cmd_ctrl = fmc_send_cmd;    nand-&gt;dev_ready = fmc_read_rb;    // 软件ECC    nand-&gt;ecc.mode = NAND_ECC_SOFT;    // 指定位宽：8位    nand-&gt;options = 0;    return 0;}</code></pre><p>最后，在配置文件里面添加nand命令的宏定义：</p><pre><code class="c">#define CONFIG_CMD_NAND#define CONFIG_NAND_STM32_UCPC#define CONFIG_MTD_DEVICE#define CONFIG_SYS_MAX_NAND_DEVICE  1#define CONFIG_SYS_NAND_BASE 0x70000000</code></pre><p>自定义了<code>CONFIG_NAND_STM32_UCPC</code>这个宏，为的是在<code>drivers/mtd/nand/Makefile</code>里面添加这个自己写的stm32_nand.c：</p><pre><code>COBJS-$(CONFIG_NAND_STM32_UCPC) += stm32_nand.o</code></pre><h5 id="nand效果"><a href="#nand效果" class="headerlink" title="nand效果"></a>nand效果</h5><p>可以看到识别到nand：</p><pre><code>U-Boot 2010.03-00003-g934021a-dirty (11月 07 2017 - 14:27:07) CPU  : STM32F4 (Cortex-M4)Freqs: SYSCLK=168MHz,HCLK=168MHz,PCLK1=42MHz,PCLK2=84MHzBoard: STM32F429I-DISCOVERY board,Rev 1.0DRAM:  64 MB                 NAND:  128 MiB</code></pre><p>可以用nand系列的命令去读写nand flash。下面罗列一些常用的命令：</p><p>查看nand信息：</p><pre><code>STM32429-DISCO&gt; nand infoDevice 0: nand0, sector size 128 KiB</code></pre><p>查看坏块：</p><pre><code>STM32429-DISCO&gt; nand badDevice 0 bad blocks:  000e0000  00140000  001a0000  001e0000  00200000  00240000  002e0000  04f20000  07fa0000</code></pre><p>擦除：</p><pre><code>STM32429-DISCO&gt; nand erase 0NAND erase: device 0 whole chip  Skipping bad block at  0x000e0000Skipping bad block at  0x00140000Skipping bad block at  0x001a0000Skipping bad block at  0x001e0000Skipping bad block at  0x00200000Skipping bad block at  0x00240000Skipping bad block at  0x002e0000Skipping bad block at  0x04f20000Skipping bad block at  0x07fa0000Erasing at 0x7fe0000 -- 100% complete.OK</code></pre><p>写入第一个扇区：</p><pre><code>STM32429-DISCO&gt; md 0x80000000             80000000: 12348765 12348765 12348765 12348765    e.4.e.4.e.4.e.4.80000010: 87654321 87654321 87654321 87654321    !Ce.!Ce.!Ce.!Ce.80000020: 00000000 00000000 00000000 00000000    ................80000030: 00000000 00000000 00000000 00000000    ...................STM32429-DISCO&gt; nand write 0x80000000 0 800NAND write: device 0 offset 0x0, size 0x800 2048 bytes written: OK</code></pre><p>dump一下刚刚写入的东西：</p><pre><code>STM32429-DISCO&gt; nand dump 0Page 00000000 dump:    65 87 34 12 65 87 34 12  65 87 34 12 65 87 34 12    21 43 65 87 21 43 65 87  21 43 65 87 21 43 65 87    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00...</code></pre><p>读一下第一个扇区：</p><pre><code>STM32429-DISCO&gt; nand read 0x80000000 0 800     NAND read: device 0 offset 0x0, size 0x800 2048 bytes read: OKSTM32429-DISCO&gt; md 0x80000000             80000000: 12348765 12348765 12348765 12348765    e.4.e.4.e.4.e.4.80000010: 87654321 87654321 87654321 87654321    !Ce.!Ce.!Ce.!Ce.80000020: 00000000 00000000 00000000 00000000    ................80000030: 00000000 00000000 00000000 00000000    ...................</code></pre><h4 id="LTDC显示接口"><a href="#LTDC显示接口" class="headerlink" title="LTDC显示接口"></a>LTDC显示接口</h4><p>原有的驱动在<code>cpu/arm_cortexm3/stm32/disp.c</code>这里。</p><p>首先，改<code>ext_tft_gpio</code>数组里定义的GPIO。需要注意的是，GPIO有两个AF对应到LTDC，分别是<code>AF9</code>和<code>AF14</code>；要老老实实翻<a href="http://www.st.com/content/ccc/resource/technical/document/datasheet/03/b4/b2/36/4c/72/49/29/DM00071990.pdf/files/DM00071990.pdf/jcr:content/translations/en.DM00071990.pdf" target="_blank" rel="noopener">DS9405</a>数据手册来检查。</p><p>然后，因为429 discovery板子上有个液晶屏，其控制芯片需要通过SPI来初始化；但是uc-PC上并不用这样做，只要有RGB信号就行（称为<code>哑显示</code>）；所以将<code>LCD_SPI</code>、<code>lcd_init()</code>等相关内容删去。</p><p>最后，配置时序，使之适合标准VGA时序。设置的行列信号依据就是下图两个红框的参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc3/vgatiming.jpeg" alt="640x480@60Hz VGA时序" title="">                </div>                <div class="image-caption">640x480@60Hz VGA时序</div>            </figure><br>可以对比VGA时序图以及LTDC的时序图。下图是VGA的时序图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc3/vgatiming2.jpeg" alt="640x480@60Hz VGA时序" title="">                </div>                <div class="image-caption">640x480@60Hz VGA时序</div>            </figure></p><p>下图是LTDC的时序图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc3/ltdctiming.jpeg" alt="LTDC时序图" title="">                </div>                <div class="image-caption">LTDC时序图</div>            </figure></p><p>最终设置的LTDC寄存器如下。首先是时钟配置，像素时钟设为25MHz：</p><pre><code class="c">// Configure PLLSAI prescalers for LCD// Enable Pixel Clock// PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 Mhz// PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAI_N = 200 Mhz// PLLLCDCLK = PLLSAI_VCO Output/PLLSAI_R = 200/4 = 50 Mhz// LTDC clock frequency = PLLLCDCLK / RCC_PLLSAIDivR = 50/2 = 25 MhzSTM32_RCC-&gt;pllsaicfgr = (204 &lt;&lt; 6) | (7 &lt;&lt; 24) | (4 &lt;&lt; 28);STM32_RCC-&gt;dckcfgr &amp;= ~0x00030000;STM32_RCC-&gt;dckcfgr |=  0x00000000;      // /2// Enable PLLSAI Clock*((volatile uint32_t *)CR_PLLSAION_BB) = 1;// Wait for PLLSAI activationwhile ((STM32_RCC-&gt;cr &amp; 0x20000000) == 0);</code></pre><p>然后是VGA时序的设置：</p><pre><code class="c">STM32_LTDC-&gt;sscr = ((96) &lt;&lt; 16)           | (2);STM32_LTDC-&gt;bpcr = ((96+48) &lt;&lt; 16)        | (2+33);STM32_LTDC-&gt;awcr = ((96+48+640) &lt;&lt; 16)    | (2+33+480); // 640 x 480STM32_LTDC-&gt;twcr = ((96+48+640+16) &lt;&lt; 16) | (2+33+480+10);</code></pre><p>只用LAYER1。主要是设置640x480的窗口，以及<code>帧缓存</code>的地址：</p><pre><code class="c">STM32_LTDC_LAYER1-&gt;whpcr  = ((95+48+641) &lt;&lt; 16) | (95+48+2);STM32_LTDC_LAYER1-&gt;wvpcr  = ((1+33+480) &lt;&lt; 16) | (1+33);STM32_LTDC_LAYER1-&gt;pfcr   = 2;  // RGB565...STM32_LTDC_LAYER1-&gt;cfbar  = FBAddr; // 帧缓存地址...</code></pre><p>最后使能LTDC。</p><h5 id="显示器效果。"><a href="#显示器效果。" class="headerlink" title="显示器效果。"></a>显示器效果。</h5><p>接上一个显示器，然后用内存读写命令来往<code>帧缓存</code>里面写入像素值。比方说帧缓存地址是0x80400000，则可以：</p><pre><code>STM32429-DISCO&gt; mw 80400000 f800f800 5000STM32429-DISCO&gt; mw 80414000 07e007e0 5000STM32429-DISCO&gt; mw 80428000 001f001f 5000STM32429-DISCO&gt; mw 8043c000 f81ff81f 5000STM32429-DISCO&gt; mw 80450000 ffe0ffe0 5000STM32429-DISCO&gt; mw 80464000 07ff07ff 5000STM32429-DISCO&gt; mw 80478000 ffffffff 5000</code></pre><p>分别是红绿蓝以及组合颜色。显示效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc3/vgaout.jpg" alt="VGA显示效果" title="">                </div>                <div class="image-caption">VGA显示效果</div>            </figure></p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>首先在配置文件里面使能网络命令：</p><pre><code class="c">#define  CONFIG_CMD_NET#define  CONFIG_NET_MULTI#define  CONFIG_STM32_ETH#define  CONFIG_STM32_ETH_RMII</code></pre><p>然后在<code>drivers/net/stm32_eth.c</code>里面更改GPIO。包括在<code>mac_gpio</code>里面修改RMII的GPIO，<strong>以及以太网复位的GPIO</strong>。然后其他可以照旧。</p><h5 id="在上位机上搭建tftp服务器"><a href="#在上位机上搭建tftp服务器" class="headerlink" title="在上位机上搭建tftp服务器"></a>在上位机上搭建tftp服务器</h5><ul><li>如果上位机上运行着Ubuntu，则可以直接通过包管理安装tftp服务器：<pre><code class="bash">$ sudo apt-get install tftp-hpa tftpd-hpa</code></pre></li><li>新建你的tftp目录，修改权限+rw（或者直接设为777，反正没人攻击你）。</li><li>更改配置文件/etc/default/tftpd-hpa<pre><code>TFTP_DIRECTORY=&quot;&lt;那个目录&gt;&quot;</code></pre></li><li>重启服务：<pre><code class="bash">$ sudo service tftpd-hpa restart</code></pre></li></ul><h5 id="网卡效果。"><a href="#网卡效果。" class="headerlink" title="网卡效果。"></a>网卡效果。</h5><p>可以看到识别到STM32的mac：</p><pre><code>U-Boot 2010.03-00003-g934021a-dirty (11月 07 2017 - 14:27:07)CPU  : STM32F4 (Cortex-M4)Freqs: SYSCLK=168MHz,HCLK=168MHz,PCLK1=42MHz,PCLK2=84MHzBoard: STM32F429I-DISCOVERY board,Rev 1.0DRAM:  64 MBNAND:  128 MiBUsing default environmentNet:   STM32_MACHit any key to stop autoboot:  0 STM32429-DISCO&gt; </code></pre><p>下载之前，板子要设置3个环境变量：随便设置一个mac地址、本机静态IP地址，以及tftp服务器的IP地址</p><pre><code>setenv ethaddr C0:B1:3D:88:88:89setenv ipaddr 192.168.1.100setenv serverip 192.168.1.177</code></pre><p>然后，在上位机将镜像复制到你的tftp目录下面，在板子上通过<code>tftp</code>命令下载镜像：</p><pre><code>STM32429-DISCO&gt; tftp 81000000 xipImageAuto-negotiation...completed.STM32_MAC: link UP (100/Full)Using STM32_MAC deviceTFTP from server 192.168.1.177; our IP address is 192.168.1.100Filename &#39;xipImage&#39;.Load address: 0x81000000Loading: #################################################################         ##################################################doneBytes transferred = 1685760 (19b900 hex)STM32429-DISCO&gt; </code></pre><p>可见已经下载成功了。</p><p>其实网卡的驱动、协议栈都已经相当成熟，如果出现问题，多半是网卡没焊好。。。或者是忘记拉高网卡的RESET引脚了。这些都会造成网卡的50MHz参考时钟没输出，而STM32的mac时钟是靠外面网卡输入的，没时钟的话就会说，mac不能复位。</p><h4 id="跳转Linux"><a href="#跳转Linux" class="headerlink" title="跳转Linux"></a>跳转Linux</h4><p>uboot编译完后，会在<code>tools/</code>目录下面生成一个<code>mkimage</code>工具，用它来将Linux镜像打包成<code>uImage</code>镜像。uboot的<code>bootm</code>命令只能启动uImage镜像。调试时候可以用tftp命令下载镜像，甚至用jlink直接下载到内存，不过后者的下载速度比较慢。</p><p>如果像我那样懒得每次调试要敲一遍mkimage的话，可以直接使用<code>go</code>命令跳转到内核。不过这个版本的go命令传参有些问题，需要修改<code>common/cmd_boot.c</code>的<code>do_go_exec</code>函数。</p><p>给STM32支持设备树的Linux内核要传3个参数，<code>R0</code>设为0，<code>R1</code>设为0xffffffff，<code>R2</code>设为设备树的地址。函数调用时候依次传参就行。或者简单起见，将那些地址写死也行。</p><p>另外值得一提的是，在SDRAM里面跑Linux内核性能简直感人，而且如果根文件系统挂载的是nfs，STM32芯片以及SDRAM芯片都会有点烫手——外设火力全开之后功耗真高。。。</p><h3 id="afboot-stm32"><a href="#afboot-stm32" class="headerlink" title="afboot-stm32"></a>afboot-stm32</h3><p>afboot-stm32是专门启动STM32上面Linux系统的最小bootloader，编译完之后大小只有2kb左右。Linux内核跑在片内flash里面，性能远胜于跑在SDRAM里。</p><p>原版的afboot已经移植到429 discovery上，对于uc-PC来说，需要修改GPIO引脚、修改SDRAM初始化、增加nand flash初始化、增加LTDC初始化。这些东西都与上文详述的uboot移植过程大同小异，不再赘述。况且afboot中所有的初始化都写在同一个c文件里面，改起来也相当方便。</p><h4 id="跳转Linux-1"><a href="#跳转Linux-1" class="headerlink" title="跳转Linux"></a>跳转Linux</h4><p><code>start_kernel.c</code>里面是最终跳转到Linux的代码，很简单，就一个跳转。</p><p>按照afboot的逻辑，bootloader烧写在片内flash第一个扇区里面（0～16k），然后设备树烧写在第二个扇区（16~32k），剩下的所有空间都留给Linux内核。但是新的内核里设备树越来越庞大，以至于超过了一个扇区的16k大小，如果接着占用下一个扇区就要多占用32k了。所以最好便是设备树紧挨着afboot，一同放在头两个扇区里面。为此start_kernel.c更改如下：</p><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;extern unsigned int _end_text;extern unsigned int _start_data;extern unsigned int _end_data;void start_kernel(void){        void (*kernel)(uint32_t reserved, uint32_t mach, uint32_t dt) = (void (*)(uint32_t, uint32_t, uint32_t))(KERNEL_ADDR | 1);        /* the DTB is just after the bootloader */        kernel(0, ~0UL, (uint32_t)&amp;_end_text + (uint32_t)&amp;_end_data - (uint32_t)&amp;_start_data);}</code></pre><p>其中，_end_text、_start_data、_end_data都是在链接脚本<code>stm32f429.lds</code>里面定义的，分别是代码段的末端、存储在flash里面的数据段的首末两端的地址。</p><pre><code>.text :{  /*. = ALIGN(4);*/  _end_text = .;} &gt;FLASH.data : {  _start_data = .;  *(.data)  _end_data = .;} &gt;SRAM1 AT &gt;FLASH </code></pre><p>所以设备树的地址就是<code>_end_text + _end_data - _start_data</code>了。</p><p>afboot和内核编译之后，用下面的命令将bootloader和设备树组合到<code>loader.bin</code>一个文件里面：</p><pre><code class="bash">$ cat stm32429i-ucpc.bin \  内核/arch/arm/boot/dts/stm32f429-disco.dtb \  &gt; loader.bin$ ls loader.bin -l-rw-r--r-- 1 hyq hyq 19057 2月  10 18:24 loader.bin</code></pre><p>一共约18kb，能烧进前32kb的空间里面。</p><p>另外内核里有个<code>CONFIG_ARM_APPENDED_DTP</code>的配置，解释为专门将dtb接到zImage后面，但“并不推荐在正式产品中使用”，于是就没做这种尝试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;稍微复杂一点的的嵌入式系统，底层初始化和操作系统的引导都由bootloader完成。bootloader可以很简单，只需要将内存初始化好、将操作系统加载好就行；也可以比较复杂，比如大名鼎鼎的&lt;a href=&quot;http://www.denx.de/wiki/U-Boot/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;u-boot&lt;/a&gt;，或者不那么有名的&lt;a href=&quot;https://www.barebox.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;barebox&lt;/a&gt;等等，都有大量的功能，管理着大量的外设，可以从各种各样的地方启动系统（flash、SD卡、U盘、网络服务器等等），并且有一个简单的或许可以跑脚本的shell。相当复杂的bootloader比如BIOS、UEFI等等甚至都有图形界面，能键盘鼠标操作。&lt;/p&gt;
&lt;p&gt;对于我们的板子而言，只需要启动存储在片内flash的Linux就够了，所以bootloader只需要初始化好内存，然后直接跳转到Linux。但是为了初步验证板子各部分的功能，首先应该跑通一个比较完整的uboot；所幸的是，github上有人为stm32f429-disc移植了uboot，驱动已经十分全面，剩下的就是要细心地改GPIO口，并且查漏补缺。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hhuysqt/afboot-stm32&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;afboot-stm32&lt;/a&gt;是专为STM32板子上启动Linux的最小bootloader；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/robutest/u-boot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个版本的uboot&lt;/a&gt;已移植到了429 discovery；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;（手机请横屏看代码）&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[2] 硬件设计</title>
    <link href="http://yoursite.com/ucpc2/"/>
    <id>http://yoursite.com/ucpc2/</id>
    <published>2018-02-27T12:26:57.000Z</published>
    <updated>2019-04-27T15:25:41.144Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引脚与外设分配"><a href="#引脚与外设分配" class="headerlink" title="引脚与外设分配"></a>引脚与外设分配</h3><p>利用<a href="http://www.st.com/en/development-tools/stm32cubemx.html" target="_blank" rel="noopener">STM32CubeMX</a>的引脚自动分配功能，前期准备工作方便了不少：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/cubemx.jpeg" alt="stm32cubemx" title="">                </div>                <div class="image-caption">stm32cubemx</div>            </figure></p><a id="more"></a><p>选择了：</p><ul><li>FMC SDRAM bank1，16位数据线，13位地址线</li><li>FMC nand flash bank2，8位总线</li><li>RMII接口</li><li>LTDC接口配置为RGB565</li><li>DCMI接口</li><li>DAC1、DAC2</li><li>USB1-fs、USB2-fs</li><li>SDIO，4位数据线</li><li>SWD调试接口</li><li>USART1<br>引脚所剩无几；再加上4个LED吧。</li></ul><p>之所以选择SDRAM的第一个bank（而不是像stm32f429-disc1那样在第二个bank），是因为据参考手册，这个bank可以重定位到0地址，在上面跑代码时候就能使用ICode总线从而提高性能。而且stm32429-eval评估板也这么干。不过我试验感觉并没有效果，可能瓶颈就是SDRAM的带宽了吧。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/remap.jpeg" alt="参考手册建议将SDRAM bank1重定位到0地址" title="">                </div>                <div class="image-caption">参考手册建议将SDRAM bank1重定位到0地址</div>            </figure></p><h3 id="KiCad布线工具"><a href="#KiCad布线工具" class="headerlink" title="KiCad布线工具"></a>KiCad布线工具</h3><p><a href="http://kicad-pcb.org/" target="_blank" rel="noopener">KiCad</a>这个开源的布线工具一点都不含糊，功能相当齐全，元件库相当华丽而齐全，运行起来也相当流畅（个人感觉比AD流畅多了）。<a href="http://kicad-pcb.org/download/ubuntu/" target="_blank" rel="noopener">Ubuntu下安装</a>要通过kicad的ppa源，下载过程相当慢；Debian的话它的软件源里面就有了。照着<a href="http://docs.kicad-pcb.org/stable/en/getting_started_in_kicad.html" target="_blank" rel="noopener">Getting Started</a>文档走一遍，可以一小时之内上手kicad。</p><h4 id="一个大坑"><a href="#一个大坑" class="headerlink" title="一个大坑"></a>一个大坑</h4><p>kicad的<code>CvPcb</code>用来为原理图的元件分配PCB的封装，它默认PCB封装库从github上下载，于是每一次启动CvPcb时候都要从网上下载那上百个封装库，这时候整个kicad都卡死了。所以先要将其设置为本地的库文件；记得要跑到<code>pcbnew</code>里面设置。。。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/pathsetting.jpeg" alt="设置本地库文件" title="">                </div>                <div class="image-caption">设置本地库文件</div>            </figure></p><p>然后将所有github的链接删掉，点击<code>Append with Wizard</code>，一个个用鼠标添加库文件。。。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/pathsetting2.jpeg" alt="添加本地库文件" title="">                </div>                <div class="image-caption">添加本地库文件</div>            </figure></p><h4 id="交互式布线"><a href="#交互式布线" class="headerlink" title="交互式布线"></a>交互式布线</h4><p>kicad手工拖线的体验相当不错。按<code>F11</code>快捷键可以切换到<code>OpenGL模式</code>，马上视觉效果就不简陋了，而且此时布线是<code>interactive</code>的，拖线时候会避开无关的net。</p><p>有些人用kicad画出来的板子走线就跟用protel99se画的那样不整齐，或许是因为他不知道<strong><em>还有一个很难找到的快捷键</em></strong>。kicad能像AD那样调整一批线和过孔，方法如下：在OpenGL的布线状态下，按着<code>Ctrl</code>键去然后拖拽之前布好的线或过孔，调整时附近的其他线与过孔都能够避开。这样来调整线路，kicad也能布出非常规整的线路来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/dragging.jpeg" alt="调整一批已布好的线" title="">                </div>                <div class="image-caption">调整一批已布好的线</div>            </figure><h4 id="有一个bug"><a href="#有一个bug" class="headerlink" title="有一个bug"></a>有一个bug</h4><p>目前kicad在铺铜时候，能正确避开不同net的焊盘、线、过孔等，但是不会避开不同net的铺铜。因此同一层中不同net的铺铜不能重叠。</p><h3 id="STM32主控"><a href="#STM32主控" class="headerlink" title="STM32主控"></a>STM32主控</h3><p>ST官网上的手册分为<code>数据手册（DS开头的）</code>、<code>应用手册（AN开头的）</code>、<code>参考手册（RM开头的）</code>等多种手册。对于STM32F429，</p><p><a href="http://www.st.com/content/ccc/resource/technical/document/datasheet/03/b4/b2/36/4c/72/49/29/DM00071990.pdf/files/DM00071990.pdf/jcr:content/translations/en.DM00071990.pdf" target="_blank" rel="noopener">DS9405</a>数据手册给出了电气特性、引脚定义、外设概况等信息。<br><a href="http://www.st.com/content/ccc/resource/technical/document/application_note/76/f9/c8/10/8a/33/4b/f0/DM00115714.pdf/files/DM00115714.pdf/jcr:content/translations/en.DM00115714.pdf" target="_blank" rel="noopener">AN4488</a>应用手册给了详细的硬件设计提示。<br><a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/3d/6d/5a/66/b4/99/40/d4/DM00031020.pdf/files/DM00031020.pdf/jcr:content/translations/en.DM00031020.pdf" target="_blank" rel="noopener">RM0090</a>参考手册给出了所有寄存器的详细解释和编程指南。</p><p>根据<a href="http://www.st.com/content/ccc/resource/technical/document/application_note/73/76/21/47/ef/d0/4c/16/DM00164538.pdf/files/DM00164538.pdf/jcr:content/translations/en.DM00164538.pdf" target="_blank" rel="noopener">AN4660</a>应用手册，LQFP176封装的stm32f429ix和stm32f767ix引脚兼容。</p><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>据说设计四层板的话，一般外层走线，内层构成完整的电源层。在主芯片每一个电源脚附近都要打过孔以确保电源连接，而且它们附近都要安排104滤波电容，这些电容一个都不能少焊：对于stm32的电源引脚很多的大芯片来说都要这样，否则可能会烧写不了程序。</p><p>LQFP176的片子有<code>BYPASS_REG</code>引脚，直接拉低则表示，使用片内的稳压器给内核供电，此时<code>VCAP1</code>和<code>VCAP2</code>外面都要接一个2.2uF左右的电容，这两个引脚将测得为1点几伏的内核电压。电容也不能省，否则接调试器时候可能识别不了芯片。<br><code>PDR_ON</code>引脚用于在刚上电时检测电源是否已达标（AN4488手册说，超过1.7V），以保证稳妥的启动。它直接拉到3V3就行。<br>复位引脚片内有上拉电阻，片外不用加上拉了，只需要在复位开关两端并联一个104电容即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/power.jpeg" alt="一些晦涩引脚的接法" title="">                </div>                <div class="image-caption">一些晦涩引脚的接法</div>            </figure></p><p>另外据说，铺铜后，应该在空闲的地方多打过孔，以便使得上下层铺铜连接更好。</p><h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h4><p>选择了25MHz的晶振。</p><p>板子上有3个部分需要时钟：STM32主芯片、以太网PHY芯片、摄像头。据<a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/3d/6d/5a/66/b4/99/40/d4/DM00031020.pdf/files/DM00031020.pdf/jcr:content/translations/en.DM00031020.pdf" target="_blank" rel="noopener">RM0090</a>参考手册，以太网的PHY芯片时钟源，可以直接用<code>MCO</code>引脚输出的STM32主芯片的晶振时钟。但是MCO1、MCO2引脚都距离RMII接口有点远，并且摄像头也要用时钟；摄像头用一个定时器输出时钟的话，设备树会写得非常绕。</p><p>为确保成功，STM32和以太网PHY都各自用一个25MHz的晶振，而摄像头就用MCO。3225无源晶振价格也不贵。</p><h4 id="原理图中优雅地分配net"><a href="#原理图中优雅地分配net" class="headerlink" title="原理图中优雅地分配net"></a>原理图中优雅地分配net</h4><p>STM32中同一个外设对应的GPIO引脚分布四方，然后很多人画原理图时候就整张图地翻找引脚、分配net，画的相当不方便，看原理图的人也很感觉很绕。</p><p>而ST官网发布的原理图就画的很清晰：主芯片的每个GPIO都有net，先不管它想用在哪个外设上面，GPIO原本是P几就设为P几；对于其他外接的芯片的引脚的net，先不管它准备接到STM32哪个GPIO上，该是什么功能就是什么功能；最后在一块单独的地方画一批平行线段，两端放net，GPIO对应到外设，一目了然。这种风格相当优雅。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/pins.jpeg" alt="原理图中清晰地分配外设GPIO" title="">                </div>                <div class="image-caption">原理图中清晰地分配外设GPIO</div>            </figure></p><h3 id="SDRAM和nand-flash"><a href="#SDRAM和nand-flash" class="headerlink" title="SDRAM和nand flash"></a>SDRAM和nand flash</h3><p>拆机的64MB SDRAM、128MB nand flash淘宝上很多，价格低廉；这些SDRAM一般是从远古时代的PC100/PC133的内存条上面拆下来的，跑起来感觉没问题（当然不能当工业级产品用）。低容量的nand flash是<a href="https://en.wikipedia.org/wiki/Multi-level_cell" target="_blank" rel="noopener">SLC</a>的，很耐擦写，回收的芯片里面顶多多了几个坏块，对这板子完全够用了。</p><p>虽然STM32F429的最高主频是180MHz，那么PLL倍频时候就可以先拉到360MHz再除以2；但因为USB需要精确的48MHz时钟，而48不能整除360，因此只能找别的倍频数。最后HCLK只设到到168MHz；而FMC的最小分频数是2，因此SDRAM的时钟频率最高是84MHz。SDRAM其他参数可以这样设置：</p><ul><li><code>CL（即CAS latency）</code>设为2；因为选用的SDRAM芯片是<code>K4S511632C-KC75</code>，最高时钟是133MHz；CL设低一点以稍微增加一点带宽。</li><li>其他时序比较常规，如<code>RCD</code> = 2，<code>RP</code> = 2，<code>WR</code> = 2，<code>RAS</code> = 4</li></ul><p>nand flash因为有busy引脚，所以大可不必担心CPU跑得太快；配置常规的时序就行了。</p><p>因为将SDRAM放在主芯片背面，引线非常短，而且时钟频率也很低，所以布线时不讲究等长，制版不搞阻抗，板子也能跑的很欢快。</p><h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>像我这种穷学生，当然选用一两块钱的<code>LAN8720A</code>这个RMII接口的百兆网卡啦。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/ethernet.jpeg" alt="网卡" title="">                </div>                <div class="image-caption">网卡</div>            </figure></p><p>复位脚我下拉了，所以程序里面初始化网卡之前先得将<code>ETH_RST</code>引脚拉高，设备树里面也记得要加复位引脚（stm32429-eval板就没加）。</p><pre><code>&amp;mac {    ...    snps,reset-gpio = &lt;&amp;gpioh 2 GPIO_ACTIVE_HIGH&gt;;    snps,reset-active-low;    snps,reset-delays-us = &lt;0 10000 100000&gt;;};</code></pre><h3 id="VGA显示接口"><a href="#VGA显示接口" class="headerlink" title="VGA显示接口"></a>VGA显示接口</h3><p>STM32F429只有LTDC液晶屏接口，并没有专门的VGA接口。VGA接口简单说就是，RGB三个模拟电平，加上行同步、帧同步信号线。STM32的DAC只有两路，不够RGB三路信号用；网上弄VGA的STM32玩家，或者是在FSMC上<a href="http://v.youku.com/v_show/id_XNzcwMzM4NTky.html" target="_blank" rel="noopener">外接一块CPLD、FPGA来弄</a>，或者RGB<a href="https://hackaday.com/2015/01/04/800-x-600-vga-with-the-stm32f4/" target="_blank" rel="noopener">只有零和一的数字电平</a>，或者<a href="http://www.eefocus.com/aliceqiulijun/blog/17-11/425157_ca8e6.html" target="_blank" rel="noopener">外接一个昂贵的高速DAC来弄</a>。</p><p>其实LTDC已经有行同步和帧同步了，关键就是将并行RGB信号转化为模拟信号嘛，最低成本的做法便是用<a href="https://www.cnblogs.com/raymon-tec/p/5129583.html" target="_blank" rel="noopener">R-2R电阻网络搭成简易DAC啦</a>。R-2R电阻网络之所以能有数模转换的效果，可用基尔霍夫定律算出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/vga.jpeg" alt="LTDC加上简易DAC搭成VGA" title="">                </div>                <div class="image-caption">LTDC加上简易DAC搭成VGA</div>            </figure></p><p>VGA的效果其实还是相当不错的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/vgaout.jpg" alt="VGA效果" title="">                </div>                <div class="image-caption">VGA效果</div>            </figure></p><h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>选用了0.5mm间距的fpc-24封装的摄像头模组。像OV7670、OV2640之类的摄像头模组引脚定义一般是一样的，而且Linux内核里面有大量摄像头的驱动，替换时候也相当方便。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/cameramodule.jpeg" alt="摄像头模组" title="">                </div>                <div class="image-caption">摄像头模组</div>            </figure></p><p>据他们的手册，这种模组有三个电源：</p><ul><li>AVDD，模拟电路电源，2.5～3.0V；</li><li>DVDD，数字电路电源，1.3V；有些原理图给到了1.8V，我之前也拉到过1.8V也没发生什么事情。</li><li>DOVDD，IO口电源，3.3V；</li></ul><p>摄像头的SCCB命令接口其实就是I2C接口。给了1.5k的上拉电阻。<br>其数据并行口最多有10位，但是实用的就8位，而且有些厂商的模组也就引出8位出来。并口、像素时钟、行同步、帧同步等信号都接到STM32的DCMI外设那里。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/camera.jpeg" alt="摄像头电路" title="">                </div>                <div class="image-caption">摄像头电路</div>            </figure></p><h3 id="其他外设"><a href="#其他外设" class="headerlink" title="其他外设"></a>其他外设</h3><ul><li>两个USB都工作在全速模式下面，直接分别引出D+、D-就可以了。（为降低板子复杂度，USB2没有外接高速phy芯片）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/usb.jpeg" alt="USB电路" title="">                </div>                <div class="image-caption">USB电路</div>            </figure></li><li>两路DAC引出为3.5mm音频接口。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/dac.jpeg" alt="音频接口" title="">                </div>                <div class="image-caption">音频接口</div>            </figure></li><li>SDIO接SD卡槽，除了时钟线之外，都加了10k上拉电阻。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/sdcard.jpeg" alt="SD卡" title="">                </div>                <div class="image-caption">SD卡</div>            </figure></li></ul><p>最终效果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/board.jpeg" alt="板子布好线了" title="">                </div>                <div class="image-caption">板子布好线了</div>            </figure></p><h3 id="布完线，就要出图了"><a href="#布完线，就要出图了" class="headerlink" title="布完线，就要出图了"></a>布完线，就要出图了</h3><p>国内工程师大规模用AD系的CAD软件，以至于国内PCB厂商都直接能接受.pcbdoc的文件了；不过最通用的还是gerber光绘文件，况且kicad也出不了.pcbdoc文件。</p><p>打样需要一批gerber文件：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">作用</th><th style="text-align:left">kicad里面的名字</th><th style="text-align:left">输出gerber文件后缀</th></tr></thead><tbody><tr><td style="text-align:left">信号层</td><td style="text-align:left">外层内层导电的铜层</td><td style="text-align:left">F.Cu、B.Cu、In1.Cu、In2.Cu等</td><td style="text-align:left">.gtl、.gbl、.g2、.g3</td></tr><tr><td style="text-align:left">阻焊层</td><td style="text-align:left">PCB外表的那一层红红绿绿的油墨层</td><td style="text-align:left">F.Mask 和 B.Mask</td><td style="text-align:left">.gts、.gbs</td></tr><tr><td style="text-align:left">锡膏层</td><td style="text-align:left">用来出钢网的</td><td style="text-align:left">F.Paste 和 B.Paste</td><td style="text-align:left">.gtp、.gbp</td></tr><tr><td style="text-align:left">丝印层</td><td style="text-align:left">即板子印有的油墨字体、logo之类的</td><td style="text-align:left">F.SilkS 和 B.Silks</td><td style="text-align:left">.gto、.gbo</td></tr><tr><td style="text-align:left">机械层</td><td style="text-align:left">勾出板子的轮廓，一般只需要一个机械层</td><td style="text-align:left">Edge.Cuts</td><td style="text-align:left">.gm1</td></tr><tr><td style="text-align:left">钻孔文件</td><td style="text-align:left">板子上打的通孔焊盘、过孔等等</td><td style="text-align:left">在plot时单独生成</td><td style="text-align:left">.drl</td></tr></tbody></table><p>最终输出的文件有：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/files.jpeg" alt="输出的文件" title="">                </div>                <div class="image-caption">输出的文件</div>            </figure></p><p>接着就可以投板生产了。不少PCB厂商都有网上平台，如果不想注册账号的话可以上淘宝翻找。打少量样片的话有些厂商可以免费24小时或48小时加急，没得加急的就等一周吧。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/tux.jpeg" alt="这只企鹅印的真是orz" title="">                </div>                <div class="image-caption">这只企鹅印的真是orz</div>            </figure><h3 id="手工焊接技巧"><a href="#手工焊接技巧" class="headerlink" title="手工焊接技巧"></a>手工焊接技巧</h3><p>根据我<del>多年</del>的焊接经验，焊引脚密集的贴片元件，一定要用<strong>有铅焊锡</strong>！63%的有铅焊锡加上<strong>松香</strong>，可以解决所有连锡问题！焊接时候一定要<strong>恒温烙铁</strong>或者<strong>焊台</strong>（恒温烙铁比普通烙铁贵不了多少），设置的焊接温度一定<strong>不能超过400摄氏度</strong>（其实300度已经很高了）！</p><p>有人说有铅焊锡不环保啊，铅是重金属对身体有害啊云云；但是要知道锡本身就是重金属啊。。。机器焊接不用有铅焊锡，忌惮的是电路板废弃之后对环境的影响；有铅焊锡的流动性、可焊接性比无铅焊锡要好多了，要想尽量减少对身体的害处，当然是快点焊完，缩短接触时间啦。</p><p>刚焊上的主控芯片。有两处连锡是因为那里本身就是连在一起的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/board2.jpg" alt="刚焊上的主控芯片" title="">                </div>                <div class="image-caption">刚焊上的主控芯片</div>            </figure></p><p>如果花点小钱定制钢网，就可以刷锡膏然后用热风枪吹了。不过锡膏刷的时候容易干掉，而且容易刷的太多，0.5mm间距的封装引脚容易连在一起，这时候还是要用电烙铁和松香将锡带出来。</p><p>对于qfn封装这类引脚在底下的芯片，就只能用热风枪来吹了。</p><p>板子全图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc2/board3.jpg" alt="板子全图" title="">                </div>                <div class="image-caption">板子全图</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引脚与外设分配&quot;&gt;&lt;a href=&quot;#引脚与外设分配&quot; class=&quot;headerlink&quot; title=&quot;引脚与外设分配&quot;&gt;&lt;/a&gt;引脚与外设分配&lt;/h3&gt;&lt;p&gt;利用&lt;a href=&quot;http://www.st.com/en/development-tools/stm32cubemx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;STM32CubeMX&lt;/a&gt;的引脚自动分配功能，前期准备工作方便了不少：&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/ucpc2/cubemx.jpeg&quot; alt=&quot;stm32cubemx&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;stm32cubemx&lt;/div&gt;
            &lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[1] ucLinux or Linux?</title>
    <link href="http://yoursite.com/ucpc1/"/>
    <id>http://yoursite.com/ucpc1/</id>
    <published>2018-02-27T06:04:21.000Z</published>
    <updated>2019-04-13T13:32:52.172Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个笼统的说法：Linux要有MMU才能跑，没有MMU的只能跑uclinux。但事实上自从2.6版本开始的Linux内核，<code>arch/arm/Kconfig</code>里就有了<code>CONFIG_MMU</code>的选项，因此严格地说，Linux内核<strong>早就能存活在没有MMU的ARM芯片上</strong>了。</p><p>uclinux严格意义上说是一个完整的发行版，它就是<code>主流内核 + 大量应用程序</code>。uclinux一直在慢慢悠悠地更新。最新的是2016年发布的4.4内核版本，然后直到现在再也没有更新了。</p><p>Linux内核里面MMU-less芯片的驱动日渐丰富，到了2015年内核4.2时代，里面竟赫然出现了STM32的配置和驱动！随后其STM32的驱动逐渐多了起来，从一开始的只有串口、pinctrl、RCC等的少量驱动，发展到支持I2C、DMA、定时器、ADC、DAC、LTDC、DCMI、USB、MII/RMII等等几乎所有STM32的外设；从一开始只支持stm32f429，到如今甚至已经支持<code>stm32h7</code>了，而现在2018年初h7芯片还基本买不到；stm32的设备树写法也改了一版。</p><a id="more"></a><h3 id="真能叫Linux么？"><a href="#真能叫Linux么？" class="headerlink" title="真能叫Linux么？"></a>真能叫Linux么？</h3><p><a href="http://emcraft.com/" target="_blank" rel="noopener">Emcraft System</a>推出不少STM32的SOM（system on module），并提供了他们的Linux BSP，内核有2.6、4.2、4.4等。他们的工程就是一个带有了bootloader的完整的发行版，应用程序也不仅仅是busybox，不过<strong>他们更愿意把它称为uclinux</strong>，可能是他们应用程序的来源就是uclinux。</p><p>Linux只是一个<strong>内核</strong>，uclinux是一个<strong>完整的发行版</strong>，就像<a href="https://buildroot.org/" target="_blank" rel="noopener">buildroot</a>、<a href="https://www.yoctoproject.org/" target="_blank" rel="noopener">yocto</a>这样的发行版；但是uclinux太众所周知了，以至于大家都把MMU-less的Linux发行版都称为uclinux。</p><p>目前我的429板子上跑的是最低配置的Linux发行版，只有区区一个busybox。以开源的自由的精神，叫uclinux还是叫Linux其实并不需要学术上的争论233</p><h3 id="没MMU的片子跑Linux，何用之有？"><a href="#没MMU的片子跑Linux，何用之有？" class="headerlink" title="没MMU的片子跑Linux，何用之有？"></a>没MMU的片子跑Linux，何用之有？</h3><p>最大的理由是，<strong>Linux下应用简直太丰富了</strong>。玩单片机如果不仅满足于让电机动起来（不过控制算法的确有很多文章可做），自然要玩些系统性的东西；如果仅是一个小实时系统，要带上文件系统、网络协议栈、USB设备之类的，则都是体力活，更不用说搭个小服务器了（或许你要远程访问它，或者要它连服务器）；而在Linux世界里面这些都不是问题。跑上Linux，单片机的负担重了点，但程序员的负担就轻了不少。</p><p>当年不少性能强劲的MMU-less的芯片促使了uclinux的迅速发展，比方说blackfin那些数百兆主频的DSP；而如今数百兆主频的ARM Cortex M系列单片机也并不少见，更有甚者如NXP准备推出1.2GHz主频的所谓跨界单片机，计算性能想必大大强于数百兆的Cortex A5/A7。单片机已非当年十几兆主频的吴下阿蒙。</p><p>想要比ARM9之流稍微强大一点的计算性能，又要比Cortex A5之流更低的功耗，还要比传统的SBC更为简单的开发模式，那么无MMU配置的Linux想必是极好的选择。</p><h3 id="为什么选择STM32F429？"><a href="#为什么选择STM32F429？" class="headerlink" title="为什么选择STM32F429？"></a>为什么选择STM32F429？</h3><p>429是当年的旗舰芯片，外设丰富，计算性能也相当不错（至少强于AT91SAM9260了）。目前主流内核对它支持相当好，基本所有外设都支持了。stm32f429-discovery开发板口碑不错，价格还不贵（要知道单片机评估板都特别特别特别贵），它可能是目前恰好能跑通主流Linux内核的最低配置的板子了。不少开源STM32的项目，但凡需要那么一点计算性能的，选型基本上从429往上走。</p><p>有人在<a href="https://openmv.io/" target="_blank" rel="noopener">OpenMV</a>上弄uclinux尝鲜，<a href="https://events.static.linuxfound.org/sites/events/files/slides/optimize-uclinux.pdf" target="_blank" rel="noopener">据说1秒钟之内就启动完毕了</a>。。寻常的ARM9板子哪能秒启动。。。应该感谢当年那些逮着uclinux到处移植的极客们，让<a href="https://github.com/robutest/uclinux" target="_blank" rel="noopener">内核里面有了F1、F2、F4的基本驱动</a>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc1/openmv.jpeg" alt="OpenMV uclinux" title="">                </div>                <div class="image-caption">OpenMV uclinux</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc1/tuxuclinux.jpeg" alt="uclinux下移动的企鹅" title="">                </div>                <div class="image-caption">uclinux下移动的企鹅</div>            </figure><p><a href="https://www.youtube.com/watch?v=shLbYdH02rA" target="_blank" rel="noopener">油管视频</a></p><h3 id="性能几何？"><a href="#性能几何？" class="headerlink" title="性能几何？"></a>性能几何？</h3><p>实话说，Linux的性能比不上裸机程序和真正的嵌入式实时操作系统，这个根深蒂固为服务器设计的内核考虑的都是无数个CPU、无数内存、无数存储设备，以致于被人吐槽为怪物；比方说，<a href="http://ck.kolivas.org/patches/bfs/bfs-faq.txt" target="_blank" rel="noopener">Con Kolivas对它的CFS调度器相当不满，然后他自己写了个BFS，称为“脑残调度器”</a>。越是新版本的内核，占用资源越大（回报是功能越齐全，漏洞越得到修补）。</p><p>就拿同一块STM32F429板子来说，只带有串口驱动的话：</p><table><thead><tr><th style="text-align:left">内核版本</th><th style="text-align:left">镜像大小</th><th style="text-align:left">BogoMIPS</th></tr></thead><tbody><tr><td style="text-align:left">uclinux 2.6.33</td><td style="text-align:left">700KB</td><td style="text-align:left">168.34</td></tr><tr><td style="text-align:left">Linux 4.2.8</td><td style="text-align:left">1.1MB</td><td style="text-align:left">~110</td></tr><tr><td style="text-align:left">Linux 4.13.3</td><td style="text-align:left">1.5MB</td><td style="text-align:left">~110</td></tr></tbody></table><p>BogoMIPS是个挺娱乐的参数，内核启动时候自行测量，以校准udelay等延时的参数，数值越高意味着单位时间内跑的指令越多，意味着性能越强。参考AT91SAM9260这个ARM9芯片，时钟频率同样是180MHz，同样跑2.6的内核，而且它还有cache，但<a href="http://linux-arm-kernel.infradead.narkive.com/8KI4atsi/at91sam9260-bogomips" target="_blank" rel="noopener">它的BogoMIPS只有八九十</a>。所以可以说，Cortex M4性能还是挺强的。</p><p>在2015年的ELC中有人做了一份<a href="https://www.youtube.com/watch?v=6F1eZKFzkUE" target="_blank" rel="noopener">如何优化uclinux的报告</a>，还有<a href="https://events.static.linuxfound.org/sites/events/files/slides/optimize-uclinux.pdf" target="_blank" rel="noopener">讲义</a>可供下载，干货满满。</p><h3 id="裁剪提示"><a href="#裁剪提示" class="headerlink" title="裁剪提示"></a>裁剪提示</h3><p>因为f429没有cache，所以内核<strong>一定要塞进片内flash</strong>，否则在片外SDRAM上运行的性能感人：BogoMIPS只有个位数，刷屏时候能体会到相当明显的卡顿，并且摄像头会抱怨<strong>DMA下溢</strong>，USB会枚举不到设备。如果是f7的芯片大可不必担心，即使在片外SDRAM里跑，其BogoMIPS据说都可达三百余。</p><p>因此f429的芯片只能选i系列的带2MB片内flash版本的才够用；f7的片子就随便啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个笼统的说法：Linux要有MMU才能跑，没有MMU的只能跑uclinux。但事实上自从2.6版本开始的Linux内核，&lt;code&gt;arch/arm/Kconfig&lt;/code&gt;里就有了&lt;code&gt;CONFIG_MMU&lt;/code&gt;的选项，因此严格地说，Linux内核&lt;strong&gt;早就能存活在没有MMU的ARM芯片上&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;uclinux严格意义上说是一个完整的发行版，它就是&lt;code&gt;主流内核 + 大量应用程序&lt;/code&gt;。uclinux一直在慢慢悠悠地更新。最新的是2016年发布的4.4内核版本，然后直到现在再也没有更新了。&lt;/p&gt;
&lt;p&gt;Linux内核里面MMU-less芯片的驱动日渐丰富，到了2015年内核4.2时代，里面竟赫然出现了STM32的配置和驱动！随后其STM32的驱动逐渐多了起来，从一开始的只有串口、pinctrl、RCC等的少量驱动，发展到支持I2C、DMA、定时器、ADC、DAC、LTDC、DCMI、USB、MII/RMII等等几乎所有STM32的外设；从一开始只支持stm32f429，到如今甚至已经支持&lt;code&gt;stm32h7&lt;/code&gt;了，而现在2018年初h7芯片还基本买不到；stm32的设备树写法也改了一版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>uc-PC[0] 序言</title>
    <link href="http://yoursite.com/ucpc0/"/>
    <id>http://yoursite.com/ucpc0/</id>
    <published>2018-02-26T06:41:37.000Z</published>
    <updated>2019-04-13T13:32:51.108Z</updated>
    
    <content type="html"><![CDATA[<p>研究系统，宜先抽筋剥骨以详其经脉，然后搭出骨架，使其生筋，让其长肉，覆之以皮肤，并让气息充实其中，从而让其鲜活起来，方能叫吃透这个系统。</p><p>玩嵌入式，就是在创造麻雀虽小五脏俱全的系统。茶余饭后，我一直在兴致勃勃地挖掘单片机的潜能，就如让一把大提琴拉出三把琴的和声，令一架管风琴弹出整个乐队的合奏。</p><p>做uc-PC，就是让它逐长筋肉，五脏俱全。</p><h3 id="它是一个完整的电脑"><a href="#它是一个完整的电脑" class="headerlink" title="它是一个完整的电脑"></a>它是一个完整的电脑</h3><p>虽是单片机开发板，但它有着与诸如树莓派、杨梅派、香蕉派、橙子派等相似的接口，插上显示器和键盘，然后假装是一台电脑。</p><a id="more"></a><h3 id="它跑着主流Linux"><a href="#它跑着主流Linux" class="headerlink" title="它跑着主流Linux"></a>它跑着主流Linux</h3><p>尽管没有MMU，它上面跑的是货真价实的<a href="https://www.kernel.org/" target="_blank" rel="noopener">kernel.org</a>下面的主流Linux内核。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/CONFIG_MMU.jpeg" alt="主流内核里的CONFIG_MMU选项" title="">                </div>                <div class="image-caption">主流内核里的CONFIG_MMU选项</div>            </figure></p><h3 id="基本驱动齐全"><a href="#基本驱动齐全" class="headerlink" title="基本驱动齐全"></a>基本驱动齐全</h3><p>网口、显示、USB、摄像头、SD卡、yaffs等都已跑通。</p><h3 id="它有着各种可能性"><a href="#它有着各种可能性" class="headerlink" title="它有着各种可能性"></a>它有着各种可能性</h3><p>它可跑通完整的发行版：</p><ul><li><a href="https://buildroot.org/" target="_blank" rel="noopener">buildroot</a></li><li><a href="http://uclinux.org/" target="_blank" rel="noopener">uclinux</a></li><li><a href="http://www.emdebian.org/" target="_blank" rel="noopener">Emdebian</a>，<a href="http://linuxdevices.io/arm7-development-board-includes-debian-gnu-linux-uclinux/" target="_blank" rel="noopener">远古时代ARM7开发板也能跑Debian</a>（可惜emdebian上的arm7部分已经找不到了）</li></ul><p>它不是yet another Linux开发板！下面的操作系统值得一试：</p><ul><li><a href="https://www.rt-thread.org/" target="_blank" rel="noopener">RT-Thread</a>，国内开源实时系统</li><li><a href="http://www.sylixos.com/" target="_blank" rel="noopener">SylixOS</a>，一个相当优秀的国产实时系统，<a href="http://jiaojinxing.github.io/2015/06/20/SylixOS-for-ARMv7-M-%E5%BC%80%E5%8F%91%E7%A1%AC%E4%BB%B6%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener">已移植到STM32F429-disc1</a></li><li><a href="http://www.nuttx.org/" target="_blank" rel="noopener">nuttx</a>，类Linux的嵌入式实时操作系统，功能相当齐全，px4飞控上的系统</li><li><a href="https://www.zephyrproject.org/" target="_blank" rel="noopener">zephyr</a>，Linux基金会托管的一个物联网操作系统，方兴未艾</li></ul><p>它能移植一系列图形界面：</p><ul><li>QT GUI，<a href="https://www.emcraft.com/som/stm32f7/running-qt-gui" target="_blank" rel="noopener">Emcraft家的stm32f7</a>，还有<a href="https://www.youtube.com/watch?v=SzvdM6CDADo" target="_blank" rel="noopener">油管上的stm32f429</a></li><li><a href="http://embeddedlightning.com/ugui/" target="_blank" rel="noopener">uGUI</a>，微型的GUI系统</li><li><a href="https://bellard.org/TinyGL/" target="_blank" rel="noopener">TinyGL</a>，裁剪版OpenGL库</li></ul><p>甚至播放视频：</p><ul><li><a href="https://github.com/kunakh/stm32f7player" target="_blank" rel="noopener">移植ffmpeg</a></li></ul><p>还将移植一些好玩的STM32开源项目：</p><ul><li><a href="https://micropython.org/" target="_blank" rel="noopener">MicroPython</a></li><li><a href="https://pixhawk.org/modules/px4flow" target="_blank" rel="noopener">px4flow</a></li><li><a href="https://openmv.io/" target="_blank" rel="noopener">OpenMV</a>（其实一开始openmv用f4的片子）</li></ul><h3 id="现在，它是最具有可玩性的单片机开发板"><a href="#现在，它是最具有可玩性的单片机开发板" class="headerlink" title="现在，它是最具有可玩性的单片机开发板"></a>现在，它是最具有可玩性的单片机开发板</h3><ul><li>STM32F429IIT6 / STM32F767IGT6</li><li>64MB SDR SDRAM</li><li>128MB nand flash</li><li>10/100M ethernet</li><li>640x480@60Hz <strong>标准VGA视频输出</strong></li><li>USB-fs *2</li><li>SD卡槽 *1</li><li>摄像头模组接口（支持OV7670、OV2640等等各种fpc-24封装摄像头模组）</li></ul><p><a href="https://www.bilibili.com/video/av19447523/?from=search&amp;seid=16245823884252462808" target="_blank" rel="noopener">演示视频在b站</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/board1.jpg" alt="板子1" title="">                </div>                <div class="image-caption">板子1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/board2.jpg" alt="板子2" title="">                </div>                <div class="image-caption">板子2</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/board3.jpg" alt="板子3" title="">                </div>                <div class="image-caption">板子3</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/board4.jpg" alt="板子4" title="">                </div>                <div class="image-caption">板子4</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/scene1.jpeg" alt="busybox 1" title="">                </div>                <div class="image-caption">busybox 1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/scene2.jpeg" alt="busybox 2" title="">                </div>                <div class="image-caption">busybox 2</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/scene3.jpeg" alt="busybox 3" title="">                </div>                <div class="image-caption">busybox 3</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/scene4.jpeg" alt="busybox 4" title="">                </div>                <div class="image-caption">busybox 4</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/scene5.jpeg" alt="摄像头" title="">                </div>                <div class="image-caption">摄像头</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/ucpc0/scene6.jpeg" alt="USB可以接任何东西" title="">                </div>                <div class="image-caption">USB可以接任何东西</div>            </figure><p><a href="https://www.bilibili.com/video/av19447523/?from=search&amp;seid=16245823884252462808" target="_blank" rel="noopener">演示视频在b站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究系统，宜先抽筋剥骨以详其经脉，然后搭出骨架，使其生筋，让其长肉，覆之以皮肤，并让气息充实其中，从而让其鲜活起来，方能叫吃透这个系统。&lt;/p&gt;
&lt;p&gt;玩嵌入式，就是在创造麻雀虽小五脏俱全的系统。茶余饭后，我一直在兴致勃勃地挖掘单片机的潜能，就如让一把大提琴拉出三把琴的和声，令一架管风琴弹出整个乐队的合奏。&lt;/p&gt;
&lt;p&gt;做uc-PC，就是让它逐长筋肉，五脏俱全。&lt;/p&gt;
&lt;h3 id=&quot;它是一个完整的电脑&quot;&gt;&lt;a href=&quot;#它是一个完整的电脑&quot; class=&quot;headerlink&quot; title=&quot;它是一个完整的电脑&quot;&gt;&lt;/a&gt;它是一个完整的电脑&lt;/h3&gt;&lt;p&gt;虽是单片机开发板，但它有着与诸如树莓派、杨梅派、香蕉派、橙子派等相似的接口，插上显示器和键盘，然后假装是一台电脑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ucpc" scheme="http://yoursite.com/tags/ucpc/"/>
    
  </entry>
  
  <entry>
    <title>调试hardfault</title>
    <link href="http://yoursite.com/hardfault/"/>
    <id>http://yoursite.com/hardfault/</id>
    <published>2018-02-26T06:13:10.000Z</published>
    <updated>2019-04-13T13:32:50.532Z</updated>
    
    <content type="html"><![CDATA[<p>对于搞Cortex M系列mcu开发的人来说，hardfault这种鬼东西，不遇到还好，倘若不幸遇到了，复位一下，瞎调一下，左右修补，或许碰巧就消除了。但是靠人品毕竟不是长久之计。下面记录我调试hardfault的一些简单的经验。</p><h2 id="hardfault来源"><a href="#hardfault来源" class="headerlink" title="hardfault来源"></a>hardfault来源</h2><p>Cortex M3、M4的向量表中，3号异常是<code>HardFault</code>；接下来三个异常是<code>MemFault</code>、<code>BusFault</code>、<code>UsageFault</code>。发生了hardfault，基本是因为后面三个异常<code>上访</code>来的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/exceptiontable.jpeg" alt="向量表" title="">                </div>                <div class="image-caption">向量表</div>            </figure><br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/DUI0553A_cortex_m4_dgug.pdf" target="_blank" rel="noopener">手册</a>上的向量表</p><a id="more"></a><p>（按照他们的意思，<code>异常</code>与<code>中断</code>是两个概念，中断专指外设产生的中断，中断是一种异常）</p><ul><li><code>MemFault</code>是由MPU（内存保护模块）产生的。对于用到MPU的工程来说必定写好了MemFault处理函数，<strong>不应该由它上访</strong>；</li><li><code>BusFault</code>，CPU访问存储器出错时发生总线错误。主要就是读写数据失败。这是最常碰到的一类错误，鉴于不少单片机工程师基本不写busfault处理函数，<strong>我碰到的基本上所有hardfault都是由总线错误引起的</strong>。。。</li><li><code>UsageFault</code>，CPU执行到非法指令，或者处于非法的模式下面。比方说在没有fpu的情况下访问fpu，没有协处理器的情况下访问协处理器；更常见的情况是PC最低位莫名其妙的变成了0进入ARM模式，而Cortex M只有thumb模式，从而出错。碰到了用法错误，如果不是自己作死（比方说写错汇编），<strong>基本上就是碰到了编译器的bug</strong>。。。</li></ul><h2 id="碰到hardfault"><a href="#碰到hardfault" class="headerlink" title="碰到hardfault"></a>碰到hardfault</h2><p>此时板子上应当连着一个调试器。。。<br>（对于Cortex M0，我试过在它正在跑的时候用jlink连它，无论当时它还是不是在欢快地运行，一连就hardfault；以我拙见，如果板子确定是由于hardfault死掉了，那要从一开始就连着调试器，然后复现状况）</p><h3 id="看哪个fault引起的"><a href="#看哪个fault引起的" class="headerlink" title="看哪个fault引起的"></a>看哪个fault引起的</h3><p>先看<code>Hardfault Status Register</code>，地址<code>0xE000ED2C</code>。看第30位是否为1，验证一下它是不是上访而来的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/hfsr.jpeg" alt="HFSR第30位" title="">                </div>                <div class="image-caption">HFSR第30位</div>            </figure></p><p>然后<strong>关注总线错误</strong>。看<code>BusFault Status Register</code>，地址<code>0xE000ED29</code>；这是一个8位寄存器，重点关注第1、2位：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/bfsr.jpeg" alt="BFSR第1、2位" title="">                </div>                <div class="image-caption">BFSR第1、2位</div>            </figure><br>就看它是不是<code>精确的</code>总线错误；PRECISE的话，<code>0xE000ED38</code>地址的寄存器<code>BusFault Address Register</code>记录了哪里而引发的错误；IMPRECISE的话就有点麻烦了。</p><p>如果用keil，则可以打开 <strong>Peripherals -&gt; Core Peripherals -&gt; Fault Reports</strong> 窗口直观地看哪个fault：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/keilfaultreport.jpeg" alt="fault reports" title="">                </div>                <div class="image-caption">fault reports</div>            </figure></p><p>如果是命令行工具，<code>JLinkExe</code>命令行下面用<code>mem8</code>、<code>mem32</code>来看；<code>gdb</code>下面则用<code>x</code>命令来看。</p><h3 id="看堆栈"><a href="#看堆栈" class="headerlink" title="看堆栈"></a>看堆栈</h3><p>直接在CPU寄存器那里看两个堆栈指针。</p><p>首先，堆栈应该在合法的RAM那里，比方说0x20000000后面的几十上百k处，又比方说初始化了片外RAM之后在片外RAM处。还要看堆栈是否溢出。<br>如果SP明显不合法的话，那接下来就要检查代码写的对不对，有没有死递归，链接脚本有没有写对（比方说移植某些项目时候，代码原本跑在内存里面，然后转片内flash了，也没有把堆栈段放好），等等。<br>如果判断是堆栈溢出了，一般来说跑裸机的话没有写堆栈溢出的保护措施，以至于stack段践踏了heap段，甚至践踏了data段，以致于破坏了一些全局变量，那就需要增加堆栈的大小；对于keil工程，在那个startup_xxxxx.s里面改stack和heap的大小；对于makefile工程，就在链接脚本里面改（不过一般都会设到SRAM的最末端）。<strong>堆栈溢出可能造成任何fault</strong>。</p><p>如果堆栈安好，那问题就出在别处；此时堆栈里面记录了出事地点，还有一些寄存器的值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/stackframe.jpeg" alt="堆栈情况" title="">                </div>                <div class="image-caption">堆栈情况</div>            </figure><br>其中，第7个int是出事时候的PC值，第6个int是出事时候的LR值（即调用者）。通过<strong>堆栈里的PC值</strong>可以查到出事的那行代码：gcc工具链中的<code>addr2line</code>就在专门干这个的；keil的话在反汇编窗口，右键，show disassembly at address，输入那个地址即可。</p><p>一般来说，看到哪一行代码出事，差不多就解决了问题，对于<code>PRECISE</code>的总线错误的话，<code>0xE000ED38</code>地址处的寄存器<code>BusFault Address Register</code>记录了哪里而引发的错误，此时检查一些变量，检查一下野指针。</p><h3 id="应对IMPRECISE-BusFault"><a href="#应对IMPRECISE-BusFault" class="headerlink" title="应对IMPRECISE BusFault"></a>应对IMPRECISE BusFault</h3><p>以我的经验，<strong>非精确的总线错误基本上是因为<code>写</code>了片内flash区域</strong>。不信你试试给const char*的字符串赋值（强转一下）。但是出现非精确总线错误时候<strong>并不知道CPU已经执行了多少指令</strong>，没有哪个寄存器可以定位出错地点。<br>但是对于Cortex M3、Cortex M4来说，<strong>IMPRECISE的错误可以转化为PRECISE的错误</strong>！将地址<code>0xE000E008</code>处的寄存器<code>Auxiliary Control Register</code>的第1位<code>DISDEFWBUF</code>置1，取消写缓冲，于是内核就会老老实实等待每个写访问完成之后再继续运行，<a href="https://community.nxp.com/docs/DOC-103810" target="_blank" rel="noopener">据说就不会产生IMPRECISE总线错误了</a>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/actlr.jpeg" alt="Auxiliary Control Register" title="">                </div>                <div class="image-caption">Auxiliary Control Register</div>            </figure></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>C语言里面指针跟数组名不是一回事。指针<strong>是变量</strong>，但是数组名就<strong>不是变量</strong>。虽然有时候混用并没有语法错误，但是运行时候就不同了。。。</p><p>假设我在<code>str.c</code>里面定义一个buff数组：</p><pre><code class="c">char buff[10];</code></pre><p>然后我在<code>main.c</code>里面才用到它；我声明它为一个指针，并且这样用它：</p><pre><code class="c">extern char *buff;int main(void){    buff[0] = &#39;a&#39;;    while(1);    return 0;}</code></pre><p><strong><em>没语法错误</em></strong>啊，<code>buff</code>不管是一个数组名，还是一个指针，<code>buff[0]</code>这样引用第0个元素怎么都是对的。</p><p>然后我们烧进板子里面，跑一下，结果它最后卡在<code>HardFault_Handler</code>里面了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/hfhandler.jpg" alt="进入hardfault死循环" title="">                </div>                <div class="image-caption">进入hardfault死循环</div>            </figure></p><p>然后看fault report，发现居然还是IMPRECISE的总线错误。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/imprecisebusfault.jpeg" alt="观察fault report" title="">                </div>                <div class="image-caption">观察fault report</div>            </figure></p><p>程序非常简单，错误肯定出在main.c第5行<code>buff[0] = &#39;a&#39;</code>这里。为什么呢？</p><p>我们来看看反汇编：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/asm1.jpeg" alt="char *buff的反汇编" title="">                </div>                <div class="image-caption">char *buff的反汇编</div>            </figure></p><p>因为<strong>指针是变量</strong>，但凡变量都客观存在，都有一块实际的内存；引用一个变量要两步，先找到它的地址，再通过地址找它；所以若要给指针指向的值赋值，就要：<code>取指针地址</code>，<code>通过指针地址取指针值</code>，<code>用寄存器寻址方式去赋值</code>，所以它有两次<code>LDR</code>。<br>但是<strong>数组名不是变量</strong>，所以它不客观存在，它没有地址，引用它，就一步到位找到它的值了。<br>因为二者不是同一类型，所以如果你在同一个文件里面这样写的话就会出编译错误，说buff重复定义：</p><pre><code class="c">char buff[10];extern char *buff;</code></pre><p>将定义和声明分开在不同的文件里面写<strong>的确是良好的工程习惯</strong>。但是上面的东西分开来写之后，编译器<strong>先逐个文件编译再链接</strong>，每个c文件<strong>都没有</strong>语法错误；而链接器并不识别类型，只根据名字将符号组合在一起，所以也发现不了这样的错误。然后程序员就愉快地以为天下无事了。</p><p>然后在运行时候，因为多了一次LDR命令，导致它将<code>buff</code>指向的值当做了<code>buff</code>本身，而现在这个值是0x00000000，然后将’a’写到0x00000000处，对STM32来说这是片内flash的地址。另外Cortex M将这个地址视为可写的，并不会立即出错；等到STM32的flash控制器发现flash没有解锁而写入了，就触发一个总线错误，然而此时CPU不知道已经跑了多久了。</p><p>如果把声明为数组：</p><pre><code class="c">extern char buff[];</code></pre><p>那么反汇编就没事：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/hardfault/asm2.jpeg" alt="char buff[]的反汇编" title="">                </div>                <div class="image-caption">char buff[]的反汇编</div>            </figure><br>自然运行也没事了。</p><p>在一个大工程里面找这样的<strong>编译器发现不了的</strong>错误，源自于某程序员一时手抖的错误，解决办法那么简单的错误，然而那么难以定位的错误，而且责任又那么难以追究的错误，要多坑有多坑。</p><h2 id="编写hardfault处理函数"><a href="#编写hardfault处理函数" class="headerlink" title="编写hardfault处理函数"></a>编写hardfault处理函数</h2><p>hardfault处理函数的手段十分有限，基本上只能干两种事：<code>上报错误</code>，<code>重启</code>。</p><p>对于裸机来说，出现了hardfault就意味着代码有严重错误，肯定不能指望hardfault来恢复些什么东西的，hardfault就是用来给你调试的，如果实在调不出来，为保证系统持续工作，你应该在出现hardfault之前重启系统。</p><p>如果上了操作系统，那就是你某个任务出现了严重错误，应该想办法将错误print到上位机以便调试。可选的方式是，将错误信息复制出去，消掉错误状态位，然后在别的地方上报错误，最后想办法重启任务，以便继续工作。</p><p>更详细的方案，请参考<strong><em>《ARM Cortex-M3 权威指南》</em></strong>附录E，以及别的某某权威指南。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于搞Cortex M系列mcu开发的人来说，hardfault这种鬼东西，不遇到还好，倘若不幸遇到了，复位一下，瞎调一下，左右修补，或许碰巧就消除了。但是靠人品毕竟不是长久之计。下面记录我调试hardfault的一些简单的经验。&lt;/p&gt;
&lt;h2 id=&quot;hardfault来源&quot;&gt;&lt;a href=&quot;#hardfault来源&quot; class=&quot;headerlink&quot; title=&quot;hardfault来源&quot;&gt;&lt;/a&gt;hardfault来源&lt;/h2&gt;&lt;p&gt;Cortex M3、M4的向量表中，3号异常是&lt;code&gt;HardFault&lt;/code&gt;；接下来三个异常是&lt;code&gt;MemFault&lt;/code&gt;、&lt;code&gt;BusFault&lt;/code&gt;、&lt;code&gt;UsageFault&lt;/code&gt;。发生了hardfault，基本是因为后面三个异常&lt;code&gt;上访&lt;/code&gt;来的。&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/hardfault/exceptiontable.jpeg&quot; alt=&quot;向量表&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;向量表&lt;/div&gt;
            &lt;/figure&gt;&lt;br&gt;&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/DUI0553A_cortex_m4_dgug.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手册&lt;/a&gt;上的向量表&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gdb调试stm32的技巧</title>
    <link href="http://yoursite.com/gdb%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/gdb调试技巧/</id>
    <published>2018-02-24T16:08:35.000Z</published>
    <updated>2019-04-13T13:32:50.444Z</updated>
    
    <content type="html"><![CDATA[<p>很多人开发C程序就像写脚本那样，查错，靠的是眼睛看；但是作为系统开发程序员，bug单纯靠看是查不出来的，于是就用printf，于是每一次查错都不可避免要机械地写printf、编译、烧写、运行，没有IDE的时候烧写、运行还不太方便。如果能在命令行下面设断点、单步调试什么的，想必是极好的。</p><p>有时候开发一些程序还不得不在Ubuntu下弄，比方说国外的不少开源项目像px4、openmv之类的，又比方说Linux、nuttx之类的系统开发，等等。当然诸如Eclipse之类的IDE配置一下也能聊胜于无，但是配置它们的复杂度不亚于在命令行下面弄，而且连接板子、开gdb server这些工序只能在命令行下完成；好处是调试时候能用鼠标操作。</p><p>其实，命令行下面用gdb调试，熟悉基本命令之后，用起来相当顺手；在TUI模式下面调试，视觉效果不亚于使用IDE。</p><h2 id="需要安装的软件"><a href="#需要安装的软件" class="headerlink" title="需要安装的软件"></a>需要安装的软件</h2><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>包管理装就行：</p><pre><code>$ sudo apt-get install gdb-arm-none-eabi</code></pre><p>当然也可以选用别的，比方说</p><ul><li><a href="https://sourcery.mentor.com/GNUToolchain/package6503/public/arm-uclinuxeabi/arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2" target="_blank" rel="noopener">arm-uclinuxeabi-2010q1</a>里面就有arm-uclinuxeabi-gdb。不过这个的TUI有问题。</li><li>SourceForge的uclinux下载页面（崩掉了）</li></ul><a id="more"></a><h3 id="ubuntu下jlink驱动"><a href="#ubuntu下jlink驱动" class="headerlink" title="ubuntu下jlink驱动"></a>ubuntu下jlink驱动</h3><p>在<a href="https://www.segger.com/downloads/jlink" target="_blank" rel="noopener">segger官网下载页面</a>上找32-bit或64-bit的deb。<strong>如果你用的是盗版jlink，则5点几的老版本驱动可能更稳定</strong>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/gdb调试技巧/segger.jpeg" alt="segger官网" title="">                </div>                <div class="image-caption">segger官网</div>            </figure></p><p>使用dpkg命令安装</p><pre><code>$ sudo dpkg -i jlink_5.10.16_x86_64.deb</code></pre><p>现在就有JLinkxxxxx的命令了，常用的是<code>JLinkExe</code>和<code>JLinkGDBServer</code>。</p><p><a href="https://www.segger.com/admin/uploads/productDocs/UM08001_JLink.pdf" target="_blank" rel="noopener">jlink的手册</a>里详述了命令行工具的用法和参数。jlink功能很强大，写好配置文件，并且初始化好板子的存储器接口，甚至可以将程序烧到片外nor flash上面（因为现在nor flash基本上都符合<a href="https://en.wikipedia.org/wiki/Common_Flash_Memory_Interface" target="_blank" rel="noopener">CFI规范</a>了）。</p><h2 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h2><p>用gcc<strong>编译程序</strong>时加上<code>-g</code>参数即可，链接时不用加。需要注意的是，如果使用链接脚本的话，不要删去无关段，因为调试信息就在一系列的debug段里面。<br><a href="https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html#Debugging-Options" target="_blank" rel="noopener">gcc的调试参数还分级别</a>。不过一般而言一个<code>-g</code>就够了。</p><p>在一些工程里面，需要在Makefile里面改<code>CFLAGS</code>来添加编译参数；或者<code>make CFLAGS=xxxxxx</code>这样来弄。<br>而对于Linux内核工程来说，它专门有一个配置叫<code>CONFIG_DEBUG_INFO</code>，选择它就行，不需要翻找Makefile。</p><h2 id="JLinkExe基本命令"><a href="#JLinkExe基本命令" class="headerlink" title="JLinkExe基本命令"></a>JLinkExe基本命令</h2><p>JLinkExe基本上就用来烧程序。假设要烧录的芯片是<code>STM32F429ZIT6</code>，用jlink连好板子后，开启<code>JLinkExe</code>：</p><pre><code>$ JLinkExe -device stm32f429zi -if swd -speed 4000</code></pre><p>命令中选用了SWD接口，速度4000<strong>k</strong>Hz。</p><pre><code>$ JLinkExe -device stm32f429zi -if swd -speed 4000SEGGER J-Link Commander V5.10p (Compiled Feb 26 2016 19:06:09)DLL version V5.10p, compiled Feb 26 2016 19:06:05Connecting to J-Link via USB...O.K.Firmware: J-Link ARM-OB STM32 compiled Aug 22 2012 19:52:04Hardware version: V7.00S/N: 20090928License(s): RDI,FlashDL,FlashBP,JFlash,GDBFullEmulator has Trace capabilityVTref = 3.300VType &quot;connect&quot; to establish a target connection, &#39;?&#39; for helpJ-Link&gt;</code></pre><p>这时已经识别到了jlink，用<code>connect</code>命令来连接板子：</p><pre><code>J-Link&gt;connectDevice &quot;STM32F429ZI&quot; selected.Found SWD-DP with ID 0x2BA01477Found SWD-DP with ID 0x2BA01477Found Cortex-M4 r0p1, Little endian.FPUnit: 6 code (BP) slots and 2 literal slotsCoreSight components:ROMTbl 0 @ E00FF000ROMTbl 0 [0]: FFF0F000, CID: B105E00D, PID: 000BB00C SCSROMTbl 0 [1]: FFF02000, CID: B105E00D, PID: 003BB002 DWTROMTbl 0 [2]: FFF03000, CID: B105E00D, PID: 002BB003 FPBROMTbl 0 [3]: FFF01000, CID: B105E00D, PID: 003BB001 ITMROMTbl 0 [4]: FFF41000, CID: B105900D, PID: 000BB9A1 TPIUROMTbl 0 [5]: FFF42000, CID: B105900D, PID: 000BB925 ETMCortex-M4 identified.J-Link&gt;</code></pre><p>倘若连不上，或许板子布线的不好，可以适当降低调试接口的时钟频率，1000kHz、500kHz、100kHz等等。<br>也有可能此时板子正处在一种很诡异的状态，它程序或许在跑，但是调试口连不上（比方说我在SDRAM里面跑程序的话有时候是连不上的）；此时，先按着复位键，输入connect命令回车，然后马上松开复位键，基本上都可以连上。<br>还有可能是你程序写的不好，比方说，你超频得太厉害了（本来是25MHz的晶振，你当成8MHz来初始化了），这种情况你按着复位键也连不上，只能够用镊子短路晶振，复位一下，然后再connect。<br>有些时候程序貌似没问题但是也连不上，短接晶振之后居然连上了，我有一次调PX4FLOW时候就是这种情况。这没办法，只能老老实实查代码。<br>当然也有些可能是芯片烧掉了。STM32内核烧掉的情况真不少见，拆机件都不是特别靠谱。总之，jlink居然都连不上板子，想必是有些问题了。</p><p>问号可以查询JLinkExe都有哪些命令。输出很多。其中有几个是经常要用的：</p><ul><li><code>r</code>，即reset，复位板子</li><li><code>g</code>，即go，代码继续运行</li><li><code>h</code>，即halt，暂停运行</li><li><code>regs</code>，查看寄存器。看寄存器用处挺大的，看PC、LR、PSR值，会知道此时CPU到底正常与否，到底发生了什么fault。</li><li><code>mem8</code>、<code>mem16</code>、<code>mem32</code>，查看对应内存地址的值。比方说出现了hardfault，这时候查看NVIC的hardfault寄存器，看看哪个fault上访；比方说出现了bus fault，查看是哪种总线错误，查看出错的地址等等。用处相当大。</li><li><code>w1</code>、<code>w2</code>、<code>w4</code>，将值写入对应的内存地址。写脚本时候可以用这些命令来初始化外设寄存器。这时就要老老实实翻手册，计算哪个寄存器应该写哪些值。</li><li><code>erase</code>，擦除整个片内flash</li><li><code>loadbin</code>，烧写程序，格式是<code>loadbin 哪个bin 哪个地址</code>。蛋疼的是，它只认.bin后缀的文件。</li></ul><p>用loadbin命令烧写程序。比方说烧写本目录下的xipImage.bin：</p><pre><code>J-Link&gt;loadbin xipImage.bin 0x08008000         Downloading file [xipImage.bin]...Comparing flash   [100%] Done.Erasing flash     [100%] Done.Programming flash [100%] Done.Verifying flash   [100%] Done.J-Link: Flash download: Flash programming performed for 2 ranges (262144 bytes)J-Link: Flash download: Total time needed: 12.326s (Prepare: 0.163s, Compare: 0.739s, Erase: 3.303s, Program: 8.100s, Verify: 0.006s, Restore: 0.013s)O.K.J-Link&gt;rJ-Link&gt;gJ-Link&gt;</code></pre><p>烧完之后记得复位、启动。</p><p>这些命令都可以写在脚本里面，然后<code>JLinkExe -commanderscript xxxxxx</code>来运行脚本。比方说要烧写一批板子，当然写脚本方便啦。</p><p>有时候烧程序会失败，直接failed to download RAM code。这或许是板子布线不好，降低调试时钟频率就行；又或许是板子上电容没焊全：大芯片有十几个电源脚，这些脚外面的104电容一个都不能少。<br>有时候烧写老是卡在某个特定地址的flash块上面，擦又擦不掉，这时降低调试时钟频率或许会有用。<br>如果死活烧不进去，或许芯片烧了。（我有一次用拆机件，发现启动时有时候PC是0x08000000之后的地址，有时候又是0x1fff0000之后的地址，而后者是STM32出厂bootloader的地址；这说明它有时候从bootloader启动，有时候又从片内flash启动，从哪启动取决于boot0引脚的电平，而测得它的电平是稳定的。这表明，芯片内部boot0引脚的某个地方可能坏了。一分钱一分货）</p><p>退出程序，用<code>q</code>，或者按<code>Ctrl+C</code>退出。</p><h2 id="使用arm-none-eabi-gdb"><a href="#使用arm-none-eabi-gdb" class="headerlink" title="使用arm-none-eabi-gdb"></a>使用arm-none-eabi-gdb</h2><p>交叉工具链的gdb用法跟gdb几乎一样。只不过交叉工具链必须要gdb server。jlink提供了<code>JLinkGDBServer</code>，连接板子时参数跟<code>JLinkExe</code>差不多，同样要表明什么芯片、什么调试口、速度几何。默认端口是2331。</p><p>假设我们要调试大名鼎鼎的<strong>Linux内核</strong>。它的elf文件是<strong>vmlinux</strong>，就在编译目录下面。而且内核配置了<code>CONFIG_DEBUG_INFO</code>。</p><p>开一个终端，开gdb server：</p><pre><code>$ JLinkGDBServer -device stm32f429zi -if swd -speed 4000  ...    Connecting to J-Link...                                    J-Link is connected.                                         ...Checking target voltage...                                 Target voltage: 3.30 V                                     Listening on TCP/IP port 2331                              Connecting to target...Connected to target                 Waiting for GDB connection...</code></pre><p>在另外一个终端，开gdb：</p><pre><code>$ arm-none-eabi-gdb vmlinuxGNU gdb (7.11.90.20160917-0ubuntu1+9build1) 7.11.90.20160917-git             Copyright (C) 2016 Free Software Foundation, Inc....Reading symbols from vmlinux...done. (gdb) </code></pre><p>在gdb里面连接gdb server</p><pre><code>(gdb) target remote :2331</code></pre><p>然后就可以愉快地调试了！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/gdb调试技巧/debug.jpeg" alt="在start_kernel()处的断点" title="">                </div>                <div class="image-caption">在start_kernel()处的断点</div>            </figure><br>以上是设在大名鼎鼎的<strong>start_kernel()</strong>处的断点。推荐使用<code>tmux</code>。上图开了两个窗口，上面的是<strong>TUI</strong>下面的arm-none-eabi-gdb，下面是JLinkGDBServer。还可以在旁边开一个窗口运行诸如picocom的串口助手，方便调试。</p><h2 id="gdb常用指令"><a href="#gdb常用指令" class="headerlink" title="gdb常用指令"></a>gdb常用指令</h2><p>gdb有一本<a href="https://www.eecs.umich.edu/courses/eecs373/readings/Debugger.pdf" target="_blank" rel="noopener">厚厚的说明书</a>。其实调试时候并不需要那么多奇技淫巧，掌握基本的命令，在gdb下存活，然后碰到问题再翻手册，这才现实。</p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li><code>b</code>，设置程序断点，语法是<code>b 函数名</code>或者<code>b 文件名:行数</code>。如果要在特定地址设置断点，就是<code>b *那个地址</code>。值得一提的是，gcc拓展的c语法中，goto是可以直接跳到特定地址的，比方说 <strong>goto *0x08000000</strong> 就是跳到0x08000000地址去执行；如果是ANSI c的话要使用一些稍显晦涩的typedef才能达到目的。</li><li><code>watch</code>，设置数据断点，watch后面加变量名。一般用来设置全局变量的断点（局部变量的话出去之后记得删掉断点）。还可以用c语言强制类型转换的语法，比方说要观察0x40023830处4个字节的变化，就是<code>watch *(int*)0x40023830</code>。</li><li><code>info breakpoints</code>，查看断点。</li><li><code>d</code>，删除断点，d后面跟着标号表示删除哪个断点；上面查看断点可以看到他们的标号。</li></ul><p>断点函数、变量都可以tab补全。</p><p>在底层，STM32不同区域的存储器断点设置策略不同。<br>对于片内flash这一段只读区域来说，stm32有一个硬件断点模块，可以设置有限个断点；<br>对于RAM这些可读可写区域来说，就会以经典的方式去弄：将那个地址的指令替换为<code>bkpt</code>断点指令，碰到之后再把原来指令换回去以便继续执行，这样断点数目就没有限制了；<br>但是需要注意的是，片外的存储器都是当做RAM的，即便接的是nor flash，它也会以后面的方式来设置断点，意味着片外nor flash是无论如何都设置不上断点的，除非在代码里面强行写bkpt指令；但是单步调试之类的是绝对不可能的。<br>如果程序跑在片外RAM那里，而且是由bootloader来搬运（比方说用uboot来从tftp服务器下载镜像）的话，在复位时候设置断点也是没有意义的，因为断点指令会被覆盖；此时就需要在bootloader搬运好程序之后断下来，以便在跳转到程序之前设置断点。因为很多情况下要反复重启板子来调试，所以最好写个gdb脚本。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li><code>c</code>或者<code>continue</code>，继续执行代码，直到碰到断点。</li><li><code>s</code>，单步执行，碰到程序调用则进入程序。</li><li><code>n</code>，单行执行，碰到程序调用就执行完那个程序。</li><li><code>si</code>，单指令执行，碰到子程序调用指令则进入子程序。</li><li><code>ni</code>，单行汇编执行，碰到子程序调用指令就执行完子程序。汇编指令级别的单步调试不仅用来调汇编，而且可以用来观察哪一步触发了fault，甚至可以发现编译器深层次的bug。</li><li><code>finish</code>，子程序执行到返回。</li></ul><h3 id="查看调用堆栈"><a href="#查看调用堆栈" class="headerlink" title="查看调用堆栈"></a>查看调用堆栈</h3><ul><li><code>bt</code>，直接输出调用栈</li></ul><h3 id="操作变量"><a href="#操作变量" class="headerlink" title="操作变量"></a>操作变量</h3><ul><li><code>p</code>，后面跟变量，即查看这个变量。可以用c语言的语法，比方说查看指针指向的值，查看结构体成员变量，甚至强制类型转换。</li><li><code>x</code>，查看内存区域的值，语法是<code>x /FMT 地址</code>。FMT处要填三个东西：个数、输出格式、长度；输出格式可以有二进制、八进制、十进制等等，长度有单字节、双字节、四字节等等。比方说：<code>x /1xw 0x40023830</code>，表示查看0x40023830处一个四字节整数，以十六进制输出。可以<code>help x</code>来查看详细内容：<br><code>`</code><br>(gdb) help x<br>Examine memory: x/FMT ADDRESS.<br>ADDRESS is an expression for the memory address to examine.<br>FMT is a repeat count followed by a format letter and a size letter.<br>Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),<br>t(binary), f(float), a(address), i(instruction), c(char), s(string)<br>and z(hex, zero padded on the left).<br>Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).<br>The specified number of objects of the specified size are printed<br>according to the format.  If a negative number is specified, memory is<br>examined backward from the address.            </li></ul><p>Defaults for format and size letters are those previously used.<br>Default count is 1.  Default address is following last thing printed<br>with this command or “print”.</p><pre><code>* `set`，设置变量；语法：`set 变量=值`。0x40023830这个地址是STM32的外设时钟使能寄存器，有时候外设莫名其妙不能初始化、不能工作，首先看看时钟是否开了。### TUI界面--Text User InterfaceTUI简直是神器，它划分了四种窗口即`src（源代码）`、`asm（反汇编）`、`regs（寄存器）`、`cmd（命令行）`，然后通过`layout`命令来排列组合这些窗口。有了TUI，调试时候就可以全键盘操作，视觉效果不亚于使用IDE。不妨通过`layout src`来进入TUI。{% image gdb调试技巧/layoutsrc.jpeg '显示源代码' '' %}单纯显示源代码，`layout src`{% image gdb调试技巧/layoutasm.jpeg '显示反汇编' '' %}显示反汇编，`layout asm`{% image gdb调试技巧/layoutsplit.jpeg '显示源代码' '' %}显示源代码和反汇编，`layout split`{% image gdb调试技巧/layoutregs.jpeg '显示寄存器' '' %}加一个窗口显示寄存器，`layout regs`还有别的排列组合，可以通过`layout next`、`layout prev`来切换。因为开了多个窗口，上下左右方向键就不单纯控制命令行命令输入了。`焦点`一般在源代码那里，上下方向键可用来前后翻看源代码。改变焦点用`focus src`、`focus asm`、`focus regs`、`focus cmd`来实现，也可以用`focus next`和`focus prev`来循环切换焦点。要调整窗口大小，使用`winheight 哪个窗口 +行数`或者`winheight 哪个窗口 -行数`来实现。窗口即src、asm、regs、cmd四种。退出TUI，先按`Ctrl+x`，再按`a`。## gdb脚本#### 执行一系列gdb命令可以把gdb命令写到任何名字命名的文件里面，然后在调试时用`source`来执行这个脚本。#### 自定义宏比方说要查看一个链表的所有信息，假设链表定义如下：``` cstruct node {    int foo;    struct node *next;};struct node *head;</code></pre><p>要查看<code>head</code>指向的链表的所有内容，当然可以一个个地输命令<code>p head-&gt;foo</code>、<code>p head-&gt;next-&gt;foo</code>、<code>p head-&gt;next-&gt;next-&gt;foo</code>等等，显然这不优雅。</p><p>不妨定义这样一个宏，把它写入gdb脚本文件里面，或者直接在gdb命令行下面输入：</p><pre><code>define plist  set var $n = $arg0  while $n    p $n-&gt;foo    set var $n = $n-&gt;next  endend</code></pre><p>然后执行这个宏：</p><pre><code>(gdb) plist head$1 = ...$2 = ......</code></pre><p>后面就会逐行输出该链表的节点了。<br>值得一提的是，脚本里面还可以用<code>printf &quot;格式&quot;, 变量</code>来格式化输出，跟c语言printf()一样。只需将上面第4行改为<code>printf &quot;%d &quot;, $n-&gt;foo</code>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人开发C程序就像写脚本那样，查错，靠的是眼睛看；但是作为系统开发程序员，bug单纯靠看是查不出来的，于是就用printf，于是每一次查错都不可避免要机械地写printf、编译、烧写、运行，没有IDE的时候烧写、运行还不太方便。如果能在命令行下面设断点、单步调试什么的，想必是极好的。&lt;/p&gt;
&lt;p&gt;有时候开发一些程序还不得不在Ubuntu下弄，比方说国外的不少开源项目像px4、openmv之类的，又比方说Linux、nuttx之类的系统开发，等等。当然诸如Eclipse之类的IDE配置一下也能聊胜于无，但是配置它们的复杂度不亚于在命令行下面弄，而且连接板子、开gdb server这些工序只能在命令行下完成；好处是调试时候能用鼠标操作。&lt;/p&gt;
&lt;p&gt;其实，命令行下面用gdb调试，熟悉基本命令之后，用起来相当顺手；在TUI模式下面调试，视觉效果不亚于使用IDE。&lt;/p&gt;
&lt;h2 id=&quot;需要安装的软件&quot;&gt;&lt;a href=&quot;#需要安装的软件&quot; class=&quot;headerlink&quot; title=&quot;需要安装的软件&quot;&gt;&lt;/a&gt;需要安装的软件&lt;/h2&gt;&lt;h3 id=&quot;gdb&quot;&gt;&lt;a href=&quot;#gdb&quot; class=&quot;headerlink&quot; title=&quot;gdb&quot;&gt;&lt;/a&gt;gdb&lt;/h3&gt;&lt;p&gt;包管理装就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install gdb-arm-none-eabi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然也可以选用别的，比方说&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sourcery.mentor.com/GNUToolchain/package6503/public/arm-uclinuxeabi/arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;arm-uclinuxeabi-2010q1&lt;/a&gt;里面就有arm-uclinuxeabi-gdb。不过这个的TUI有问题。&lt;/li&gt;
&lt;li&gt;SourceForge的uclinux下载页面（崩掉了）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>制作arm-uclinuxeabi的交叉编译工具链</title>
    <link href="http://yoursite.com/cross-compiler/"/>
    <id>http://yoursite.com/cross-compiler/</id>
    <published>2018-02-23T15:03:53.000Z</published>
    <updated>2019-04-13T13:32:51.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交叉编译的常识"><a href="#交叉编译的常识" class="headerlink" title="交叉编译的常识"></a>交叉编译的常识</h2><p>制作交叉工具链，会涉及到三个架构的机器：</p><ul><li>build，哪个机器制作的这个编译器</li><li>host，哪个机器将运行编译器</li><li>target，编译器生成代码将会跑在哪个机器上</li></ul><p>如果build == host == target，就叫<code>native</code>编译器。这是最正常的情况。<br>如果build == host != target，就叫<code>cross</code>编译器。这就是常规意义下的交叉编译器。<br>如果build != host != target，就叫<code>canadian</code>编译器。据说在社区讨论这种情况的编译器时候，<a href="https://en.wikipedia.org/wiki/Canadian_cross" target="_blank" rel="noopener">加拿大国会有三个党，于是就这样开玩笑了</a>。。。这种情况一般用在<a href="https://en.wikipedia.org/wiki/Compile_farm" target="_blank" rel="noopener">Compile farm</a>里面。编译农场或许就是一堆树莓派，它用来编译不同架构的软件包，制作这个编译器的或许就是某台高性能的x86机器。</p><p>其他情况也有不同的叫法，参考<a href="https://stackoverflow.com/questions/5139403/whats-the-difference-of-configure-option-build-host-and-target" target="_blank" rel="noopener">这个回答</a></p><h2 id="对于Cortex-M，有哪些工具链可选？"><a href="#对于Cortex-M，有哪些工具链可选？" class="headerlink" title="对于Cortex M，有哪些工具链可选？"></a>对于Cortex M，有哪些工具链可选？</h2><ul><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/optimize-uclinux.pdf" target="_blank" rel="noopener">optimize-uclinux</a>这篇报告第34页简述了一些可用的编译器。</li><li><a href="https://toolchains.bootlin.com/" target="_blank" rel="noopener">Bootlin（以前叫Free electrons）公司</a>收录了一堆常见CPU架构的不同版本的gcc工具链。不过armv7-m的工具链貌似不行。</li><li><a href="https://sourcery.mentor.com/GNUToolchain/package6503/public/arm-uclinuxeabi/arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2" target="_blank" rel="noopener">社区推荐的arm2010-q1工具链</a>有很强的可用性。</li><li><a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads" target="_blank" rel="noopener">arm官方维护的亲儿子gcc-arm-none-eabi</a>可用用来开发裸机程序，基本没bug，适应的CPU又多。</li><li>包管理可用安装gcc-arm-none-eabi工具链，不过版本略旧与arm官网的gcc。</li><li>自己动手做arm-none-eabi或者arm-uclinuxeabi工具链。</li></ul><a id="more"></a><p><strong>个人意见</strong>：</p><ul><li>如果要弄旧的uclinux或者弄busybox的话首选arm2010-q1的工具链，经过社区的验证很好；不过gcc 4.4稍微老了点。</li><li>开发裸机，首选arm官网的工具链。</li><li>如果碰到arm2010q1的工具链里面缺乏某些Linux头文件（比方说v4l2）的情况，或者要弄新版本的Linux内核，或者单纯想换新版本的gcc、新版本内核，那就自己动手丰衣足食吧。</li></ul><h2 id="首先，稍微研究一下arm-xxxxxxxx-gcc吧"><a href="#首先，稍微研究一下arm-xxxxxxxx-gcc吧" class="headerlink" title="首先，稍微研究一下arm-xxxxxxxx-gcc吧"></a>首先，稍微研究一下arm-xxxxxxxx-gcc吧</h2><p>编译一个应用程序需要经过<strong>编译</strong>、<strong>链接</strong>两步骤。<strong>编译</strong>这一步生成obj文件，这个文件里面已经是可执行的代码了，不过并没有启动、结束的代码，也没有库文件的代码，只是在需要调用库文件的函数的地方做了记号；<strong>链接</strong>这一步，将库文件里的函数复制到最终的elf文件里面，各个记号换成对应函数的地址，是谓“链接”。比方说这样一个简单的程序<strong><em>hello.c</em></strong>：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(void){    double d = 0.12345;    printf (&quot;%lf\n&quot;, d*2.0);    return 0;}</code></pre><p>用下面的命令编译：</p><pre><code class="bash">$ arm-uclinuxeabi-gcc -g -mthumb -march=armv7-m -c hello.c -o hello.o</code></pre><p>这条命令其实是，<code>arm-uclinuxeabi-gcc hello.c</code>，加上下列参数：</p><ul><li><code>-g</code>，加入调试信息，这样的话addr2line就有用，反汇编时候可以看到C源码，而且gdb调试时候就可以知道现在程序跑到哪一行了。</li><li><code>-c</code>，仅仅编译这个文件，而不链接最终的elf。制作库文件时候用处大。</li><li><code>-o hello.o</code>，指定生成的文件名字叫hello.o。</li><li><code>-mthumb -march=armv7-m</code>，生成armv7-m的thumb2模式的代码；不加这两个参数的话会默认生成arm模式的代码。</li></ul><p>如果编译时候还加上<code>-mfloat-abi=hard</code>这个参数，那么将会生成使用fpu的代码。</p><p>我们反汇编一下hello.o看看：</p><pre><code class="bash">$ arm-uclinuxeabi-objdump -S hello.o</code></pre><p>然后输出这些东西：</p><pre><code class="c">hello.o：     文件格式 elf32-littlearmDisassembly of section .text:00000000 &lt;main&gt;:#include &lt;stdio.h&gt;int main(void){   0:    b590          push    {r4, r7, lr}   2:    b083          sub    sp, #12   4:    af00          add    r7, sp, #0    double d = 0.12345;   6:    a40c          add    r4, pc, #48    ; (adr r4, 38 &lt;main+0x38&gt;)   8:    e9d4 3400     ldrd    r3, r4, [r4]   c:    e9c7 3400     strd    r3, r4, [r7]    printf (&quot;%lf\n&quot;, d*2.0);  10:    e9d7 0100     ldrd    r0, r1, [r7]  14:    4602          mov    r2, r0  16:    460b          mov    r3, r1  18:    f7ff fffe     bl    0 &lt;__aeabi_dadd&gt;  1c:    4603          mov    r3, r0  1e:    460c          mov    r4, r1  20:    461a          mov    r2, r3  22:    4623          mov    r3, r4  24:    4806          ldr    r0, [pc, #24]    ; (40 &lt;main+0x40&gt;)  26:    f7ff fffe     bl    0 &lt;printf&gt;    return 0;  2a:    2300          movs    r3, #0}  2c:    4618          mov    r0, r3  2e:    370c          adds    r7, #12  30:    46bd          mov    sp, r7  32:    bd90          pop    {r4, r7, pc}  34:    f3af 8000     nop.w  38:    50b0f27c     .word    0x50b0f27c  3c:    3fbf9a6b     .word    0x3fbf9a6b  40:    00000000     .word    0x00000000  44:    f3af 8000     nop.w</code></pre><p>这是thumb2的汇编代码。可以看到，<code>printf (&quot;%lf\n&quot;, d*2.0)</code>引出了两个函数调用：<code>__aeabi_dadd</code>和<code>printf</code>；前者是为实现<code>d*2.0</code>这个浮点数乘法的，后者就是格式化输出的。编译器还是挺聪明的，知道乘以2可以用加法代替。</p><p>使用fpu的代码反汇编时候长这样：</p><pre><code class="c">...    printf (&quot;%lf\n&quot;, d*2.0);  10:    ed97 7b00     vldr    d7, [r7]  14:    ee37 7b07     vadd.f64    d7, d7, d7  18:    ec53 2b17     vmov    r2, r3, d7  1c:    4804          ldr    r0, [pc, #16]    ; (14 &lt;printf+0x14&gt;)  1e:    f7ff fffe     bl    0 &lt;printf&gt;...</code></pre><p>可见就不需要调用<code>__aeabi_dadd</code>了。</p><p>如果我们一步编译链接到头，对于arm-uclinuxeabi-gcc来说将会生成两个文件：</p><pre><code>$ arm-uclinuxeabi-gcc -g -mthumb -march=armv7-m hello.c -o hello$ lshello  hello.c  hello.gdb# 看看他们是啥类型的文件$ file ./*./hello:       BFLT executable - version 4 ram./hello.c:     C source, ASCII text./hello.gdb:   ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, with debug_info, not stripped</code></pre><p>其中，<code>hello</code>是最终下载到板子上运行的flt文件；<code>hello.gdb</code>是一个正常的elf文件，有它就可以在上位机上运行gdb来调试了。对它反汇编可以看到上述的待链接的标号都已经填上了。</p><pre><code class="c">    printf (&quot;%lf\n&quot;, d*2.0);      c8:    e9d7 0100     ldrd    r0, r1, [r7]      cc:    4602          mov    r2, r0      ce:    460b          mov    r3, r1      d0:    f000 f81c     bl    10c &lt;__adddf3&gt;      d4:    4603          mov    r3, r0      d6:    460c          mov    r4, r1      d8:    461a          mov    r2, r3      da:    4623          mov    r3, r4      dc:    4806          ldr    r0, [pc, #24]    ; (f8 &lt;main+0x40&gt;)      de:    f000 f9c7     bl    470 &lt;__GI_printf&gt;</code></pre><p>并且，最终的elf文件会多很多函数，这些都是库函数，比方说elf入口是<code>_start</code>，在crt1.o里面定义；<code>__adddf3</code>是浮点数的加法，在libgcc.a里面定义；等等。<br><code>arm-none-eabi</code>工具链里面缺乏启动函数，所以不能编译这样的Linux下面的应用程序，只能编译裸机程序，并且需要一个<strong><em>链接文件</em></strong>来表明哪里是入口。STM32CubeMX生成的gcc工程是很好的例子。<br><code>arm-uclinuxeabi</code>工具链里面预设了Linux应用程序的链接文件，上述hello.c可以编译过关并在uclinux平台下运行。当然它也可以弄裸机程序，此时也需要链接文件。</p><p>其实，arm的工具链可以生成不同架构的代码，关键就是<code>-mxxxx</code>这些参数；可以用<code>-print-multi-lib</code>参数来查看工具链支持哪些架构，比方说arm-none-eabi的工具链：</p><pre><code>$ arm-none-eabi-gcc -print-multi-lib.;thumb;@mthumbhard;@mfloat-abi=hardthumb/v6-m;@mthumb@march=armv6s-mthumb/v7-m;@mthumb@march=armv7-mthumb/v7e-m;@mthumb@march=armv7e-mthumb/v7-ar;@mthumb@march=armv7thumb/v8-m.base;@mthumb@march=armv8-m.basethumb/v8-m.main;@mthumb@march=armv8-m.mainthumb/v7e-m/fpv4-sp/softfp;@mthumb@march=armv7e-m@mfpu=fpv4-sp-d16@mfloat-abi=softfpthumb/v7e-m/fpv4-sp/hard;@mthumb@march=armv7e-m@mfpu=fpv4-sp-d16@mfloat-abi=hardthumb/v7e-m/fpv5-sp/softfp;@mthumb@march=armv7e-m@mfpu=fpv5-sp-d16@mfloat-abi=softfpthumb/v7e-m/fpv5-sp/hard;@mthumb@march=armv7e-m@mfpu=fpv5-sp-d16@mfloat-abi=hardthumb/v7e-m/fpv5/softfp;@mthumb@march=armv7e-m@mfpu=fpv5-d16@mfloat-abi=softfpthumb/v7e-m/fpv5/hard;@mthumb@march=armv7e-m@mfpu=fpv5-d16@mfloat-abi=hardthumb/v7-ar/fpv3/softfp;@mthumb@march=armv7@mfpu=vfpv3-d16@mfloat-abi=softfpthumb/v7-ar/fpv3/hard;@mthumb@march=armv7@mfpu=vfpv3-d16@mfloat-abi=hardthumb/v8-m.main/fpv5-sp/softfp;@mthumb@march=armv8-m.main@mfpu=fpv5-sp-d16@mfloat-abi=softfpthumb/v8-m.main/fpv5-sp/hard;@mthumb@march=armv8-m.main@mfpu=fpv5-sp-d16@mfloat-abi=hardthumb/v8-m.main/fpv5/softfp;@mthumb@march=armv8-m.main@mfpu=fpv5-d16@mfloat-abi=softfpthumb/v8-m.main/fpv5/hard;@mthumb@march=armv8-m.main@mfpu=fpv5-d16@mfloat-abi=hard</code></pre><p>解读几行：</p><ul><li>不加参数，生成的是arm模式的代码；</li><li>加<code>-mthumb</code>，生成thumb代码；</li><li>加<code>-mfloat-abi=hard</code>，生成使用硬件浮点数的代码；</li><li>加<code>-mthumb -march=armv6s-m</code>，生成armv6-m的代码（对应Cortex-M0架构）；</li><li>加<code>-mthumb -march=armv7-m</code>，生成armv7-m的代码（对应Cortex-M3、Cortex-M4、Cortex-M7架构）；</li></ul><p>之所以能支持不同的架构，不仅是因为汇编器能生成对应的代码，还因为工具链的安装目录下面为不同架构预设了库文件。这些库文件放置在特定的几个地方，可以通过<code>-print-search-dirs</code>来查看。不同的编译器略有不同。</p><p>对于arm-none-eabi-gcc：</p><pre><code>$ arm-none-eabi-gcc -print-search-dirsinstall: 某某某/lib/gcc/arm-none-eabi/6.3.1/programs: =某某某/lib/gcc/arm-none-eabi/6.3.1/:某某某/lib/gcc/:某某某/lib/gcc/arm-none-eabi/6.3.1/../../../../arm-none-eabi/bin/arm-none-eabi/6.3.1/:某某某/lib/gcc/arm-none-eabi/6.3.1/../../../../arm-none-eabi/bin/libraries: =某某某/lib/gcc/arm-none-eabi/6.3.1/:某某某/lib/gcc/:某某某/lib/gcc/arm-none-eabi/6.3.1/../../../../arm-none-eabi/lib/arm-none-eabi/6.3.1/:某某某/lib/gcc/arm-none-eabi/6.3.1/../../../../arm-none-eabi/lib/:某某某/arm-none-eabi/lib/arm-none-eabi/6.3.1/:某某某/arm-none-eabi/lib/:某某某/arm-none-eabi/usr/lib/arm-none-eabi/6.3.1/:某某某/arm-none-eabi/usr/lib/</code></pre><p>对于社区推荐的arm2010q1工具链：</p><pre><code>$ arm-uclinuxeabi-gcc -print-search-dirsinstall: 某某某/lib/gcc/arm-uclinuxeabi/4.4.1/programs: =某某某/libexec/gcc/arm-uclinuxeabi/4.4.1/:某某某/libexec/gcc/:某某某/lib/gcc/arm-uclinuxeabi/4.4.1/../../../../arm-uclinuxeabi/bin/arm-uclinuxeabi/4.4.1/:某某某/lib/gcc/arm-uclinuxeabi/4.4.1/../../../../arm-uclinuxeabi/bin/libraries: =某某某/lib/gcc/arm-uclinuxeabi/4.4.1/:某某某/lib/gcc/:某某某/lib/gcc/arm-uclinuxeabi/4.4.1/../../../../arm-uclinuxeabi/lib/arm-uclinuxeabi/4.4.1/:某某某/lib/gcc/arm-uclinuxeabi/4.4.1/../../../../arm-uclinuxeabi/lib/:某某某/arm-uclinuxeabi/libc/lib/arm-uclinuxeabi/4.4.1/:某某某/arm-uclinuxeabi/libc/lib/:某某某/arm-uclinuxeabi/libc/usr/lib/arm-uclinuxeabi/4.4.1/:某某某/arm-uclinuxeabi/libc/usr/lib/</code></pre><p>自己做的工具链：</p><pre><code>$ arm-uclinuxeabi-gcc -print-search-dirsinstall: 某某某/lib/gcc/arm-uclinuxeabi/6.4.0/programs: =某某某/libexec/gcc/arm-uclinuxeabi/6.4.0/:某某某/libexec/gcc/:某某某/lib/gcc/arm-uclinuxeabi/6.4.0/../../../../arm-uclinuxeabi/bin/arm-uclinuxeabi/6.4.0/:某某某/lib/gcc/arm-uclinuxeabi/6.4.0/../../../../arm-uclinuxeabi/bin/libraries: =某某某/lib/gcc/arm-uclinuxeabi/6.4.0/:某某某/lib/gcc/:某某某/lib/gcc/arm-uclinuxeabi/6.4.0/../../../../arm-uclinuxeabi/lib/arm-uclinuxeabi/6.4.0/:某某某/lib/gcc/arm-uclinuxeabi/6.4.0/../../../../arm-uclinuxeabi/lib/</code></pre><p>库文件来源一般有两个：gcc自带库，以及libc。制作工具链时候二者都要编译，并安装到这些目录的其中之一里面。</p><p>不同架构的这些参数，取决于gcc编译时候的配置（以及你的实现，不过一般都已经实现了的）。arm-uclinuxeabi这里有坑，稍后叙述。其他通用参数可以参考<a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html" target="_blank" rel="noopener">gcc官网上ARM工具链的参数</a>。</p><h2 id="制作arm-uclinuxeabi工具链"><a href="#制作arm-uclinuxeabi工具链" class="headerlink" title="制作arm-uclinuxeabi工具链"></a>制作arm-uclinuxeabi工具链</h2><p>不同交叉编译工具链，其实是配置出来的，毕竟编译器前端的词法语法语意优化什么的都与架构无关，而后端架构相关的部分都是不常变化的。源码里面早已有不同的配置，比方说arm-none-eabi、arm-elf、arm-uclinuxeabi等等。<br>想要制作一个<strong><em>可以编译Linux应用程序的</em></strong>交叉编译工具，需要这些源码：</p><ul><li>binutils，它包括有<code>as(汇编器)</code>、<code>ld(链接器)</code>、<code>ar(打包)</code>、<code>objdump(反汇编器)</code>、<code>objcopy(一般用来生成bin文件)</code>、<code>addr2line(查询一个地址对应源码哪一行)</code>，还有一些别的工具；</li><li>gcc，它调用别的工具。代码里还有gcc自己的底层库，比方说进行浮点数运算等的库。</li><li>Linux内核头文件，有了它你可以<code>#include &lt;linux/xxxx.h&gt;</code>。如果是裸机程序的话就不用。</li><li>libc，c库，有了它你才可以<code>printf()</code>什么的。可以选择glibc(体积很大，功能齐全)、newlib(稍小，“嵌入式友好”)、uclibc(小，功能齐全，buildroot工程的默认c库)、<a href="https://uclibc.org/other_libs.html" target="_blank" rel="noopener">其他的库</a>。<a href="http://www.etalabs.net/compare_libcs.html" target="_blank" rel="noopener">这些库性能各有不同</a>。</li></ul><p>如果要做的是arm-uclinuxeabi的工具链，因为它要生成flat可执行文件而不是传统的elf，还需要这个：</p><ul><li>elf2flt，uclinuxeabi配置的工具链在编译你的程序的最后一步，将elf转化为flt。编译器将会为应用程序生成一个flat文件和一个elf文件，后者专门用来gdb调试。</li></ul><p>值得一提的是，网上资料说，制作交叉编译工具链，gcc需要编译两次：第一次生成基本gcc，用这个gcc去编译libc，最后第二次编译gcc；很多资料说<a href="https://www6.software.ibm.com/developerworks/education/l-cross/l-cross-ltr.pdf" target="_blank" rel="noopener">两次编译都要配置</a>，<a href="http://preshing.com/20141119/how-to-build-a-gcc-cross-compiler/" target="_blank" rel="noopener">有的就说不用</a>；但是如果两次都重新配置的话，<code>gcc -v</code>会输出两次配置的参数，而现成的工具链都没有这样的输出，说明人家没有多次配置。而我经过多次编译失败后发现，gcc一次配置，分别编译gcc和libgcc两个模块，就可过关。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/binutils/binutils-2.25.tar.bz2" target="_blank" rel="noopener">binutils-2.25</a>；注意，binutils版本不要太高，亲测最新版本加入了armv8-m的支持，导致armv7-m生成的代码有问题，会触发usage fault。</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-6.3.0/gcc-6.3.0.tar.bz2" target="_blank" rel="noopener">gcc-6.3.0</a>；gcc还需要下载<a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz" target="_blank" rel="noopener">cloog</a>，<a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/gmp/gmp-6.1.2.tar.xz" target="_blank" rel="noopener">gmp</a>，<a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/isl-0.12.2.tar.bz2" target="_blank" rel="noopener">isl</a>，<a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/mpc/mpc-1.0.3.tar.gz" target="_blank" rel="noopener">mpc</a>，<a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/mpfr/mpfr-3.1.6.tar.bz2" target="_blank" rel="noopener">mpfr</a>。后面的几位如果不手动下载，gcc编译过程中会下载，国外的ftp下载的特别慢。。。</li><li><a href="https://downloads.uclibc-ng.org/releases/1.0.27/uClibc-ng-1.0.27.tar.bz2" target="_blank" rel="noopener">uclibc-ng</a>；ng代表new generation，老uclibc已经不再更新了。不同的libc编译方式不同，uclibc是<code>make menuconfig</code>、<code>make install</code>这种风格的；uclinux推荐用这个。如果是newlib，则是<code>./configure --target=xxxxxx ...</code>、<code>make</code>、<code>make install</code>这种风格的，而newlib并没有arm-uclinuxeabi的target，直接不能用。别的libc暂时没试过。。。</li><li>内核源码，不妨从<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" target="_blank" rel="noopener">清华软件源</a>里挑选一个喜欢的内核版本；kernel.org那里下载速度慢。并不是说版本越新越好，因为理论上说，Linux内核abi向后兼容，而不是向前兼容，所以较旧的内核头文件理论上来说适用性更好。</li><li><a href="https://sourceforge.net/projects/uclinux/files/Tools/m68k-uclinux-20160822/elf2flt-20160818.tar.gz/download" target="_blank" rel="noopener">elf2flt</a>；这是SourceForge下载页面，不能wget。。。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先，需要安装一些软件包。如果是Ubuntu的话，用这条命令就够了，无需逐个安装bison之类的软件包：</p><pre><code class="bash">$ sudo apt-get build-dep gcc binutils</code></pre><p>然后，新建你的安装目录和编译目录</p><pre><code class="bash">$ mkdir 某某某安装目录 某某编译目录</code></pre><p>将下载的源码解压到编译目录下面</p><pre><code class="bash">$ tar xf balabalabala -C 某某编译目录</code></pre><p>其中，将cloog、gmp、isl、mpc、mpfr这几个包都复制到gcc源码目录下面，重命名以去掉版本后缀</p><pre><code class="bash">$ mv cloog-0.18.1/ gcc-6.3.0/cloog$ mv gmp-6.1.2/    gcc-6.3.0/gmp$ mv isl-0.18/     gcc-6.3.0/isl$ mv mpc-1.0.3/    gcc-6.3.0/mpc$ mv mpfr-3.1.6/   gcc-6.3.0/mpfr</code></pre><p>binutils、gcc最好不要在源码目录下面编译。为此在它源码目录外面新建编译文件夹</p><pre><code>$ mkdir build_binutils build_gcc</code></pre><p>方便起见，建立几个环境变量</p><pre><code class="bash">$ export PREFIX=某某某安装目录$ export TARGET=arm-uclinuxeabi$ export PATH=$PATH:$PREFIX/bin</code></pre><p><code>TARGET</code>设为arm-uclinuxeabi，配置binutils、gcc时传入<code>--target=$TARGET</code>，就可以配置出arm-uclinuxeabi-xxx的工具链啦！</p><h3 id="binutils"><a href="#binutils" class="headerlink" title="binutils"></a>binutils</h3><p>在build_bintuils编译文件夹里面configure；只需要prefix和target参数就行了。然后编译安装</p><pre><code class="bash">$ ../binutils-2.25/configure --prefix=$PREFIX --target=$TARGET$ make -j4$ make install</code></pre><p>因为安装目录已经添加到<code>PATH</code>环境变量，所以此时有arm-uclinuxeabi-as之类的命令了。</p><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>前面已经将cloog、gmp、isl、mpc、mpfr放在源码目录下面了，编译时候就不用慢吞吞的从国外ftp下载了。</p><p>不过<strong>配置之前要修改gcc源码的配置文件！</strong>在configure时候，我们使用<code>--with-multilib-list</code>来指定一批不同架构的配置。方便起见，我们使用代码里面原有的rtems的配置，来生成不同架构下面的库文件，即<strong>–with-multilib-list=<code>rtems</code></strong>。</p><p>rtems配置有一大堆不同arm架构的东西，有些配置不需要并且编译不过（可能因为binutils比较老），比方说cortex m0的专门配置（要知道Cortex M0比Cortex M3晚出），比方说一堆乱七八糟的fpu，比方说R系列的芯片等等。这些都删掉。配置文件是<code>gcc/config/arm/t-rtems</code>；注意下面的<code>MULTILIB_REQUIRED</code>，我只留了armv7-m的少量配置，足够Cortex M3、M4用了。这些都会在安装目录下面某个库文件夹下单独生成文件夹。</p><pre><code># Custom RTEMS multilibs for ARMMULTILIB_OPTIONS  = mthumb march=armv7-m/mcpu=cortex-m7 mfpu=vfp/mfpu=fpv4-sp-d16 mfloat-abi=hardMULTILIB_DIRNAMES = thumb armv7-m vfp fpv4-sp-d16 fpv5-d16 hard# Enumeration of multilibsMULTILIB_EXCEPTIONS =MULTILIB_REQUIRED =MULTILIB_REQUIRED += mfpu=vfp/mfloat-abi=hardMULTILIB_REQUIRED += mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hardMULTILIB_REQUIRED += mthumb/march=armv7-mMULTILIB_REQUIRED += mthumb</code></pre><p>另外还要修改<code>gcc/config.gcc</code>，因为默认情况下并不支持rtems的配置，详见大约第3812行处。这个case一旦落入了default，就会出来说Error。我们在前面加上一段：</p><pre><code>...  rtems)                   tmake_file=&quot;${tmake_file} arm/t-rtems&quot;                           break            ;;       default)                 ;;       *)...</code></pre><p>其实，自己命名一个配置也是可以的。仿照现成的写一下就行了。<br>然后就可以开始愉快的编译了。</p><p>在build_gcc编译文件夹里面configure。</p><pre><code>$ ../gcc-6.4.0/configure --prefix=$PREFIX --target=$TARGET \  --disable-nls --disable-libssp --disable-shared --disable-threads \  --with-gnu-as --with-gnu-ld --enable-multilib --with-system-zlib \  --enable-languages=c,c++ \  --with-host-libstdcxx=&#39;-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm&#39; \  --with-multilib-list=rtems</code></pre><p>这些参数都是一步步试错而得来的。</p><p>然后，不能直接一股脑地make，要先编译gcc，再编译libgcc，最后install；不然的话会死在某些别的地方。</p><pre><code class="bash">$ make -j4 all-gcc$ make -j4 all-target-libgcc $ make install-gcc$ make install-target-libgcc </code></pre><p>然后就有arm-uclinuxeabi-gcc的命令了。</p><h3 id="内核头文件"><a href="#内核头文件" class="headerlink" title="内核头文件"></a>内核头文件</h3><p>解压内核源代码，然后安装头文件</p><pre><code class="bash">$ make ARCH=arm INSTALL_HDR_PATH=$PREFIX/arm-uclinuxeabi headers_install</code></pre><p>之所以装在这里，可详见上面<code>arm-uclinuxeabi-gcc -print-search-dirs</code>的输出。</p><h3 id="uclibc"><a href="#uclibc" class="headerlink" title="uclibc"></a>uclibc</h3><p>uclibc使用kconfig，需要一个.config文件。这里需要注意的几个配置是：</p><ul><li><code>KERNEL_HEADERS</code>，即刚刚安装内核头文件的include目录；</li><li><code>DEVEL_PREFIX</code>，编译的c库文件安装在哪。注意这是一个相对路径，我填了<code>/lib/gcc/arm-uclinuxeabi/6.4.0/</code>；</li><li><code>RUNTIME_PREFIX</code>和<code>MULTILIB_DIR</code>都不用设置；</li><li><code>CROSS_COMPILER_PREFIX</code>，填<code>arm-uclinuxeabi-</code>；</li><li><code>UCLIBC_EXTRA_CFLAGS</code>，填<code>-march=armv7-m -mthumb</code>，这样才能生成正确的thumb2指令，见本文开头的描述。</li></ul><p>然后，照常编译、安装：</p><pre><code class="bash">$ make$ make install</code></pre><h3 id="elf2flt"><a href="#elf2flt" class="headerlink" title="elf2flt"></a>elf2flt</h3><p>只适用于arm-uclinuxeabi工具链，而且只有arm-uclinuxeabi需要它。<br>它使用configure脚本，需要告诉它之前编译的binutils里面的libbfd、libiberty在哪。</p><pre><code class="bash">$ ./configure --prefix=$PREFIX --target=$TARGET \  --with-bfd-include-dir=某某某/build-binutils/bfd \  --with-libbfd=某某某/build-binutils/bfd/libbfd.a \  --with-libiberty=某某某/build-binutils/libiberty/libiberty.a \  --with-binutils-build-dir=某某某/binutils-2.29$ make$ make install</code></pre><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;交叉编译的常识&quot;&gt;&lt;a href=&quot;#交叉编译的常识&quot; class=&quot;headerlink&quot; title=&quot;交叉编译的常识&quot;&gt;&lt;/a&gt;交叉编译的常识&lt;/h2&gt;&lt;p&gt;制作交叉工具链，会涉及到三个架构的机器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;build，哪个机器制作的这个编译器&lt;/li&gt;
&lt;li&gt;host，哪个机器将运行编译器&lt;/li&gt;
&lt;li&gt;target，编译器生成代码将会跑在哪个机器上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果build == host == target，就叫&lt;code&gt;native&lt;/code&gt;编译器。这是最正常的情况。&lt;br&gt;如果build == host != target，就叫&lt;code&gt;cross&lt;/code&gt;编译器。这就是常规意义下的交叉编译器。&lt;br&gt;如果build != host != target，就叫&lt;code&gt;canadian&lt;/code&gt;编译器。据说在社区讨论这种情况的编译器时候，&lt;a href=&quot;https://en.wikipedia.org/wiki/Canadian_cross&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加拿大国会有三个党，于是就这样开玩笑了&lt;/a&gt;。。。这种情况一般用在&lt;a href=&quot;https://en.wikipedia.org/wiki/Compile_farm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Compile farm&lt;/a&gt;里面。编译农场或许就是一堆树莓派，它用来编译不同架构的软件包，制作这个编译器的或许就是某台高性能的x86机器。&lt;/p&gt;
&lt;p&gt;其他情况也有不同的叫法，参考&lt;a href=&quot;https://stackoverflow.com/questions/5139403/whats-the-difference-of-configure-option-build-host-and-target&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个回答&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;对于Cortex-M，有哪些工具链可选？&quot;&gt;&lt;a href=&quot;#对于Cortex-M，有哪些工具链可选？&quot; class=&quot;headerlink&quot; title=&quot;对于Cortex M，有哪些工具链可选？&quot;&gt;&lt;/a&gt;对于Cortex M，有哪些工具链可选？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://events.static.linuxfound.org/sites/events/files/slides/optimize-uclinux.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;optimize-uclinux&lt;/a&gt;这篇报告第34页简述了一些可用的编译器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://toolchains.bootlin.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bootlin（以前叫Free electrons）公司&lt;/a&gt;收录了一堆常见CPU架构的不同版本的gcc工具链。不过armv7-m的工具链貌似不行。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sourcery.mentor.com/GNUToolchain/package6503/public/arm-uclinuxeabi/arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;社区推荐的arm2010-q1工具链&lt;/a&gt;有很强的可用性。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;arm官方维护的亲儿子gcc-arm-none-eabi&lt;/a&gt;可用用来开发裸机程序，基本没bug，适应的CPU又多。&lt;/li&gt;
&lt;li&gt;包管理可用安装gcc-arm-none-eabi工具链，不过版本略旧与arm官网的gcc。&lt;/li&gt;
&lt;li&gt;自己动手做arm-none-eabi或者arm-uclinuxeabi工具链。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>uclinux on STM32F103ZET6</title>
    <link href="http://yoursite.com/uclinux-on-stm32f103/"/>
    <id>http://yoursite.com/uclinux-on-stm32f103/</id>
    <published>2018-02-22T15:30:11.000Z</published>
    <updated>2019-04-13T13:32:52.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用哪个BSP？"><a href="#用哪个BSP？" class="headerlink" title="用哪个BSP？"></a>用哪个BSP？</h2><p>ST为他们<a href="http://www.st.com/resource/en/application_note/cd00242717.pdf" target="_blank" rel="noopener">STM3210E-EVAL的评估板</a>制作了uClinux-dist-20080808的补丁。bootloader是一个莫名其妙的bin，kernel和rootfs放在片外nor flash里面，并且带有jffs。官方评估板又贵又买不到，不过我手上一块淘宝上一百多块钱的相似配置的板子也能玩。shell跑起来太慢了，跑个ls都要卡一两秒。</p><p>Emcraft为一些ST的板子做了第三方的BSP，其中包括<a href="https://emcraft.com/products/343" target="_blank" rel="noopener">STM32F429I-disc的uclinux BSP</a>。虽然是给STM32F4板子写的，但是它里面也包括一些STM32F1的驱动，比方说USART、DMA。做一些修改还是可以用的。这份BSP血统比较纯正，用uboot作为bootloader，uclinux内核单独抽出来编译，应用程序用的busybox，包装为ROMFS的镜像。这些东西全部都在片内flash里<code>就地执行</code>，性能颇高，在429 discovery板子上跑的很欢快。</p><p>既然要build it from scratch，那就应该好好研究Emcraft的BSP，好好学学社区的玩法吧。<a href="https://github.com/jserv/stm32f429-linux-builder" target="_blank" rel="noopener">github上有一个makefile，从头开始为429 discovery编译所有东西</a>，它从<a href="https://github.com/robutest" target="_blank" rel="noopener">robutest</a>的仓库里面下载的uboot和uclinux，我猜Emcraft的东西来源也是这个，因为里面的驱动感觉是一样的。</p><p>首先在我买的板子上跑通整个系统，然后再移植到自己的板子上。别人的板子配置颇高，有2MB的片外SRAM跟4MB的片外NOR flash，还有64MB的nand flash，完全可以跑通。我的板子只有1MB的SRAM，加上一个256MB的nand flash；配置之所以那么诡异是因为我芯片只能淘宝。。。</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/board1.jpg" alt="淘宝上的板子" title="">                </div>                <div class="image-caption">淘宝上的板子</div>            </figure><p>淘宝上的板子</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/board3.jpg" alt="自己的板子1](uclinux-on-stm32f103/board2.jpg) ![自己的板子2" title="">                </div>                <div class="image-caption">自己的板子1](uclinux-on-stm32f103/board2.jpg) ![自己的板子2</div>            </figure><p>自己做的板子</p><h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p>老代码用老编译器，新代码用新编译器。比方说新版的uboot编译时候如果用gcc 4.4，就会抱怨说将来不会支持小于6的gcc了。但是6点几的gcc编译老uboot时候，就会报错说，别名不行，以及链接文件里面不能使用变量。<br>目前的编译工具链是<a href="https://sourcery.mentor.com/GNUToolchain/package6503/public/arm-uclinuxeabi/arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2" target="_blank" rel="noopener">Emcraft推荐的arm-uclinuxeabi-2010q1</a>。</p><h2 id="跑通基本uboot"><a href="#跑通基本uboot" class="headerlink" title="跑通基本uboot"></a>跑通基本uboot</h2><p>正统的uboot跟<a href="https://github.com/robutest/u-boot" target="_blank" rel="noopener">robutest的</a>都有STM32F429的配置，不过并没有STM32F1的驱动。后者是老版本的uboot，还没有引入Kbuild，新增板子要改Makefile，配置全靠写头文件宏定义，但是编译出来的镜像更小，也比较容易裁剪。</p><p>Makefile里面添加：</p><pre><code class="makefile">stm32f103zet6_config : unconfig    @$(MKCONFIG) $(@:_config=) arm arm_cortexm3 stm32f103zet6 \    stm stm32</code></pre><p>要想在F1板子上跑起来，首先得搞定基本的驱动：时钟、串口、GPIO。为方便起见，直接在ST官方库包装一层便是了。不过ST库跟uboot都定义了一些类型，比方说u8、u32等等；如果include了两方的头文件，就会说类型重复定义。所以封装层只能够包含ST库头文件。</p><p>RCC封装层：</p><pre><code class="c">void clock_init(void);unsigned long clock_get(int);</code></pre><p>USART封装层：</p><pre><code class="c">s32 serial_init(void);void serial_setbrg(void); // 设置波特率s32 serial_getc(void);void serial_putc(const char c);void serial_puts(const char *s);s32 serial_tstc(void); // 获取串口接收状态</code></pre><p>板级初始化里面，初始化所有的GPIO：</p><pre><code class="c">int board_init(void);</code></pre><p>这个函数会在<code>lib_arm/board.c:start_armboot()</code>里面通过函数指针列表来调用。</p><p>初始化FSMC的函数，改为sram_init(void)，并且照搬ST的例程。</p><p>配置文件<code>include/configs/stm32f103zet6.h</code>里面，基本上照搬了429 discovery的配置，值得修改的地方有，时钟：</p><pre><code class="c">#define CONFIG_STM32_SYS_CLK_PLL#define CONFIG_STM32_PLL_SRC_HSE#define CONFIG_STM32_HSE_HZ        8000000        /* 8 MHz */#define CONFIG_STM32_PLL_M        4#define CONFIG_STM32_PLL_N        360#define CONFIG_STM32_PLL_P        4#define CONFIG_STM32_PLL_Q        15</code></pre><p>片内flash大小：</p><pre><code class="c">#define CONFIG_MEM_NVM_BASE        0x08000000#define CONFIG_MEM_NVM_LEN        (1024 * 512)</code></pre><p>片内SRAM：</p><pre><code class="c">#define CONFIG_MEM_RAM_BASE        0x20000000#define CONFIG_MEM_RAM_LEN        (20 * 1024)#define CONFIG_MEM_RAM_BUF_LEN        (24 * 1024)#define CONFIG_MEM_MALLOC_LEN        (16 * 1024)#define CONFIG_MEM_STACK_LEN        (4 * 1024)</code></pre><p>接在FSMC bank0 CS3的片外SRAM：</p><pre><code class="c">#define CONFIG_NR_DRAM_BANKS        1#define CONFIG_SYS_RAM_SIZE        (2 * 1024 * 1024)#define CONFIG_SYS_RAM_CS        1#define CONFIG_SYS_RAM_FREQ_DIV        2#define CONFIG_SYS_RAM_BASE        0x68000000</code></pre><p>串口配置，改为USART1：</p><pre><code class="c">#define CONFIG_STM32_USART_PORT        1    /* USART1 */#define CONFIG_STM32_USART_TX_IO_PORT    0    /* PORTA */#define CONFIG_STM32_USART_TX_IO_PIN    9    /* GPIO9 */#define CONFIG_STM32_USART_RX_IO_PORT    0    /* PORTA */#define CONFIG_STM32_USART_RX_IO_PIN    10    /* GPIO10 */#define CONFIG_BAUDRATE            115200#define CONFIG_SYS_BAUDRATE_TABLE    { 9600, 19200, 38400, 57600, 115200 }</code></pre><p>然后是一些uboot的基本设置，比方说<code>CONFIG_BOOTDELAY</code>是开始数秒的秒数，<code>CONFIG_EXTRA_ENV_SETTINGS</code>是环境变量的设置，<code>CONFIG_BOOTCOMMAND</code>是默认启动的命令。</p><pre><code class="c">#define CONFIG_BOOTDELAY        3#define CONFIG_BOOTCOMMAND        &quot;run envmboot&quot;#define CONFIG_EXTRA_ENV_SETTINGS                \        ...        &quot;envmboot=bootm ${envmaddr}\0&quot;        \        ...</code></pre><p>然后编译通过之后，启动时在读秒的时候按一下回车，可以进入uboot命令行了。可以测试一下基本命令，比方说md，mm这些读写内存的命令，来问候片外SRAM是否安好。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/uboot-basic.jpg" alt="编译进去的命令" title="">                </div>                <div class="image-caption">编译进去的命令</div>            </figure><br>编译进去的命令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/uboot-mem.jpg" alt="内存测试" title="">                </div>                <div class="image-caption">内存测试</div>            </figure><p>内存测试</p><h2 id="为uboot添加一些功能"><a href="#为uboot添加一些功能" class="headerlink" title="为uboot添加一些功能"></a>为uboot添加一些功能</h2><p>比方说，环境变量存储在片内flash里面，nand命令等等。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>封装一下ST库的flash读写：</p><pre><code class="c">void envm_init(void); // 空函数u32 envm_write(u32 offset, void * buf, u32 size); // 检测地址合法性，然后写入flash</code></pre><p>然后<code>include/configs/stm32f103zet6.h</code>里面添加一下配置。下面设置片内flash 128k之后的4k空间作为环境变量的存储区：</p><pre><code class="c">#define CONFIG_ENV_IS_IN_ENVM#define CONFIG_ENV_SIZE            (4 * 1024)#define CONFIG_ENV_ADDR         \    (CONFIG_SYS_ENVM_BASE + (128 * 1024))#define CONFIG_INFERNO            1#define CONFIG_ENV_OVERWRITE        1</code></pre><p>然后就可以用<code>setenv</code>和<code>save</code>命令了。</p><h3 id="nand-flash"><a href="#nand-flash" class="headerlink" title="nand flash"></a>nand flash</h3><p>uboot里面有简化了的mtd系统，基本上只要写了底层初始化、读写的函数就行了。</p><p>首先在<code>board_init()</code>里面补充FSMC nand flash的初始化和相应GPIO的初始化。</p><p>我在<code>drivers/mtd/nand/stm32f103zet6_nand.c</code>里面实现的底层驱动。这些都要<strong><em>老老实实去翻手册</em></strong>。以下是基本读写函数：</p><pre><code class="c">/* 发送一条命令，或写一个字节数据 */static void stm32f103_fsmc_send_cmd(struct mtd_info *mtd, int cmd, unsigned int ctrl);/* nand flash是否忙。读一下忙引脚的电平即可 */static int stm32f103_fsmc_read_rb(struct mtd_info *mtd);</code></pre><p>然后还要告诉mtd层读写函数：</p><pre><code class="c">int board_nand_init(struct nand_chip *nand){    // 设置读写寄存器的地址    nand-&gt;IO_ADDR_R = nand-&gt;IO_ADDR_W = 0x70000000;    // 前面定义的两个static函数    nand-&gt;cmd_ctrl = stm32f103_fsmc_send_cmd;    nand-&gt;dev_ready = stm32f103_fsmc_read_rb;    // mtd层帮忙做ECC    nand-&gt;ecc.mode = NAND_ECC_SOFT;    // 指定位宽：8位    nand-&gt;options = 0;    return 0;}</code></pre><p>最后在<code>include/configs/stm32f103zet6.h</code>里面添加一下配置：</p><pre><code class="c">#define CONFIG_CMD_NAND 1#define CONGIG_MTD_DEVICE#define CONFIG_SYS_MAX_NAND_DEVICE  1#define CONFIG_SYS_NAND_BASE 0x70000000</code></pre><p>然后启动时候就可以观察到NAND的东西了。mtd里面有个数组记录了很多常用nand芯片的ID和大小，并且通用的初始化什么的都做好了，相当方便。现在就可以用nand指令去问候nand flash了。比方说<code>nand dump</code>、<code>nand erase</code>、<code>nand read</code>、<code>nand write</code>等等。</p><h3 id="其他的可玩配置："><a href="#其他的可玩配置：" class="headerlink" title="其他的可玩配置："></a>其他的可玩配置：</h3><p>uboot命令行里面可以用上下方向键看历史命令：</p><pre><code class="c">#define CONFIG_CMDLINE_EDITING</code></pre><p>tab补全：</p><pre><code class="c">#define CONFIG_AUTO_COMPLETE</code></pre><p>想要在编译时候裁剪掉没有被引用的函数或数组，要在makefile里面加gcc<strong><em>编译参数</em></strong><code>-ffunction-sections -fdata-sections</code>和<strong><em>链接参数</em></strong><code>-Wl,--gc-sections</code>。因为ST库的函数太多了，可以裁掉数十kb的大小。</p><h2 id="uclinux内核配置"><a href="#uclinux内核配置" class="headerlink" title="uclinux内核配置"></a>uclinux内核配置</h2><p>好事情是，<a href="https://github.com/robutest/uclinux" target="_blank" rel="noopener">robutest的uclinux</a>里面有STM32F1的驱动，改改配置，编译出来的东西就能启动。</p><ul><li>居然有<code>CONFIG_ARCH_STM32F1</code><br>见arch/arm/mach-stm32里面的函数、头文件<br>还有drivers/serial/stm32_usart.c的<code>CONFIG_STM32_USART1</code></li><li>还有<code>CONFIG_STM32_DMA</code><br>不过grep出来的dma貌似只在drivers/mmc/host/mmci.c里面有实际作用</li><li>平台的定义<br>arch/arm/mach-stm32/stm32_platform.c<br>内核启动传参<code>stm32_platform=stm32f1-se-comm</code></li></ul><p>坏事情是，uclinux真是<strong><em>太大了</em></strong>orz。。。按照常规配置，内核大小1MB左右，只能放在片外存储器上跑。以FSMC那渣渣带宽跑起来真的很慢：淘宝上能以正常价格买到的SRAM是70ns的，换算一下也就十几兆带宽，STM32内核72MHz也没用。所以问题就在于怎样极限裁剪内核，使之能够塞进片内flash。</p><h3 id="跑起内核"><a href="#跑起内核" class="headerlink" title="跑起内核"></a>跑起内核</h3><ul><li>驱动方面，裁掉除了USART之外的其他驱动。。。</li><li>选择<code>SLOB (Simple Allocator)</code>作为slab分配器</li><li>去掉模块支持<code>CONFIG_MODULES</code></li><li>去掉sysfs和procfs。。。</li><li>去掉网络支持</li><li>去掉加密解密之类的支持</li><li>配置内存、XIP的地址<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/addrset1.jpeg" alt="内存地址" title="">                </div>                <div class="image-caption">内存地址</div>            </figure>内存地址和长度</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/addrset2.jpeg" alt="XIP地址" title="">                </div>                <div class="image-caption">XIP地址</div>            </figure><p>XIP地址</p><p>内核镜像要在它前面留有64字节的空，这是uImage的头部。需要用uboot编译出来的工具<code>mkimage</code>来生成最终的uImage。</p><pre><code class="bash">$ ../uboot/tools/mkimage -x -A arm -O linux -T kernel \  -C none -a 0x08015040 -e 0x08015041 -n &quot;linux&quot;  \  -d xipImage.bin \  xipuImage.bin</code></pre><p>注意stm32运行thumb2代码，PC最低位为1，所以是<code>-e 0x08015041</code>这个地址。</p><p>将生成的镜像烧进0x08015000，就可以启动到找不到根文件系统的kernel panic了。内核算是跑起来了。</p><h2 id="摆弄根文件系统"><a href="#摆弄根文件系统" class="headerlink" title="摆弄根文件系统"></a>摆弄根文件系统</h2><p><code>根文件系统的根</code>跟<code>vfs的根</code>不是一回事，后者是内核启动时自己凭空生成的，根据配置，会挂载有tmpfs、devtmpfs、sysfs、procfs等等，这是内核真正的根；而前者是内核启动最后一步<code>chroot</code>到的根文件系统，我们做的应用程序比如busybox就放在那里，可以配置启动文件，将sysfs之类的文件系统挂载到这里来。</p><p>我们做的根文件系统可以选择各种各样的文件系统，比方说romfs、yaffs、jffs等等，也可以用initramfs来编译进内核。uclinux的惯例是用<code>romfs</code>，因为它够小够简单（主流的Linux内核里面也有romfs的支持，那个模块就叫<code>uclinux</code>，<a href="https://elixir.bootlin.com/linux/latest/source/drivers/mtd/maps/uclinux.c" target="_blank" rel="noopener">可以参考主流内核源码drivers/mtd/maps/uclinux.c</a>）</p><h3 id="从busybox开始弄rootfs"><a href="#从busybox开始弄rootfs" class="headerlink" title="从busybox开始弄rootfs"></a>从busybox开始弄rootfs</h3><p>busybox源码从官网上下载就行了。</p><ul><li>它有<code>CONFIG_NOMMU</code>的配置</li><li><code>CONFIG_CROSS_COMPILER_PREFIX</code>设置交叉编译工具链</li><li><code>CONFIG_EXTRA_CFLAGS</code>设置为<code>-march=armv7-m -mthumb</code>，使之生成thumb2的代码</li><li><code>CONFIG_PREFIX</code>设置安装目录</li><li><p>编译时，需要SKIP_STRIP：</p><pre><code class="bash">$ make SKIP_STRIP=y...$ make install</code></pre></li><li><p>然后，那个安装目录下面就有了<code>bin</code>, <code>sbin</code>, <code>usr</code>目录了。补充上<code>etc</code>、<code>dev</code>，然后就是比较规范的根目录了。规范叫<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank" rel="noopener">“Filesystem Hierarchy Standard”</a></p><pre><code class="bash">$ ls ../rootfsbin  dev  etc  sbin  usr</code></pre></li><li><p>最后，通过<code>genromfs</code>命令来生成romfs镜像。genromfs通过包管理来安装。<br><code>`</code> bash<br>$ genromfs -v \<br>-V “ROM Disk” \<br>-f romfs.bin \<br>-x placeholder \<br>-d ./rootfs/</p><h1 id="然后输出一堆东西。。。"><a href="#然后输出一堆东西。。。" class="headerlink" title="然后输出一堆东西。。。"></a>然后输出一堆东西。。。</h1></li></ul><p>$ ls romfs.bin<br>romfs.bin</p><pre><code>这个romfs.bin就可以烧进对应地址的存储器了。### 内核开启romfs的支持* `CONFIG_BLOCK`、`CONFIG_MTD`、`CONFIG_MTD_UCLINUX`、`CONFIG_MTD_BLOCK_RO`这些是必选项。* `CONFIG_MTD_UCLINUX_PHYADDR`配置romfs的地址{% image uclinux-on-stm32f103/romfs-addr.jpeg 'romfs地址' '' %}### romfs设备文件uclinux 2.6.33的devtmpfs依赖tmpfs，后者又依赖MMU，所以不可能弄到动态生成/dev下面的设备文件节点。而romfs又是只读的，又不能mknod，所以需要将那些设备文件写死在rootfs的/dev目录下面。man genromfs可以看到：`If a file begins with the @ sign (and is empty otherwise), it refers to a device special node in the format: @name,type,major,minor. type can be b for block devices, c for character devices, and p for fifos.  The linux virtual console 1 can thus be included as a file with the name: @tty1,c,4,1`于是/dev目录下面就可以有这些东西：``` bash$ ls rootfs/dev@console,c,5,1     @rom0,b,31,0 @mem,c,1,1         @tty,c,5,0   @mtd0,c,90,0       @ttyS0,c,4,64@mtd1,c,90,2       @ttyS1,c,4,65@mtdblock1,b,31,1  @ttyS2,c,4,66@null,c,1,3        @zero,c,1,5  @ram0,b,1,0</code></pre><p>生成的romfs烧进去对应的地址，然后启动时候可以看到这些printk：</p><pre><code>ROMFS MTD (C) 2007 Red Hat, Inc....uclinux[mtd]: ROM probe address=0x681bd000 size=0x43000Creating 1 MTD partitions on &quot;ROM&quot;:0x000000000000-0x000000043000 : &quot;ROMfs&quot;</code></pre><h2 id="裁剪！"><a href="#裁剪！" class="headerlink" title="裁剪！"></a>裁剪！</h2><p>现在片内flash里已经没有空间了，只能用片外SRAM来曲线救国，通过uboot来把东西搬到SRAM，然后内核配置中romfs的地址写到那里去，然后内核参数中将内存大小缩减一点。可惜的是，这样配置的uboot、uclinux、busybox可以在人家2MB内存的板子上跑起来了，但是在我1MB内存的板子上显然是跑不动的，它会爆内存。所以这些东西都得往死里裁剪，才能塞进片内flash和1MB SRAM。</p><h3 id="uboot裁剪"><a href="#uboot裁剪" class="headerlink" title="uboot裁剪"></a>uboot裁剪</h3><p>uboot只能放在片内flash。唯一的裁剪方式是改编译参数。</p><ul><li>gcc优化参数有，<code>O0</code>, <code>O1</code>, <code>O2</code>, <code>O3</code>, <code>Os</code>。Os是optimize size的意思。试验发现，O2加上Os生成的镜像最小。</li><li>为了删去没有用到的函数和数组，要添加gcc<strong><em>编译参数</em></strong><code>-ffunction-sections -fdata-sections</code>和<strong><em>链接参数</em></strong><code>-Wl,--gc-sections</code>。<br>然后，uboot镜像可以小至80kb，可以塞进前0x15000的片内flash。</li></ul><h3 id="uclinux裁剪"><a href="#uclinux裁剪" class="headerlink" title="uclinux裁剪"></a>uclinux裁剪</h3><p>极限裁剪之后整个镜像有460k左右，加上uboot就塞不进512kb的片内flash了。我从<code>Run parts of the kernel in built-in eNVM of Cortex-M3</code>这个内核选项里面得到灵感，观察到编译出来的镜像里面有40k左右是data段，刚好可以砍出来，剩下的text段恰好挤得进去。。。而data段可以由uboot来初始化，uclinux开始那段初始化就可以屏蔽掉了。为此我添加了一个配置：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/data_sec_in_nand.jpeg" alt="砍为两半" title="">                </div>                <div class="image-caption">砍为两半</div>            </figure></p><p>在arch/arm/kernel/head-common.S:__mmap_switched函数里面屏蔽掉data段初始化：</p><pre><code class="c">        /*                      * Copy .data segment and clear BSS             * For stm32f1 device, it shuold be done in uboot beforehand,                                   * because eNVM is too small to hold them...                                                    */            #ifndef CONFIG_STM32_DATA_SEC_IS_IN_NAND               cmp     r4, r5                          @ Copy data segment if needed                  1:      cmpne   r5, r6         ldrne   fp, [r4], #4        strne   fp, [r5], #4        bne     1b#endif</code></pre><p>然后，利用uboot将data段烧进nand flash里面，启动时候从nand flash里面搬运到SRAM。</p><h3 id="busybox裁剪"><a href="#busybox裁剪" class="headerlink" title="busybox裁剪"></a>busybox裁剪</h3><ul><li>init都不要了</li><li>busybox只剩下这些东西：<br>hush, ls, dmesg, cat, free, uname</li></ul><p>最终romfs大小是110k左右，只能够靠uboot来初始化了。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/uclinux-on-stm32f103/booting.jpg" alt="启动" title="">                </div>                <div class="image-caption">启动</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用哪个BSP？&quot;&gt;&lt;a href=&quot;#用哪个BSP？&quot; class=&quot;headerlink&quot; title=&quot;用哪个BSP？&quot;&gt;&lt;/a&gt;用哪个BSP？&lt;/h2&gt;&lt;p&gt;ST为他们&lt;a href=&quot;http://www.st.com/resource/en/application_note/cd00242717.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;STM3210E-EVAL的评估板&lt;/a&gt;制作了uClinux-dist-20080808的补丁。bootloader是一个莫名其妙的bin，kernel和rootfs放在片外nor flash里面，并且带有jffs。官方评估板又贵又买不到，不过我手上一块淘宝上一百多块钱的相似配置的板子也能玩。shell跑起来太慢了，跑个ls都要卡一两秒。&lt;/p&gt;
&lt;p&gt;Emcraft为一些ST的板子做了第三方的BSP，其中包括&lt;a href=&quot;https://emcraft.com/products/343&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;STM32F429I-disc的uclinux BSP&lt;/a&gt;。虽然是给STM32F4板子写的，但是它里面也包括一些STM32F1的驱动，比方说USART、DMA。做一些修改还是可以用的。这份BSP血统比较纯正，用uboot作为bootloader，uclinux内核单独抽出来编译，应用程序用的busybox，包装为ROMFS的镜像。这些东西全部都在片内flash里&lt;code&gt;就地执行&lt;/code&gt;，性能颇高，在429 discovery板子上跑的很欢快。&lt;/p&gt;
&lt;p&gt;既然要build it from scratch，那就应该好好研究Emcraft的BSP，好好学学社区的玩法吧。&lt;a href=&quot;https://github.com/jserv/stm32f429-linux-builder&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github上有一个makefile，从头开始为429 discovery编译所有东西&lt;/a&gt;，它从&lt;a href=&quot;https://github.com/robutest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;robutest&lt;/a&gt;的仓库里面下载的uboot和uclinux，我猜Emcraft的东西来源也是这个，因为里面的驱动感觉是一样的。&lt;/p&gt;
&lt;p&gt;首先在我买的板子上跑通整个系统，然后再移植到自己的板子上。别人的板子配置颇高，有2MB的片外SRAM跟4MB的片外NOR flash，还有64MB的nand flash，完全可以跑通。我的板子只有1MB的SRAM，加上一个256MB的nand flash；配置之所以那么诡异是因为我芯片只能淘宝。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
